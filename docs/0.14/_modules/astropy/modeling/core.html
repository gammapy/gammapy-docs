

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>astropy.modeling.core &mdash; gammapy v0.14</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/gammapy_logo.ico"/>
  
  
  
    <link rel="canonical" href="https://docs.gammapy.org/dev/_modules/astropy/modeling/core.html"/>
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/copybutton.js"></script>
        <script type="text/javascript" src="../../../_static/gammapy.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gammapy.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> gammapy
          

          
          </a>

          
            
            
              <div class="version">
                0.14
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../install/dependencies.html">Gammapy Dependencies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../install/dependencies.html#required-dependencies">Required dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/dependencies.html#optional-dependencies">Optional dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/dependencies.html#versions">Versions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/conda.html">Gammapy conda installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/conda.html#background-information">Background information</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../install/conda.html#stable-version">Stable version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/check.html">Check Gammapy installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../install/check.html#how-to-run-checks">How to run checks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/check.html#common-issues">Common issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/check.html#known-issues">Known issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/pip.html">Installation with pip or setup.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../install/pip.html#install-pip">pip</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/pip.html#setup-py">setup.py</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/pip.html#development-version">Development version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/other.html">Other package managers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../install/other.html#id1">apt-get</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/other.html#id2">yum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/other.html#id3">Homebrew</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/other.html#id4">Fermi ScienceTools</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting-started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#help">Help!?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#check">Check</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#download-tutorials">Download tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#check-your-setup">Check your setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#use-gammapy">Use Gammapy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#id2">Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#id3">IPython</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#python-script">Python script</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#command-line">Command line</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#jupyter-notebooks">Jupyter notebooks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#install-issues">Install issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorial notebooks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials.html#notebooks">Notebooks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/first_steps.html">Getting started with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/first_steps.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/first_steps.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/first_steps.html#Maps">Maps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/first_steps.html#Event-lists">Event lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/first_steps.html#Source-catalogs">Source catalogs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/first_steps.html#Spectral-models-and-flux-points">Spectral models and flux points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/first_steps.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/intro_maps.html">Gammapy Maps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/intro_maps.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/intro_maps.html#0.-Setup">0. Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/intro_maps.html#1.-Creating-WCS-Maps">1. Creating WCS Maps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/intro_maps.html#2.-Accessing-and-Modifying-Data">2. Accessing and Modifying Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/intro_maps.html#3.-Reading-and-Writing">3. Reading and Writing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/intro_maps.html#4.-Visualizing-and-Plotting">4. Visualizing and Plotting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/intro_maps.html#5.-Reprojecting,-Interpolating-and-Miscellaneous">5. Reprojecting, Interpolating and Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html">CTA first data challenge (1DC) with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#Notebook-and-Gammapy-Setup">Notebook and Gammapy Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#DC-1-data">DC-1 data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#EVENT-data">EVENT data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#EVENT-analysis-example">EVENT analysis example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#IRFs">IRFs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#Index-files-and-DataStore">Index files and DataStore</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#Select-observations">Select observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#Load-data">Load data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#Model-XML-files">Model XML files</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_1dc_introduction.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html">CTA data analysis with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Select-observations">Select observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Make-sky-images">Make sky images</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Source-Detection">Source Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Spatial-analysis">Spatial analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Spectrum">Spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_data_analysis.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/analysis_3d.html">3D analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d.html#Prepare-modeling-input-data">Prepare modeling input data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d.html#Likelihood-fit">Likelihood fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d.html#Computing-Flux-Points">Computing Flux Points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d.html#Summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/analysis_3d_joint.html">Joint 3D Analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d_joint.html#Prepare-modeling-input-data">Prepare modeling input data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d_joint.html#Likelihood-fit">Likelihood fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/analysis_3d_joint.html#Plotting-residuals">Plotting residuals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/simulate_3d.html">3D simulation and fitting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/simulate_3d.html#Imports-and-versions">Imports and versions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/simulate_3d.html#Simulate">Simulate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/simulate_3d.html#Fit">Fit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/hess.html">Analysis of H.E.S.S. DL3 data with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hess.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hess.html#Analysis-configuration">Analysis configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hess.html#Observation-selection">Observation selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hess.html#Data-reduction">Data reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hess.html#Model-fitting">Model fitting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hess.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/detect_ts.html">Source detection with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Read-in-input-images">Read in input images</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Plot-images">Plot images</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Source-catalog">Source catalog</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Measurements">Measurements</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Compare-to-3FHL">Compare to 3FHL</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/detect_ts.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html">Fitting 2D images with Sherpa</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Necessary-imports">Necessary imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Making-a-PSF-Map">Making a PSF Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Make-2D-images-from-3D-ones">Make 2D images from 3D ones</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Read-the-maps-and-store-them-in-a-sherpa-model">Read the maps and store them in a sherpa model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Find-and-fit-the-brightest-source">Find and fit the brightest source</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Iteratively-find-and-fit-additional-sources">Iteratively find and fit additional sources</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Generating-output-table-and-Test-Statistics-estimation">Generating output table and Test Statistics estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_fitting_with_sherpa.html#More-about-sherpa">More about sherpa</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html">Spectral analysis with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Load-Data">Load Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Define-Target-Region">Define Target Region</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Create-exclusion-mask">Create exclusion mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Estimate-background">Estimate background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Source-statistic">Source statistic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Extract-spectrum">Extract spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Fit-spectrum">Fit spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Compute-Flux-Points">Compute Flux Points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Stack-observations">Stack observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_analysis.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/spectrum_fitting_with_sherpa.html">Fitting gammapy spectra with sherpa</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_fitting_with_sherpa.html#Load-data-stack">Load data stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_fitting_with_sherpa.html#Define-source-model">Define source model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_fitting_with_sherpa.html#Fit-and-error-estimation">Fit and error estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_fitting_with_sherpa.html#Results-plot">Results plot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_fitting_with_sherpa.html#Errors-and-confidence-contours">Errors and confidence contours</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_fitting_with_sherpa.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html">Flux point fitting in Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#Load-spectral-points">Load spectral points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#Power-Law-Fit">Power Law Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#Exponential-Cut-Off-Powerlaw-Fit">Exponential Cut-Off Powerlaw Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#Log-Parabola-Fit">Log-Parabola Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/sed_fitting_gammacat_fermi.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/fermi_lat.html">Fermi-LAT data with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Events">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Counts">Counts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Exposure">Exposure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Galactic-diffuse-background">Galactic diffuse background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Isotropic-diffuse-background">Isotropic diffuse background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#PSF">PSF</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Background">Background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Excess-and-flux">Excess and flux</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Fit">Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/fermi_lat.html#Summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/light_curve.html">Light curve estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#Select-the-data">Select the data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#Define-time-intervals">Define time intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#3D-data-reduction">3D data reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#Light-Curve-estimation:-the-3D-case">Light Curve estimation: the 3D case</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#Performing-the-same-analysis-with-1D-spectra">Performing the same analysis with 1D spectra</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/light_curve.html#Light-Curve-estimation-for-1D-spectra">Light Curve estimation for 1D spectra</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html">Estimation of the CTA point source sensitivity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Define-analysis-region-and-energy-binning">Define analysis region and energy binning</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Load-IRFs">Load IRFs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Determine-energy-dependent-integration-radius">Determine energy dependent integration radius</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Estimate-background">Estimate background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Compute-sensitivity">Compute sensitivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Results">Results</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cta_sensitivity.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/spectrum_simulation.html">Spectrum simulation for CTA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_simulation.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_simulation.html#Simulation-of-a-single-spectrum">Simulation of a single spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_simulation.html#Include-Background">Include Background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_simulation.html#Adding-a-user-defined-model">Adding a user defined model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_simulation.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/spectrum_simulation.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/image_analysis.html">Fitting 2D images with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_analysis.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_analysis.html#Prepare-modeling-input-data">Prepare modeling input data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_analysis.html#Define-a-mask">Define a mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_analysis.html#Modeling-the-source">Modeling the source</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_analysis.html#Modeling-the-background">Modeling the background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_analysis.html#Classical-Ring-Background-Analysis">Classical Ring Background Analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/image_analysis.html#Exercises">Exercises</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials.html#extra-topics">Extra topics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/hgps.html">HGPS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Notebook-Overview">Notebook Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Packages">Packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Download-Data">Download Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Catalog-with-Astropy">Catalog with Astropy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Maps-with-Astropy">Maps with Astropy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Catalog-with-Gammapy">Catalog with Gammapy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Maps-with-Gammapy">Maps with Gammapy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Conclusions">Conclusions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/hgps.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/source_population_model.html">Astrophysical source population modeling with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#Simulate-positions">Simulate positions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#Simulate-luminosities">Simulate luminosities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#Compute-observable-parameters">Compute observable parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#Check-output">Check output</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/source_population_model.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/cwt.html">CWT Algorithm</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cwt.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cwt.html#CWT-Algorithm">CWT Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/cwt.html#Results-of-analysis">Results of analysis</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/astro_dark_matter.html">Dark matter utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/astro_dark_matter.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/astro_dark_matter.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/astro_dark_matter.html#Profiles">Profiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/astro_dark_matter.html#J-Factors">J Factors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/astro_dark_matter.html#Gamma-ray-spectra-at-production">Gamma-ray spectra at production</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/astro_dark_matter.html#Flux-maps">Flux maps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/background_model.html">Make template background model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/background_model.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/background_model.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/background_model.html#Select-off-data">Select off data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/background_model.html#Background-model">Background model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/background_model.html#Zenith-dependence">Zenith dependence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/background_model.html#Index-tables">Index tables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/background_model.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html">Fitting and error estimation with MCMC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html#Simulate-an-observation">Simulate an observation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html#Estimate-parameter-correlations-with-MCMC">Estimate parameter correlations with MCMC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html#Plot-the-results">Plot the results</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html#Plot-the-model-dispersion">Plot the model dispersion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html#Fun-Zone">Fun Zone</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/mcmc_sampling.html#PeVatrons-in-CTA-?">PeVatrons in CTA ?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/pulsar_analysis.html">Pulsar analysis with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/pulsar_analysis.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/pulsar_analysis.html#Opening-the-data">Opening the data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/pulsar_analysis.html#Phasogram">Phasogram</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/pulsar_analysis.html#Phase-resolved-map">Phase-resolved map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/pulsar_analysis.html#Phase-resolved-spectrum">Phase-resolved spectrum</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials.html#basics">Basics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#publications">Publications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#glossary">Glossary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#other-gamma-ray-packages">Other gamma-ray packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#other-useful-packages">Other useful packages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#sep-30-2019">0.14 (Sep 30, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#pull-requests">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#july-26-2019">0.13 (July 26, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id2">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id3">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#may-30-2019">0.12 (May 30, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id4">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id5">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#mar-29-2019">0.11 (Mar 29, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id6">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id7">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#jan-28-2019">0.10 (Jan 28, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id8">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id9">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#nov-29-2018">0.9 (Nov 29, 2018)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id10">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id11">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#sep-23-2018">0.8 (Sep 23, 2018)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id12">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id13">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#feb-28-2018">0.7 (Feb 28, 2018)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id14">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id15">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#apr-28-2017">0.6 (Apr 28, 2017)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id16">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id17">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#nov-22-2016">0.5 (Nov 22, 2016)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id18">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id19">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#apr-20-2016">0.4 (Apr 20, 2016)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id20">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id21">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#aug-13-2015">0.3 (Aug 13, 2015)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id22">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id23">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#apr-13-2015">0.2 (Apr 13, 2015)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id24">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id25">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#aug-25-2014">0.1 (Aug 25, 2014)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id26">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id27">Pull requests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Gammapy Package</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../data/index.html">data - Data and observations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#using-gammapy-data">Using <code class="docutils literal notranslate"><span class="pre">gammapy.data</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../data/index.html#module-gammapy.data">gammapy.data Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../data/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../data/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../irf/index.html">irf - Instrument response functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#effective-area">Effective area</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#background">Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#psf">PSF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#energy-dispersion">Energy Dispersion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#using-gammapy-irf">Using <code class="docutils literal notranslate"><span class="pre">gammapy.irf</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/theory.html">IRF Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/aeff.html">Effective area</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/edisp.html">Energy dispersion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/index.html#module-gammapy.irf">gammapy.irf Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../maps/index.html">maps - Sky maps</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#constructing-with-factory-methods">Constructing with Factory Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#indexing-and-slicing">Indexing and Slicing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#accessor-methods">Accessor Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#interface-with-mapcoord-and-skycoord">Interface with <code class="docutils literal notranslate"><span class="pre">MapCoord</span></code> and <code class="docutils literal notranslate"><span class="pre">SkyCoord</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#mapcoord">MapCoord</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#interpolation">Interpolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#projection">Projection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#iterating-by-image">Iterating by image</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#fits-i-o">FITS I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#visualization">Visualization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#creating-a-counts-cube-from-an-ft1-file">Creating a Counts Cube from an FT1 File</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#generating-a-cutout-of-a-model-cube">Generating a Cutout of a Model Cube</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#using-gammapy-maps">Using <code class="docutils literal notranslate"><span class="pre">gammapy.maps</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/hpxmap.html">HEALPix-based Maps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../maps/hpxmap.html#healpix-geometry">HEALPix Geometry</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../maps/hpxmap.html#sparse-maps">Sparse Maps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/wcsmap.html">WCS-based Maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/plotting.html">Image plotting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../maps/plotting.html#colormaps">Colormaps</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#module-gammapy.maps">gammapy.maps Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../maps/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../maps/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../modeling/index.html">modeling - Models and fitting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../modeling/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../modeling/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#spectral-models">Spectral Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#spatial-models">Spatial Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#skymodel-and-skydiffusecube">SkyModel and SkyDiffuseCube</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#fitting">Fitting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modeling/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#module-gammapy.modeling">gammapy.modeling Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#module-gammapy.modeling.models">gammapy.modeling.models Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#id1">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#id2">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cube/index.html">cube - Map cube analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cube/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../cube/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../cube/index.html#using-gammapy-cube">Using <code class="docutils literal notranslate"><span class="pre">gammapy.cube</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../cube/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../cube/index.html#module-gammapy.cube">gammapy.cube Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../cube/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../cube/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../detect/index.html">detect - Source detection</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../detect/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../detect/index.html#computation-of-ts-images">Computation of TS images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../detect/index.html#computation-of-li-ma-significance-images">Computation of Li &amp; Ma significance images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../detect/index.html#using-gammapy-detect">Using <code class="docutils literal notranslate"><span class="pre">gammapy.detect</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../detect/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../detect/index.html#module-gammapy.detect">gammapy.detect Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../detect/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../detect/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../spectrum/index.html">spectrum - 1D spectrum analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../spectrum/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../spectrum/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../spectrum/index.html#using-gammapy-spectrum">Using <code class="docutils literal notranslate"><span class="pre">gammapy.spectrum</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../spectrum/fitting.html">Spectral Fitting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../spectrum/fitting.html#getting-started">Getting Started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../spectrum/fitting.html#interactive-sherpa-fit">Interactive Sherpa Fit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../spectrum/reflected.html">Reflected regions background</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../spectrum/reflected.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../spectrum/reflected.html#using-regions">Using regions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../spectrum/reflected.html#the-reflected-region-finder">The reflected region finder</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../spectrum/reflected.html#using-the-reflected-background-estimator">Using the reflected background estimator</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../spectrum/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../spectrum/index.html#module-gammapy.spectrum">gammapy.spectrum Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../spectrum/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../time/index.html">time - Time analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../time/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../time/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../time/index.html#lightcurve">Lightcurve</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../time/index.html#variability-test">Variability test</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../time/index.html#other-codes">Other codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../time/index.html#using-gammapy-time">Using <code class="docutils literal notranslate"><span class="pre">gammapy.time</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../time/period.html">Period detection and plotting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../time/period.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../time/period.html#getting-started">Getting Started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../time/period.html#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../time/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../time/index.html#module-gammapy.time">gammapy.time Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../time/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../time/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../stats/index.html">stats - Statistics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#li-ma-significance">Li &amp; Ma Significance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#confidence-intervals">Confidence Intervals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#using-gammapy-stats">Using <code class="docutils literal notranslate"><span class="pre">gammapy.stats</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/feldman_cousins.html">Feldman and Cousins Confidence Intervals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/feldman_cousins.html#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/feldman_cousins.html#acceptance-interval-fixing">Acceptance Interval Fixing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/feldman_cousins.html#sensitivity">Sensitivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/feldman_cousins.html#general-case">General Case</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/feldman_cousins.html#verification">Verification</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/fit_statistics.html">Fit statistics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#gaussian-data">Gaussian data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#poisson-data">Poisson data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#poisson-data-with-background-measurement">Poisson data with background measurement</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#further-references">Further references</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#module-gammapy.stats">gammapy.stats Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/index.html">utils - Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#time-handling-in-gammapy">Time handling in Gammapy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#time-format-and-scale">Time format and scale</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#mission-elapsed-times-met">Mission elapsed times (MET)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#time-differences">Time differences</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.units">gammapy.utils.units Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.coordinates">gammapy.utils.coordinates Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id3">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#variables">Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.integrate">gammapy.utils.integrate Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id4">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.interpolation">gammapy.utils.interpolation Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id5">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.table">gammapy.utils.table Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id6">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.fits">gammapy.utils.fits Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#gammapy-fits-utilities">Gammapy FITS utilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id7">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id8">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.random">gammapy.utils.random Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id9">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id10">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.regions">gammapy.utils.regions Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id11">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.scripts">gammapy.utils.scripts Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id12">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.testing">gammapy.utils.testing Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id13">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id14">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.nddata">gammapy.utils.nddata Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id15">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id16">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.time">gammapy.utils.time Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id17">Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">scripts - High-level interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#configuration-and-methods">Configuration and methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#general-settings">General settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#observations-selection">Observations selection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#data-reduction-and-datasets">Data reduction and datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#model">Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#fitting">Fitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#flux-points">Flux points</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#residuals">Residuals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#using-the-high-level-interface">Using the high-level interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#command-line-tools">Command line tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/cli.html">scripts - Command line tools</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/cli.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/cli.html#reference">Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/cli.html#implementation">Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/cli.html#limitations">Limitations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/cli.html#plan">Plan</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/cli.html#write-your-own-cli">Write your own CLI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/cli.html#reference-api">Reference/API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#module-gammapy.scripts">gammapy.scripts Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../catalog/index.html">catalog - Source catalogs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../catalog/index.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../catalog/index.html#available-catalogs">Available catalogs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../catalog/index.html#how-it-works">How it works</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../catalog/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../catalog/index.html#using-gammapy-catalog">Using <code class="docutils literal notranslate"><span class="pre">gammapy.catalog</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../catalog/gammacat.html">gamma-cat</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../catalog/gammacat.html#catalog">Catalog</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../catalog/gammacat.html#data-collection">Data collection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../catalog/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../catalog/index.html#module-gammapy.catalog">gammapy.catalog Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../catalog/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../catalog/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../astro/index.html">astro - Astrophysics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../astro/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../astro/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../astro/index.html#sub-packages">Sub-packages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../astro/source/index.html">Astrophysical source models (<code class="docutils literal notranslate"><span class="pre">gammapy.astro.source</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#using-gammapy-astro-source">Using <code class="docutils literal notranslate"><span class="pre">gammapy.astro.source</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#reference-api">Reference/API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../astro/population/index.html">Astrophysical source population models (<code class="docutils literal notranslate"><span class="pre">gammapy.astro.population</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/population/index.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/population/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/population/index.html#reference-api">Reference/API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../astro/darkmatter/index.html">Dark matter (<code class="docutils literal notranslate"><span class="pre">gammapy.astro.darkmatter</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#other-packages">Other packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#using-gammapy-spectrum">Using <code class="docutils literal notranslate"><span class="pre">gammapy.spectrum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#reference-api">Reference/API</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../development/index.html">Developer documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../development/intro.html">How to contribute to Gammapy?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/setup.html">Gammapy project setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/howto.html">Developer HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/release.html">How to make a Gammapy release</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/pigs/index.html">PIGs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-001.html">PIG 1 - PIG purpose and guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-002.html">PIG 2 - Organization of low-level analysis code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-003.html">PIG 3 - Plan for dropping Python 2.7 support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-004.html">PIG 4 - Setup for tutorial notebooks and data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-005.html">PIG 5 - Gammapy 1.0 Roadmap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-009.html">PIG 9 - Event Sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-010.html">PIG 10 - Regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-012.html">PIG 12 - High-level interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-013.html">PIG 13 - Gammapy dependencies and distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-016.html">PIG 16 - Gammapy package structure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/dataformats.html">Data Formats</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gammapy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>astropy.modeling.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for astropy.modeling.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines base classes for all models.  The base class of all</span>
<span class="sd">models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is</span>
<span class="sd">the base class for all fittable models. Fittable models can be linear or</span>
<span class="sd">nonlinear in a regression analysis sense.</span>

<span class="sd">All models provide a `__call__` method which performs the transformation in</span>
<span class="sd">a purely mathematical way, i.e. the models are unitless.  Model instances can</span>
<span class="sd">represent either a single model, or a &quot;model set&quot; representing multiple copies</span>
<span class="sd">of the same type of model, but with potentially different values of the</span>
<span class="sd">parameters in each model making up the set.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">copyreg</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">suppress</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">islice</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="k">import</span> <span class="n">indent</span><span class="p">,</span> <span class="n">metadata</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="k">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="k">import</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">UnitsError</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span>
<span class="kn">from</span> <span class="nn">astropy.units.utils</span> <span class="k">import</span> <span class="n">quantity_asanyarray</span>
<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="k">import</span> <span class="p">(</span><span class="n">sharedmethod</span><span class="p">,</span> <span class="n">find_current_module</span><span class="p">,</span>
                           <span class="n">InheritDocstrings</span><span class="p">,</span> <span class="n">OrderedDescriptorContainer</span><span class="p">,</span>
                           <span class="n">check_broadcast</span><span class="p">,</span> <span class="n">IncompatibleShapeError</span><span class="p">,</span> <span class="n">isiterable</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">astropy.utils.codegen</span> <span class="k">import</span> <span class="n">make_function_with_signature</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="k">import</span> <span class="n">AstropyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="p">(</span><span class="n">combine_labels</span><span class="p">,</span> <span class="n">make_binary_operator_eval</span><span class="p">,</span>
                    <span class="n">ExpressionTree</span><span class="p">,</span> <span class="n">AliasDict</span><span class="p">,</span> <span class="n">get_inputs_and_params</span><span class="p">,</span>
                    <span class="n">_BoundingBox</span><span class="p">,</span> <span class="n">_combine_equivalency_dict</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">astropy.nddata.utils</span> <span class="k">import</span> <span class="n">add_array</span><span class="p">,</span> <span class="n">extract_array</span>

<span class="kn">from</span> <span class="nn">.parameters</span> <span class="k">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">InputParameterError</span><span class="p">,</span> <span class="n">param_repr_oneline</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="s1">&#39;FittableModel&#39;</span><span class="p">,</span> <span class="s1">&#39;Fittable1DModel&#39;</span><span class="p">,</span> <span class="s1">&#39;Fittable2DModel&#39;</span><span class="p">,</span>
           <span class="s1">&#39;custom_model&#39;</span><span class="p">,</span> <span class="s1">&#39;ModelDefinitionError&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ModelDefinitionError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for incorrect models definitions&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_model_oper</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a function that evaluates a given Python arithmetic operator</span>
<span class="sd">    between two models.  The operator should be given as a string, like ``&#39;+&#39;``</span>
<span class="sd">    or ``&#39;**&#39;``.</span>

<span class="sd">    Any additional keyword arguments passed in are passed to</span>
<span class="sd">    `_CompoundModelMeta._from_operator`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Note: Originally this used functools.partial, but that won&#39;t work when</span>
    <span class="c1"># used in the class definition of _CompoundModelMeta since</span>
    <span class="c1"># _CompoundModelMeta has not been defined yet.</span>

    <span class="k">def</span> <span class="nf">_opfunc</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="c1"># Deprecation is for https://github.com/astropy/astropy/issues/8234</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Model</span><span class="p">)):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Composition of model classes will be removed in 4.0 &#39;</span>
                <span class="s1">&#39;(but composition of model instances is not affected)&#39;</span><span class="p">,</span>
                <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>

        <span class="c1"># Perform an arithmetic operation on two models.</span>
        <span class="k">return</span> <span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">_from_operator</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_opfunc</span>


<span class="k">class</span> <span class="nc">_ModelMeta</span><span class="p">(</span><span class="n">OrderedDescriptorContainer</span><span class="p">,</span> <span class="n">InheritDocstrings</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metaclass for Model.</span>

<span class="sd">    Currently just handles auto-generating the param_names list based on</span>
<span class="sd">    Parameter descriptors declared at the class-level of Model subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_is_dynamic</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This flag signifies whether this class was created in the &quot;normal&quot; way,</span>
<span class="sd">    with a class statement in the body of a module, as opposed to a call to</span>
<span class="sd">    `type` or some other metaclass constructor, such that the resulting class</span>
<span class="sd">    does not belong to a specific module.  This is important for pickling of</span>
<span class="sd">    dynamic classes.</span>

<span class="sd">    This flag is always forced to False for new classes, so code that creates</span>
<span class="sd">    dynamic classes should manually set it to True on those classes when</span>
<span class="sd">    creating them.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default empty dict for _parameters_, which will be empty on model</span>
    <span class="c1"># classes that don&#39;t have any Parameters</span>
    <span class="n">_parameters_</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="c1"># See the docstring for _is_dynamic above</span>
        <span class="k">if</span> <span class="s1">&#39;_is_dynamic&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="n">members</span><span class="p">[</span><span class="s1">&#39;_is_dynamic&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcls</span><span class="o">.</span><span class="n">_is_dynamic</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="c1"># Make sure OrderedDescriptorContainer gets to run before doing</span>
        <span class="c1"># anything else</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_param_names&#39;</span><span class="p">):</span>
                <span class="c1"># Slight kludge to support compound models, where</span>
                <span class="c1"># cls.param_names is a property; could be improved with a</span>
                <span class="c1"># little refactoring but fine for now</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_inverse_property</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_bounding_box_property</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handle_special_methods</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom repr for Model subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repr for IPython&#39;s pretty printer.</span>

<span class="sd">        By default IPython &quot;pretty prints&quot; classes, so we need to implement</span>
<span class="sd">        this so that IPython displays the custom repr for Models.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_dynamic</span><span class="p">:</span>
            <span class="c1"># Just return a string specifying where the class can be imported</span>
            <span class="c1"># from</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">members</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="c1"># Delete any ABC-related attributes--these will be restored when</span>
            <span class="c1"># the class is reconstructed:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">members</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_abc_&#39;</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">members</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># Delete custom __init__ and __call__ if they exist:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">members</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">),</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="n">members</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of this model class--equivalent to ``cls.__name__``.</span>

<span class="sd">        This attribute is provided for symmetry with the `Model.name` attribute</span>
<span class="sd">        of model instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_concrete</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class-level property that determines whether the class is a concrete</span>
<span class="sd">        implementation of a Model--i.e. it is not some abstract base class or</span>
<span class="sd">        internal implementation detail (i.e. begins with &#39;_&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of this model class with a new name.</span>

<span class="sd">        The new class is technically a subclass of the original class, so that</span>
<span class="sd">        instance and type checks will still work.  For example::</span>

<span class="sd">            &gt;&gt;&gt; from astropy.modeling.models import Rotation2D</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation = Rotation2D.rename(&#39;SkyRotation&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation</span>
<span class="sd">            &lt;class &#39;__main__.SkyRotation&#39;&gt;</span>
<span class="sd">            Name: SkyRotation (Rotation2D)</span>
<span class="sd">            Inputs: (&#39;x&#39;, &#39;y&#39;)</span>
<span class="sd">            Outputs: (&#39;x&#39;, &#39;y&#39;)</span>
<span class="sd">            Fittable parameters: (&#39;angle&#39;,)</span>
<span class="sd">            &gt;&gt;&gt; issubclass(SkyRotation, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; r = SkyRotation(90)</span>
<span class="sd">            &gt;&gt;&gt; isinstance(r, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span>

        <span class="n">new_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,),</span> <span class="p">{})</span>
        <span class="n">new_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">modname</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
                <span class="c1"># __main__ is not added to a class&#39;s qualified name</span>
                <span class="n">new_cls</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_cls</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_cls</span>

    <span class="k">def</span> <span class="nf">_create_inverse_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inverse&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="c1"># The latter clause is the prevent the below code from running on</span>
            <span class="c1"># the Model base class, which implements the default getter and</span>
            <span class="c1"># setter for .inverse</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="c1"># We allow the @property decorator to be omitted entirely from</span>
            <span class="c1"># the class definition, though its use should be encouraged for</span>
            <span class="c1"># clarity</span>
            <span class="n">inverse</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">fget</span>

        <span class="c1"># Store the inverse getter internally, then delete the given .inverse</span>
        <span class="c1"># attribute so that cls.inverse resolves to Model.inverse instead</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_inverse</span> <span class="o">=</span> <span class="n">inverse</span>
        <span class="k">del</span> <span class="bp">cls</span><span class="o">.</span><span class="n">inverse</span>

    <span class="k">def</span> <span class="nf">_create_bounding_box_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes any bounding_box defined on a concrete Model subclass (either</span>
<span class="sd">        as a fixed tuple or a property or method) and wraps it in the generic</span>
<span class="sd">        getter/setter interface for the bounding_box attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Much of this is verbatim from _create_inverse_property--I feel</span>
        <span class="c1"># like there could be a way to generify properties that work this way,</span>
        <span class="c1"># but for the time being that would probably only confuse things more.</span>
        <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bounding_box&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span><span class="o">.</span><span class="n">fget</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">):</span>
            <span class="c1"># See if it&#39;s a hard-coded bounding_box (as a sequence) and</span>
            <span class="c1"># normalize it</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">_BoundingBox</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">)</span>
            <span class="c1"># May be a method that only takes &#39;self&#39; as an argument (like a</span>
            <span class="c1"># property, but the @property decorator was forgotten)</span>
            <span class="c1"># TODO: Maybe warn in the above case?</span>
            <span class="c1">#</span>
            <span class="c1"># However, if the method takes additional arguments then this is a</span>
            <span class="c1"># parameterized bounding box and should be callable</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> \
                        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_bounding_box_subclass</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

        <span class="c1"># See the Model.bounding_box getter definition for how this attribute</span>
        <span class="c1"># is used</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="k">del</span> <span class="bp">cls</span><span class="o">.</span><span class="n">bounding_box</span>

    <span class="k">def</span> <span class="nf">_create_bounding_box_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For Models that take optional arguments for defining their bounding</span>
<span class="sd">        box, we create a subclass of _BoundingBox with a ``__call__`` method</span>
<span class="sd">        that supports those additional arguments.</span>

<span class="sd">        Takes the function&#39;s Signature as an argument since that is already</span>
<span class="sd">        computed in _create_bounding_box_property, so no need to duplicate that</span>
<span class="sd">        effort.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Might be convenient if calling the bounding box also</span>
        <span class="c1"># automatically sets the _user_bounding_box.  So that</span>
        <span class="c1">#</span>
        <span class="c1">#    &gt;&gt;&gt; model.bounding_box(arg=1)</span>
        <span class="c1">#</span>
        <span class="c1"># in addition to returning the computed bbox, also sets it, so that</span>
        <span class="c1"># it&#39;s a shortcut for</span>
        <span class="c1">#</span>
        <span class="c1">#    &gt;&gt;&gt; model.bounding_box = model.bounding_box(arg=1)</span>
        <span class="c1">#</span>
        <span class="c1"># Not sure if that would be non-obvious / confusing though...</span>

        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Presumed to be a &#39;self&#39; argument</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s1">&#39;The bounding_box method for </span><span class="si">{0}</span><span class="s1"> is not correctly &#39;</span>
                    <span class="s1">&#39;defined: If defined as a method all arguments to that &#39;</span>
                    <span class="s1">&#39;method (besides self) must be keyword arguments with &#39;</span>
                    <span class="s1">&#39;default values that can be used to compute a default &#39;</span>
                    <span class="s1">&#39;bounding box.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="n">kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">))</span>

        <span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;_</span><span class="si">{0}</span><span class="s1">BoundingBox&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="p">)),</span> <span class="p">(</span><span class="n">_BoundingBox</span><span class="p">,),</span>
                    <span class="p">{</span><span class="s1">&#39;__call__&#39;</span><span class="p">:</span> <span class="fm">__call__</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_handle_special_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>

        <span class="c1"># Handle init creation from inputs</span>
        <span class="k">def</span> <span class="nf">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="c1"># Set up the new __call__&#39;s metadata attributes as though it were</span>
            <span class="c1"># manually defined in the class definition</span>
            <span class="c1"># A bit like functools.update_wrapper but uses the class instead of</span>
            <span class="c1"># the wrapped function</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="vm">__doc__</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">):</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;__call__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="s1">&#39;inputs&#39;</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)):</span>

            <span class="c1"># Don&#39;t create a custom __call__ for classes that already have one</span>
            <span class="c1"># explicitly defined (this includes the Model base class, and any</span>
            <span class="c1"># other classes that manually override __call__</span>

            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Evaluate this model on the supplied inputs.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># When called, models can take two optional keyword arguments:</span>
            <span class="c1">#</span>
            <span class="c1"># * model_set_axis, which indicates (for multi-dimensional input)</span>
            <span class="c1">#   which axis is used to indicate different models</span>
            <span class="c1">#</span>
            <span class="c1"># * equivalencies, a dictionary of equivalencies to be applied to</span>
            <span class="c1">#   the input values, where each key should correspond to one of</span>
            <span class="c1">#   the inputs.</span>
            <span class="c1">#</span>
            <span class="c1"># The following code creates the __call__ function with these</span>
            <span class="c1"># two keyword arguments.</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">inputs</span>
            <span class="n">new_call</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                    <span class="fm">__call__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                     <span class="p">(</span><span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                     <span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
                                     <span class="p">(</span><span class="s1">&#39;equivalencies&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>

            <span class="c1"># The following makes it look like __call__ was defined in the class</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_call</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span> <span class="o">=</span> <span class="n">new_call</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;__init__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">):</span>

            <span class="c1"># If *all* the parameters have default values we can make them</span>
            <span class="c1"># keyword arguments; otherwise they must all be positional arguments</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                    <span class="n">default</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span>
                    <span class="c1"># If the unit was specified in the parameter but the default</span>
                    <span class="c1"># is not a Quantity, attach the unit to the default.</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">default</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param_name</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">new_init</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                    <span class="fm">__init__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">varkwargs</span><span class="o">=</span><span class="s1">&#39;kwargs&#39;</span><span class="p">)</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_init</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">new_init</span>

    <span class="c1"># *** Arithmetic operators for creating compound models ***</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="c1"># *** Other utilities ***</span>

    <span class="k">def</span> <span class="nf">_format_cls_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For the sake of familiarity start the output with the standard class</span>
        <span class="c1"># __repr__</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">format_inheritance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)):</span>
                    <span class="k">break</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bases</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> (</span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; -&gt; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bases</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="n">format_inheritance</span><span class="p">(</span><span class="bp">cls</span><span class="p">)),</span>
                <span class="p">(</span><span class="s1">&#39;Inputs&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;Outputs&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">default_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Fittable parameters&#39;</span><span class="p">,</span>
                                         <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span> <span class="o">+</span> <span class="n">keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If any of the above formatting fails fall back on the basic repr</span>
            <span class="c1"># (this is particularly useful in debugging)</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_ModelMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all models.</span>

<span class="sd">    This is an abstract class and should not be instantiated directly.</span>

<span class="sd">    This class sets the constraints and other properties for all individual</span>
<span class="sd">    parameters and performs parameter validation.</span>

<span class="sd">    The following initialization arguments apply to the majority of Model</span>
<span class="sd">    subclasses by default (exceptions include specialized utility models</span>
<span class="sd">    like `~astropy.modeling.mappings.Mapping`).  Parametric models take all</span>
<span class="sd">    their parameters as arguments, followed by any of the following optional</span>
<span class="sd">    keyword arguments:</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A human-friendly name associated with this model instance</span>
<span class="sd">        (particularly useful for identifying the individual components of a</span>
<span class="sd">        compound model).</span>

<span class="sd">    meta : dict, optional</span>
<span class="sd">        An optional dict of user-defined metadata to attach to this model.</span>
<span class="sd">        How this is used and interpreted is up to the user or individual use</span>
<span class="sd">        case.</span>

<span class="sd">    n_models : int, optional</span>
<span class="sd">        If given an integer greater than 1, a *model set* is instantiated</span>
<span class="sd">        instead of a single model.  This affects how the parameter arguments</span>
<span class="sd">        are interpreted.  In this case each parameter must be given as a list</span>
<span class="sd">        or array--elements of this array are taken along the first axis (or</span>
<span class="sd">        ``model_set_axis`` if specified), such that the Nth element is the</span>
<span class="sd">        value of that parameter for the Nth model in the set.</span>

<span class="sd">        See the section on model sets in the documentation for more details.</span>

<span class="sd">    model_set_axis : int, optional</span>
<span class="sd">        This argument only applies when creating a model set (i.e. ``n_models &gt;</span>
<span class="sd">        1``).  It changes how parameter values are interpreted.  Normally the</span>
<span class="sd">        first axis of each input parameter array (properly the 0th axis) is</span>
<span class="sd">        taken as the axis corresponding to the model sets.  However, any axis</span>
<span class="sd">        of an input array may be taken as this &quot;model set axis&quot;.  This accepts</span>
<span class="sd">        negative integers as well--for example use ``model_set_axis=-1`` if the</span>
<span class="sd">        last (most rapidly changing) axis should be associated with the model</span>
<span class="sd">        sets. Also, ``model_set_axis=False`` can be used to tell that a given</span>
<span class="sd">        input should be used to evaluate all the models in the model set.</span>

<span class="sd">    fixed : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: bool}`` setting the fixed constraint</span>
<span class="sd">        for one or more parameters.  `True` means the parameter is held fixed</span>
<span class="sd">        during fitting and is prevented from updates once an instance of the</span>
<span class="sd">        model has been created.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.fixed` property of a</span>
<span class="sd">        parameter may be used to lock or unlock individual parameters.</span>

<span class="sd">    tied : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: callable}`` of parameters which are</span>
<span class="sd">        linked to some other parameter. The dictionary values are callables</span>
<span class="sd">        providing the linking relationship.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.tied` property of a</span>
<span class="sd">        parameter may be used to set the ``tied`` constraint on individual</span>
<span class="sd">        parameters.</span>

<span class="sd">    bounds : dict, optional</span>
<span class="sd">        A dictionary ``{parameter_name: value}`` of lower and upper bounds of</span>
<span class="sd">        parameters. Keys are parameter names. Values are a list or a tuple</span>
<span class="sd">        of length 2 giving the desired range for the parameter.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.min` and</span>
<span class="sd">        `~astropy.modeling.Parameter.max` or</span>
<span class="sd">        ~astropy.modeling.Parameter.bounds` properties of a parameter may be</span>
<span class="sd">        used to set bounds on individual parameters.</span>

<span class="sd">    eqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``eqcons[j](x0, *args) == 0.0``</span>
<span class="sd">        in a successfully optimized problem.</span>

<span class="sd">    ineqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``ieqcons[j](x0, *args) &gt;=</span>
<span class="sd">        0.0`` is a successfully optimized problem.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.modeling import models</span>
<span class="sd">    &gt;&gt;&gt; def tie_center(model):</span>
<span class="sd">    ...         mean = 50 * model.stddev</span>
<span class="sd">    ...         return mean</span>
<span class="sd">    &gt;&gt;&gt; tied_parameters = {&#39;mean&#39;: tie_center}</span>

<span class="sd">    Specify that ``&#39;mean&#39;`` is a tied parameter in one of two ways:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        tied=tied_parameters)</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied = tie_center</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    &lt;function tie_center at 0x...&gt;</span>

<span class="sd">    Fixed parameters:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        fixed={&#39;stddev&#39;: True})</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed = True</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameter_constraints</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">constraints</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that can be set on a model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model_constraints</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;eqcons&#39;</span><span class="p">,</span> <span class="s1">&#39;ineqcons&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that constrain model evaluation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">param_names</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Names of the parameters that describe models of this type.</span>

<span class="sd">    The parameters in this tuple are in the same order they should be passed in</span>
<span class="sd">    when initializing a model of a specific type.  Some types of models, such</span>
<span class="sd">    as polynomial models, have a different number of parameters depending on</span>
<span class="sd">    some other property of the model, such as the degree.</span>

<span class="sd">    When defining a custom model class the value of this attribute is</span>
<span class="sd">    automatically set by the `~astropy.modeling.Parameter` attributes defined</span>
<span class="sd">    in the class body.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;The name(s) of the input variable(s) on which a model is evaluated.&quot;&quot;&quot;</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;The name(s) of the output(s) of the model.&quot;&quot;&quot;</span>

    <span class="n">standard_broadcasting</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_separable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot; A boolean flag to indicate whether a model is separable.&quot;&quot;&quot;</span>

    <span class="n">meta</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">MetaData</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;A dict-like object to store optional information.&quot;&quot;&quot;</span>

    <span class="c1"># By default models either use their own inverse property or have no</span>
    <span class="c1"># inverse at all, but users may also assign a custom inverse to a model,</span>
    <span class="c1"># optionally; in that case it is of course up to the user to determine</span>
    <span class="c1"># whether their inverse is *actually* an inverse to the model they assign</span>
    <span class="c1"># it to.</span>
    <span class="n">_inverse</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_user_inverse</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Default n_models attribute, so that __len__ is still defined even when a</span>
    <span class="c1"># model hasn&#39;t completed initialization yet</span>
    <span class="n">_n_models</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># New classes can set this as a boolean value.</span>
    <span class="c1"># It is converted to a dictionary mapping input name to a boolean value.</span>
    <span class="n">_input_units_strict</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Allow dimensionless input (and corresponding output). If this is True,</span>
    <span class="c1"># input values to evaluate will gain the units specified in input_units. If</span>
    <span class="c1"># this is a dictionary then it should map input name to a bool to allow</span>
    <span class="c1"># dimensionless numbers for that input.</span>
    <span class="c1"># Only has an effect if input_units is defined.</span>
    <span class="n">_input_units_allow_dimensionless</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Default equivalencies to apply to input values. If set, this should be a</span>
    <span class="c1"># dictionary where each key is a string that corresponds to one of the</span>
    <span class="c1"># model inputs. Only has an effect if input_units is defined.</span>
    <span class="n">input_units_equivalencies</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_constraints</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Remaining keyword args are either parameter values or invalid</span>
        <span class="c1"># Parameter values must be passed in as keyword arguments in order to</span>
        <span class="c1"># distinguish them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_unit_support</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize_unit_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert self._input_units_strict and</span>
<span class="sd">        self.input_units_allow_dimensionless to dictionaries</span>
<span class="sd">        mapping input name to a boolena value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span> <span class="k">for</span>
                                        <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span>
                                                     <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_strict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enforce strict units on inputs to evaluate. If this is set to True,</span>
<span class="sd">        input values to evaluate will be in the exact units specified by</span>
<span class="sd">        input_units. If the input quantities are convertible to input_units,</span>
<span class="sd">        they are converted. If this is a dictionary then it should map input</span>
<span class="sd">        name to a bool to set strict input units for that parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_allow_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow dimensionless input (and corresponding output). If this is True,</span>
<span class="sd">        input values to evaluate will gain the units specified in input_units. If</span>
<span class="sd">        this is a dictionary then it should map input name to a bool to allow</span>
<span class="sd">        dimensionless numbers for that input.</span>
<span class="sd">        Only has an effect if input_units is defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uses_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if this model has been created with `~astropy.units.Quantity`</span>
<span class="sd">        objects or if there are no parameters.</span>

<span class="sd">        This can be used to determine if this model should be evaluated with</span>
<span class="sd">        `~astropy.units.Quantity` or regular floats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pisq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pisq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">pisq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_str</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate this model using the given input(s) and the parameter values</span>
<span class="sd">        that were specified when the model was instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">format_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inputs</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">(</span><span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">with_bbox</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">with_bbox</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># bounding_box is in python order - convert it to the order of the inputs</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>
                <span class="c1"># indices where input is outside the bbox</span>
                <span class="c1"># have a value of 1 in ``nan_ind``</span>
                <span class="n">nan_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                    <span class="c1"># Pass an ``out`` array so that ``axis_ind`` is array for scalars as well.</span>
                    <span class="n">axis_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="n">axis_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">inp</span> <span class="o">&lt;</span> <span class="n">bbox</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">inp</span> <span class="o">&gt;</span> <span class="n">bbox</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">axis_ind</span><span class="p">)</span>
                    <span class="n">nan_ind</span><span class="p">[</span><span class="n">axis_ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># get an array with indices of valid inputs</span>
                <span class="n">valid_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">nan_ind</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="c1"># inputs holds only inputs within the bbox</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="c1"># shape is ()</span>
                        <span class="k">if</span> <span class="n">nan_ind</span><span class="p">:</span>
                            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fill_value</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="n">valid_ind</span><span class="p">])</span>
                <span class="n">valid_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">valid_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">valid_result</span><span class="p">]</span>
                <span class="c1"># combine the valid results with the ``fill_value`` values</span>
                <span class="c1"># outside the bbox</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">fill_value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_result</span><span class="p">))]</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valid_result</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="c1"># shape is ()</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">valid_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="c1"># format output</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_outputs</span><span class="p">(</span><span class="n">format_info</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span>

    <span class="c1"># *** Arithmetic operators for creating compound models ***</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="c1"># *** Properties ***</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;User-provided name for this model instance.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign a (new) name to this model.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of inputs to this model.</span>

<span class="sd">        Equivalent to ``len(model.inputs)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of outputs from this model.</span>

<span class="sd">        Equivalent to ``len(model.outputs)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of the model set axis--that is the axis of a parameter array</span>
<span class="sd">        that pertains to which model a parameter value pertains to--as</span>
<span class="sd">        specified when the model was initialized.</span>

<span class="sd">        See the documentation on `Model Sets</span>
<span class="sd">        &lt;http://docs.astropy.org/en/stable/modeling/models.html#model-sets&gt;`_</span>
<span class="sd">        for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return parameters as a pset.</span>

<span class="sd">        This is a list with one item per parameter set, which is an array of</span>
<span class="sd">        that parameter&#39;s values across all parameter sets, with the last axis</span>
<span class="sd">        associated with the parameter set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flattened array of all parameter values in all parameter sets.</span>

<span class="sd">        Fittable parameters maintain this list and fitters modify it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Currently the sequence of a model&#39;s parameters must be contiguous</span>
        <span class="c1"># within the _parameters array (which may be a view of a larger array,</span>
        <span class="c1"># for example when taking a sub-expression of a compound model), so</span>
        <span class="c1"># the assumption here is reliable:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="c1"># Trivial, but not unheard of</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>

    <span class="nd">@parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigning to this attribute updates the parameters array rather than</span>
<span class="sd">        replacing it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s2">&quot;Input parameter values not compatible with the model &quot;</span>
                <span class="s2">&quot;parameters array: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fixed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `dict` mapping parameter names to their fixed constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s1">&#39;fixed&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tied</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `dict` mapping parameter names to their tied constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s1">&#39;tied&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `dict` mapping parameter names to their upper and lower bounds as</span>
<span class="sd">        ``(min, max)`` tuples or ``[min, max]`` lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter equality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s1">&#39;eqcons&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter inequality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s1">&#39;ineqcons&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `~astropy.modeling.Model` instance which performs the</span>
<span class="sd">        inverse transform, if an analytic inverse is defined for this model.</span>

<span class="sd">        Even on models that don&#39;t have an inverse defined, this property can be</span>
<span class="sd">        set with a manually-defined inverse, such a pre-computed or</span>
<span class="sd">        experimentally determined inverse (often given as a</span>
<span class="sd">        `~astropy.modeling.polynomial.PolynomialModel`, but not by</span>
<span class="sd">        requirement).</span>

<span class="sd">        A custom inverse can be deleted with ``del model.inverse``.  In this</span>
<span class="sd">        case the model&#39;s inverse is reset to its default, if a default exists</span>
<span class="sd">        (otherwise the default is to raise `NotImplementedError`).</span>

<span class="sd">        Note to authors of `~astropy.modeling.Model` subclasses:  To define an</span>
<span class="sd">        inverse for a model simply override this property to return the</span>
<span class="sd">        appropriate model representing the inverse.  The machinery that will</span>
<span class="sd">        make the inverse manually-overridable is added automatically by the</span>
<span class="sd">        base class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span><span class="p">()</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;An analytical inverse transform has not &quot;</span>
                                  <span class="s2">&quot;been implemented for this model.&quot;</span><span class="p">)</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ``inverse`` attribute may be assigned a `Model` &quot;</span>
                <span class="s2">&quot;instance or `None` (where `None` explicitly forces the &quot;</span>
                <span class="s2">&quot;model to have no inverse.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the model&#39;s inverse to its default (if one exists, otherwise</span>
<span class="sd">        the model will have no inverse).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom inverse model has been</span>
<span class="sd">        assigned to this model by a user, via assignment to ``model.inverse``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `tuple` of length `n_inputs` defining the bounding box limits, or</span>
<span class="sd">        `None` for no bounding box.</span>

<span class="sd">        The default limits are given by a ``bounding_box`` property or method</span>
<span class="sd">        defined in the class body of a specific model.  If not defined then</span>
<span class="sd">        this property just raises `NotImplementedError` by default (but may be</span>
<span class="sd">        assigned a custom value by a user).  ``bounding_box`` can be set</span>
<span class="sd">        manually to an array-like object of shape ``(model.n_inputs, 2)``. For</span>
<span class="sd">        further usage, see :ref:`bounding-boxes`</span>

<span class="sd">        The limits are ordered according to the `numpy` indexing</span>
<span class="sd">        convention, and are the reverse of the model input order,</span>
<span class="sd">        e.g. for inputs ``(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;)``, ``bounding_box`` is defined:</span>

<span class="sd">        * for 1D: ``(x_low, x_high)``</span>
<span class="sd">        * for 2D: ``((y_low, y_high), (x_low, x_high))``</span>
<span class="sd">        * for 3D: ``((z_low, z_high), (y_low, y_high), (x_low, x_high))``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Setting the ``bounding_box`` limits for a 1D and 2D model:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import Gaussian1D, Gaussian2D</span>
<span class="sd">        &gt;&gt;&gt; model_1d = Gaussian1D()</span>
<span class="sd">        &gt;&gt;&gt; model_2d = Gaussian2D(x_stddev=1, y_stddev=1)</span>
<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box = (-5, 5)</span>
<span class="sd">        &gt;&gt;&gt; model_2d.bounding_box = ((-6, 6), (-5, 5))</span>

<span class="sd">        Setting the bounding_box limits for a user-defined 3D `custom_model`:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import custom_model</span>
<span class="sd">        &gt;&gt;&gt; def const3d(x, y, z, amp=1):</span>
<span class="sd">        ...    return amp</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Const3D = custom_model(const3d)</span>
<span class="sd">        &gt;&gt;&gt; model_3d = Const3D()</span>
<span class="sd">        &gt;&gt;&gt; model_3d.bounding_box = ((-6, 6), (-5, 5), (-4, 4))</span>

<span class="sd">        To reset ``bounding_box`` to its default limits just delete the</span>
<span class="sd">        user-defined value--this will reset it back to the default defined</span>
<span class="sd">        on the class:</span>

<span class="sd">        &gt;&gt;&gt; del model_1d.bounding_box</span>

<span class="sd">        To disable the bounding box entirely (including the default),</span>
<span class="sd">        set ``bounding_box`` to `None`:</span>

<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box = None</span>
<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">          File &quot;astropy\modeling\core.py&quot;, line 980, in bounding_box</span>
<span class="sd">            &quot;No bounding box is defined for this model (note: the &quot;</span>
<span class="sd">        NotImplementedError: No bounding box is defined for this model (note:</span>
<span class="sd">        the bounding box was explicitly disabled for this model; use `del</span>
<span class="sd">        model.bounding_box` to restore the default bounding box, if one is</span>
<span class="sd">        defined for this model).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;No bounding box is defined for this model (note: the &quot;</span>
                    <span class="s2">&quot;bounding box was explicitly disabled for this model; &quot;</span>
                    <span class="s2">&quot;use `del model.bounding_box` to restore the default &quot;</span>
                    <span class="s2">&quot;bounding box, if one is defined for this model).&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;No bounding box is defined for this model.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">_BoundingBox</span><span class="p">):</span>
            <span class="c1"># This typically implies a hard-coded bounding box.  This will</span>
            <span class="c1"># probably be rare, but it is an option</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The only other allowed possibility is that it&#39;s a _BoundingBox</span>
            <span class="c1"># subclass, so we call it with its default arguments and return an</span>
            <span class="c1"># instance of it (that can be called to recompute the bounding box</span>
            <span class="c1"># with any optional parameters)</span>
            <span class="c1"># (In other words, in this case self._bounding_box is a *class*)</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">((),</span> <span class="n">_model</span><span class="o">=</span><span class="bp">self</span><span class="p">)()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">_model</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@bounding_box</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns the bounding box limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># We use this to explicitly set an unimplemented bounding box (as</span>
            <span class="c1"># opposed to no user bounding box defined)</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">_BoundingBox</span><span class="p">)):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">_BoundingBox</span>

        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>

    <span class="nd">@bounding_box</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom bounding_box has been</span>
<span class="sd">        assigned to this model by a user, via assignment to</span>
<span class="sd">        ``model.bounding_box``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A flag indicating whether a model is separable.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;The &quot;separable&quot; property is not defined for &#39;</span>
                <span class="s1">&#39;model </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="c1"># *** Public methods ***</span>

    <span class="k">def</span> <span class="nf">without_units_for_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of the model for which the parameter values have been</span>
<span class="sd">        converted to the right units for the data, then the units have been</span>
<span class="sd">        stripped away.</span>

<span class="sd">        The input and output Quantity objects should be given as keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is needed in order to be able to fit models with units in</span>
<span class="sd">        the parameters, since we need to temporarily strip away the units from</span>
<span class="sd">        the model during the fitting (which might be done by e.g. scipy</span>
<span class="sd">        functions).</span>

<span class="sd">        The units that the parameters should be converted to are not necessarily</span>
<span class="sd">        the units of the input data, but are derived from them. Model subclasses</span>
<span class="sd">        that want fitting to work in the presence of quantities need to define a</span>
<span class="sd">        _parameter_units_for_data_units method that takes the input and output</span>
<span class="sd">        units (as two dictionaries) and returns a dictionary giving the target</span>
<span class="sd">        units for each parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">inputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">outputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">parameter_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">inputs_unit</span><span class="p">,</span> <span class="n">outputs_unit</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">parameter_units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parameter</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parameter</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">quantity</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">parameter</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">_CompoundModel</span><span class="p">):</span>
            <span class="n">model</span><span class="o">.</span><span class="n">strip_units_from_tree</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">strip_units_from_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">traverse_inorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">parname</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                    <span class="n">par</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">parname</span><span class="p">)</span>
                    <span class="n">par</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">parname</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_units_from_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of the model which has units for which the parameter</span>
<span class="sd">        values are compatible with the data units specified.</span>

<span class="sd">        The input and output Quantity objects should be given as keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is needed in order to be able to fit models with units in</span>
<span class="sd">        the parameters, since we need to temporarily strip away the units from</span>
<span class="sd">        the model during the fitting (which might be done by e.g. scipy</span>
<span class="sd">        functions).</span>

<span class="sd">        The units that the parameters will gain are not necessarily the units of</span>
<span class="sd">        the input data, but are derived from them. Model subclasses that want</span>
<span class="sd">        fitting to work in the presence of quantities need to define a</span>
<span class="sd">        _parameter_units_for_data_units method that takes the input and output</span>
<span class="sd">        units (as two dictionaries) and returns a dictionary giving the target</span>
<span class="sd">        units for each parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">inputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">outputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">parameter_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">inputs_unit</span><span class="p">,</span> <span class="n">outputs_unit</span><span class="p">)</span>

        <span class="c1"># We are adding units to parameters that already have a value, but we</span>
        <span class="c1"># don&#39;t want to convert the parameter, just add the unit directly, hence</span>
        <span class="c1"># the call to _set_unit.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">parameter_units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">parameter</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_has_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Returns True if any of the parameters have units</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_supports_unit_fitting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If the model has a &#39;_parameter_units_for_data_units&#39; method, this</span>
        <span class="c1"># indicates that we have enough information to strip the units away</span>
        <span class="c1"># and add them back after fitting, when fitting quantities</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_parameter_units_for_data_units&#39;</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the model on some input variables.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sum_of_implicit_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the sum of any implicit model terms on some input variables.</span>
<span class="sd">        This includes any fixed terms used in evaluating a linear model that</span>
<span class="sd">        do not have corresponding parameters exposed to the user. The</span>
<span class="sd">        prototypical case is `astropy.modeling.functional_models.Shift`, which</span>
<span class="sd">        corresponds to a function y = a + bx, where b=1 is intrinsically fixed</span>
<span class="sd">        by the type of model, such that sum_of_implicit_terms(x) == x. This</span>
<span class="sd">        method is needed by linear fitters to correct the dependent variable</span>
<span class="sd">        for the implicit term(s) when solving for the remaining terms</span>
<span class="sd">        (ie. a = y - bx).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a model at fixed positions, respecting the ``bounding_box``.</span>

<span class="sd">        The key difference relative to evaluating the model directly is that</span>
<span class="sd">        this method is limited to a bounding box if the `Model.bounding_box`</span>
<span class="sd">        attribute is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            An array that the evaluated model will be added to.  If this is not</span>
<span class="sd">            given (or given as ``None``), a new array will be created.</span>
<span class="sd">        coords : array-like, optional</span>
<span class="sd">            An array to be used to translate from the model&#39;s input coordinates</span>
<span class="sd">            to the ``out`` array. It should have the property that</span>
<span class="sd">            ``self(coords)`` yields the same shape as ``out``.  If ``out`` is</span>
<span class="sd">            not specified, ``coords`` will be used to determine the shape of the</span>
<span class="sd">            returned array. If this is not provided (or None), the model will be</span>
<span class="sd">            evaluated on a grid determined by `Model.bounding_box`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            The model added to ``out`` if  ``out`` is not ``None``, or else a</span>
<span class="sd">            new array from evaluating the model over ``coords``.</span>
<span class="sd">            If ``out`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">            limited to the `Model.bounding_box` limits. If</span>
<span class="sd">            `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be passed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``coords`` are not given and the the `Model.bounding_box` of this</span>
<span class="sd">            model is not set.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`bounding-boxes`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set, &#39;</span>
                             <span class="s1">&#39;coords or out must be input.&#39;</span><span class="p">)</span>

        <span class="c1"># for consistent indexing</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Check dimensions match out and model</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndim</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;inconsistent shape of the output.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the array and model must have the same &#39;</span>
                                 <span class="s1">&#39;number of dimensions.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># assures position is at center pixel, important when using add_array</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">pd</span>

            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;The `bounding_box` is larger than the input out in &#39;</span>
                        <span class="s1">&#39;one or more dimensions. Set &#39;</span>
                        <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_shape</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property is used to indicate what units or sets of units the</span>
<span class="sd">        evaluate method expects, and returns a dictionary mapping inputs to</span>
<span class="sd">        units (or `None` if any units are accepted).</span>

<span class="sd">        Model sub-classes can also use function annotations in evaluate to</span>
<span class="sd">        indicate valid input units, in which case this property should</span>
<span class="sd">        not be overridden since it will return the input units based on the</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_input_units&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">):</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="o">.</span><span class="vm">__annotations__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">annotations</span><span class="p">:</span>
                <span class="c1"># If there are not annotations for all inputs this will error.</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">annotations</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># None means any unit is accepted</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">return_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property is used to indicate what units or sets of units the output</span>
<span class="sd">        of evaluate should be in, and returns a dictionary mapping outputs to</span>
<span class="sd">        units (or `None` if any units are accepted).</span>

<span class="sd">        Model sub-classes can also use function annotations in evaluate to</span>
<span class="sd">        indicate valid output units, in which case this property should not be</span>
<span class="sd">        overridden since it will return the return units based on the</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_return_units&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_units</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="o">.</span><span class="vm">__annotations__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># None means any unit is accepted</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">prepare_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used in `~astropy.modeling.Model.__call__` to ensure</span>
<span class="sd">        that all the inputs to the model can be broadcast into compatible</span>
<span class="sd">        shapes (if one or both of them are input as arrays), particularly if</span>
<span class="sd">        there are more than one parameter sets. This also makes sure that (if</span>
<span class="sd">        applicable) the units of the input will be compatible with the evaluate</span>
<span class="sd">        method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># When we instantiate the model class, we make sure that __call__ can</span>
        <span class="c1"># take the following two keyword arguments: model_set_axis and</span>
        <span class="c1"># equivalencies.</span>

        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># By default the model_set_axis for the input is assumed to be the</span>
            <span class="c1"># same as that for the parameters the model was defined with</span>
            <span class="c1"># TODO: Ensure that negative model_set_axis arguments are respected</span>
            <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span>

        <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">_input</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="n">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span>
                               <span class="n">model_set_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>

        <span class="c1"># The input formatting required for single models versus a multiple</span>
        <span class="c1"># model set are different enough that they&#39;ve been split into separate</span>
        <span class="c1"># subroutines</span>
        <span class="k">if</span> <span class="n">n_models</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_inputs_single_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_inputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span>
                                             <span class="n">model_set_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="c1"># Check that the units are correct, if applicable</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># We combine any instance-level input equivalencies with user</span>
            <span class="c1"># specified ones at call-time.</span>
            <span class="n">input_units_equivalencies</span> <span class="o">=</span> <span class="n">_combine_equivalency_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                                                  <span class="n">equivalencies</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">input_units_equivalencies</span><span class="p">)</span>

            <span class="c1"># We now iterate over the different inputs and make sure that their</span>
            <span class="c1"># units are consistent with those specified in input_units.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)):</span>

                <span class="n">input_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">input_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Quantity</span><span class="p">):</span>

                    <span class="c1"># We check for consistency of the units with input_units,</span>
                    <span class="c1"># taking into account any equivalencies</span>

                    <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">input_unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">input_name</span><span class="p">]):</span>

                        <span class="c1"># If equivalencies have been specified, we need to</span>
                        <span class="c1"># convert the input to the input units - this is because</span>
                        <span class="c1"># some equivalencies are non-linear, and we need to be</span>
                        <span class="c1"># sure that we evaluate the model in its own frame</span>
                        <span class="c1"># of reference. If input_units_strict is set, we also</span>
                        <span class="c1"># need to convert to the input units.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_units_equivalencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units_strict</span><span class="p">[</span><span class="n">input_name</span><span class="p">]:</span>
                            <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">input_unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">input_name</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="c1"># We consider the following two cases separately so as</span>
                        <span class="c1"># to be able to raise more appropriate/nicer exceptions</span>

                        <span class="k">if</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="n">dimensionless_unscaled</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: Units of input &#39;</span><span class="si">{1}</span><span class="s2">&#39;, </span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{3}</span><span class="s2">), could not be &quot;</span>
                                             <span class="s2">&quot;converted to required dimensionless &quot;</span>
                                             <span class="s2">&quot;input&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                            <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                                                            <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: Units of input &#39;</span><span class="si">{1}</span><span class="s2">&#39;, </span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{3}</span><span class="s2">), could not be &quot;</span>
                                             <span class="s2">&quot;converted to required input units of &quot;</span>
                                             <span class="s2">&quot;</span><span class="si">{4}</span><span class="s2"> (</span><span class="si">{5}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                                                                <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">,</span>
                                                                <span class="n">input_unit</span><span class="p">,</span>
                                                                <span class="n">input_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># If we allow dimensionless input, we add the units to the</span>
                    <span class="c1"># input values without conversion, otherwise we raise an</span>
                    <span class="c1"># exception.</span>

                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units_allow_dimensionless</span><span class="p">[</span><span class="n">input_name</span><span class="p">]</span> <span class="ow">and</span>
                       <span class="n">input_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dimensionless_unscaled</span> <span class="ow">and</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: Units of input &#39;</span><span class="si">{1}</span><span class="s2">&#39;, (dimensionless), could not be &quot;</span>
                                             <span class="s2">&quot;converted to required input units of &quot;</span>
                                             <span class="s2">&quot;</span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{3}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">input_unit</span><span class="p">,</span>
                                                                <span class="n">input_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">inputs</span>

    <span class="k">def</span> <span class="nf">_process_output_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">inputs_are_quantity</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span> <span class="ow">and</span> <span class="n">inputs_are_quantity</span><span class="p">:</span>
            <span class="c1"># We allow a non-iterable unit only if there is one output</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_units</span><span class="p">):</span>
                <span class="n">return_units</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span>

            <span class="n">outputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Quantity</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">return_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">out_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">outputs</span>

    <span class="k">def</span> <span class="nf">prepare_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_info</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_outputs_single_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_outputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model.</span>

<span class="sd">        Uses a deep copy so that all model attributes, including parameter</span>
<span class="sd">        values, are copied as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deep copy of this model.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model with a new name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">new_model</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">n_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of components in a single model, which is</span>
<span class="sd">        obviously 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="c1"># *** Internal methods ***</span>
    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">_from_existing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">existing</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new instance of ``cls`` that shares its underlying parameter</span>
<span class="sd">        values with an existing model instance given by ``existing``.</span>

<span class="sd">        This is used primarily by compound models to return a view of an</span>
<span class="sd">        individual component of a compound model.  ``param_names`` should be</span>
<span class="sd">        the names of the parameters in the *existing* model to use as the</span>
<span class="sd">        parameters in this new model.  Its length should equal the number of</span>
<span class="sd">        parameters this model takes, so that it can map parameters on the</span>
<span class="sd">        existing model to parameters on this model one-to-one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Basically this is an alternative __init__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="c1"># self is a class, not an instance</span>
            <span class="n">needs_initialization</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">dummy_args</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">dummy_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">needs_initialization</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">aliases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">param_names</span><span class="p">))</span>
        <span class="c1"># This is basically an alternative _initialize_constraints</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cons_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_constraints</span><span class="p">:</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="n">cons_type</span><span class="p">]</span>
            <span class="n">constraints</span><span class="p">[</span><span class="n">cons_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">AliasDict</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">aliases</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">constraints</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_n_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_model_set_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_parameters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param_a</span><span class="p">,</span> <span class="n">param_b</span> <span class="ow">in</span> <span class="n">aliases</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Take the param metrics info for the giving parameters in the</span>
            <span class="c1"># existing model, and hand them to the appropriate parameters in</span>
            <span class="c1"># the new model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">param_a</span><span class="p">]</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">param_b</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">needs_initialization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">dummy_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_initialize_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop parameter constraint values off the keyword arguments passed to</span>
<span class="sd">        `Model.__init__` and store them in private instance attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_constraints&#39;</span><span class="p">):</span>
            <span class="c1"># Skip constraint initialization if it has already been handled via</span>
            <span class="c1"># an alternate initialization</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Pop any constraints off the keyword arguments</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Update with default parameter constraints</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>

                <span class="c1"># Parameters don&#39;t have all constraint types</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_initialize_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the _parameters array that stores raw parameter values for</span>
<span class="sd">        all parameter sets for use with vectorized fitting algorithms; on</span>
<span class="sd">        FittableModels the _param_name attributes actually just reference</span>
<span class="sd">        slices of this array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_parameters&#39;</span><span class="p">):</span>
            <span class="c1"># Skip parameter initialization if it has already been handled via</span>
            <span class="c1"># an alternate initialization</span>
            <span class="k">return</span>

        <span class="n">n_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_models&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n_models</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;n_models must be either None (in which case it is &quot;</span>
                <span class="s2">&quot;determined from the model_set_axis of the parameter initial &quot;</span>
                <span class="s2">&quot;values) or it must be a positive integer &quot;</span>
                <span class="s2">&quot;(got </span><span class="si">{0!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_models</span><span class="p">))</span>

        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Default to zero</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise disable</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;model_set_axis must be either False or an integer &quot;</span>
                    <span class="s2">&quot;specifying the parameter array axis to map to each &quot;</span>
                    <span class="s2">&quot;model in a set of models (got </span><span class="si">{0!r}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">model_set_axis</span><span class="p">))</span>

        <span class="c1"># Process positional arguments by matching them up with the</span>
        <span class="c1"># corresponding parameters in self.param_names--if any also appear as</span>
        <span class="c1"># keyword arguments this presents a conflict</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() takes at most </span><span class="si">{1}</span><span class="s2"> positional arguments (</span><span class="si">{2}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;given)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">model_set_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># A value of None implies using the default value, if exists</span>
                <span class="k">continue</span>
            <span class="c1"># We use quantity_asanyarray here instead of np.asanyarray because</span>
            <span class="c1"># if any of the arguments are quantities, we need to return a</span>
            <span class="c1"># Quantity object not a plain Numpy array.</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">quantity_asanyarray</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># At this point the only remaining keyword arguments should be</span>
        <span class="c1"># parameter names; any others are in error.</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() got multiple values for parameter &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">param_name</span><span class="p">))</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># We use quantity_asanyarray here instead of np.asanyarray because</span>
                <span class="c1"># if any of the arguments are quantities, we need to return a</span>
                <span class="c1"># Quantity object not a plain Numpy array.</span>
                <span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_asanyarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># If any keyword arguments were left over at this point they are</span>
            <span class="c1"># invalid--the base class should only be passed the parameter</span>
            <span class="c1"># values, constraints, and param_dim</span>
            <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="c1"># Just raise an error on the first unrecognized argument</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.__init__() got an unrecognized parameter &#39;</span>
                    <span class="s1">&#39;</span><span class="si">{1!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">))</span>

        <span class="c1"># Determine the number of model sets: If the model_set_axis is</span>
        <span class="c1"># None then there is just one parameter set; otherwise it is determined</span>
        <span class="c1"># by the size of that axis on the first parameter--if the other</span>
        <span class="c1"># parameters don&#39;t have the right number of axes or the sizes of their</span>
        <span class="c1"># model_set_axis don&#39;t match an error is raised</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">max_ndim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">min_ndim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="s2">&quot;All parameter values must be arrays of dimension &quot;</span>
                        <span class="s2">&quot;at least </span><span class="si">{0}</span><span class="s2"> for model_set_axis=</span><span class="si">{1}</span><span class="s2"> (the value &quot;</span>
                        <span class="s2">&quot;given for </span><span class="si">{2!r}</span><span class="s2"> is only </span><span class="si">{3}</span><span class="s2">-dimensional)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">min_ndim</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">param_ndim</span><span class="p">))</span>

                <span class="n">max_ndim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_ndim</span><span class="p">,</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Use the dimensions of the first parameter to determine</span>
                    <span class="c1"># the number of model sets</span>
                    <span class="n">n_models</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="s2">&quot;Inconsistent dimensions for parameter </span><span class="si">{0!r}</span><span class="s2"> for &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2"> model sets.  The length of axis </span><span class="si">{2}</span><span class="s2"> must be the &quot;</span>
                        <span class="s2">&quot;same for all input parameter values&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">max_ndim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_models</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="n">n_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_values</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_parameter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="c1"># self._param_metrics should have been initialized in</span>
        <span class="c1"># self._initialize_parameters</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">param_descr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">default</span>

                <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># No value was supplied for the parameter and the</span>
                    <span class="c1"># parameter does not have a default, therefore the model</span>
                    <span class="c1"># is underspecified</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() requires a value for parameter &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

                <span class="n">value</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">unit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">param_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="n">param_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">param_size</span><span class="p">)</span>

            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_slice</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_shape</span>

            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() requires a Quantity for parameter &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;orig_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;raw_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">_setter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_val</span> <span class="o">=</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">_setter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_val</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;raw_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_val</span><span class="o">.</span><span class="n">unit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;raw_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">total_size</span> <span class="o">+=</span> <span class="n">param_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">param_metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Now set the parameter values (this will also fill</span>
        <span class="c1"># self._parameters)</span>
        <span class="c1"># TODO: This is a bit ugly, but easier to deal with than how this was</span>
        <span class="c1"># done previously.  There&#39;s still lots of opportunity for refactoring</span>
        <span class="c1"># though, in particular once we move the _get/set_model_value methods</span>
        <span class="c1"># out of Parameter and into Model (renaming them</span>
        <span class="c1"># _get/set_parameter_value)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># value here may be a Quantity object.</span>
            <span class="n">param_descr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">orig_unit</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;orig_unit&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">_setter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">param_descr</span><span class="o">.</span><span class="n">_setter</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">orig_unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">param_descr</span><span class="o">.</span><span class="n">_setter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Finally validate all the parameters; we do this last so that</span>
        <span class="c1"># validators that depend on one of the other parameters&#39; values will</span>
        <span class="c1"># work</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">param_descr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">param_descr</span><span class="o">.</span><span class="n">validator</span><span class="p">(</span><span class="n">param_descr</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_param_broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">max_ndim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This subroutine checks that all parameter arrays can be broadcast</span>
<span class="sd">        against each other, and determines the shapes parameters must have in</span>
<span class="sd">        order to broadcast correctly.</span>

<span class="sd">        If model_set_axis is None this merely checks that the parameters</span>
<span class="sd">        broadcast and returns an empty dict if so.  This mode is only used for</span>
<span class="sd">        single model sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="c1"># Previously this just used iteritems(params), but we loop over all</span>
            <span class="c1"># param_names instead just to ensure some determinism in the</span>
            <span class="c1"># ordering behavior</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">value</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># We&#39;ve already checked that each parameter array is compatible in</span>
            <span class="c1"># the model_set_axis dimension, but now we need to check the</span>
            <span class="c1"># dimensions excluding that axis</span>
            <span class="c1"># Split the array dimensions into the axes before model_set_axis</span>
            <span class="c1"># and after model_set_axis</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="n">param_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_ndim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">max_ndim</span><span class="p">:</span>
                <span class="c1"># All arrays have the same number of dimensions up to the</span>
                <span class="c1"># model_set_axis dimension, but after that they may have a</span>
                <span class="c1"># different number of trailing axes.  The number of trailing</span>
                <span class="c1"># axes must be extended for mutual compatibility.  For example</span>
                <span class="c1"># if max_ndim = 3 and model_set_axis = 0, an array with the</span>
                <span class="c1"># shape (2, 2) must be extended to (2, 1, 2).  However, an</span>
                <span class="c1"># array with shape (2,) is extended to (2, 1).</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_ndim</span> <span class="o">-</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Just need to prepend axes to make up the difference</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">param_shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">param_shape</span><span class="p">[:</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">new_axes</span> <span class="o">+</span>
                                       <span class="n">param_shape</span><span class="p">[</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;broadcast_shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_shape</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>

        <span class="c1"># Now check mutual broadcastability of all shapes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">IncompatibleShapeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">shape_a</span><span class="p">,</span> <span class="n">shape_a_idx</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">,</span> <span class="n">shape_b_idx</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span>
            <span class="n">param_a</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="n">shape_a_idx</span><span class="p">]</span>
            <span class="n">param_b</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="n">shape_b_idx</span><span class="p">]</span>

            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s2">&quot;Parameter </span><span class="si">{0!r}</span><span class="s2"> of shape </span><span class="si">{1!r}</span><span class="s2"> cannot be broadcast with &quot;</span>
                <span class="s2">&quot;parameter </span><span class="si">{2!r}</span><span class="s2"> of shape </span><span class="si">{3!r}</span><span class="s2">.  All parameter arrays &quot;</span>
                <span class="s2">&quot;must have shapes that are mutually compatible according &quot;</span>
                <span class="s2">&quot;to the broadcasting rules.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_a</span><span class="p">,</span> <span class="n">shape_a</span><span class="p">,</span>
                                                    <span class="n">param_b</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of the Model.param_sets property.</span>

<span class="sd">        This internal implementation has a ``raw`` argument which controls</span>
<span class="sd">        whether or not to return the raw parameter values (i.e. the values that</span>
<span class="sd">        are actually stored in the ._parameters array, as opposed to the values</span>
<span class="sd">        displayed to users.  In most cases these are one in the same but there</span>
<span class="sd">        are currently a few exceptions.</span>

<span class="sd">        Note: This is notably an overcomplicated device and may be removed</span>
<span class="sd">        entirely in the near future.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">raw</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_raw_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>

            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_shape&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

            <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Add a single param set axis to the parameter&#39;s value (thus</span>
                <span class="c1"># converting scalars to shape (1,) array values) for</span>
                <span class="c1"># consistency</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">units</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raw</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;raw_unit&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;raw_unit&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">units</span><span class="p">:</span>
            <span class="c1"># If the parameters are not all the same shape, converting to an</span>
            <span class="c1"># array is going to produce an object array</span>
            <span class="c1"># However the way Numpy creates object arrays is tricky in that it</span>
            <span class="c1"># will recurse into array objects in the list and break them up</span>
            <span class="c1"># into separate objects.  Doing things this way ensures a 1-D</span>
            <span class="c1"># object array the elements of which are the individual parameter</span>
            <span class="c1"># arrays.  There&#39;s not much reason to do this over returning a list</span>
            <span class="c1"># except for consistency</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">psets</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">return</span> <span class="n">psets</span>

        <span class="c1"># TODO: Returning an array from this method may be entirely pointless</span>
        <span class="c1"># for internal use--perhaps only the external param_sets method should</span>
        <span class="c1"># return an array (and just for backwards compat--I would prefer to</span>
        <span class="c1"># maybe deprecate that method)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: I think this could be reworked to preset model sets better</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                             <span class="n">param_repr_oneline</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;name=</span><span class="si">{0!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">defaults</span> <span class="ow">and</span> <span class="n">defaults</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">=</span><span class="si">{1!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwarg</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;n_models=</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{0}</span><span class="s1">(</span><span class="si">{1}</span><span class="s1">)&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__str__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__str__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Inputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Outputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Model set size&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span> <span class="o">+</span> <span class="n">keywords</span>
                 <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Parameters:&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">param_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
            <span class="c1"># Set units on the columns</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">param_table</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">param_table</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FittableModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for models that can be fitted using the built-in fitting</span>
<span class="sd">    algorithms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># derivative with respect to parameters</span>
    <span class="n">fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function (similar to the model&#39;s `~Model.evaluate`) to compute the</span>
<span class="sd">    derivatives of the model with respect to its parameters, for use by fitting</span>
<span class="sd">    algorithms.  In other words, this computes the Jacobian matrix with respect</span>
<span class="sd">    to the model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Flag that indicates if the model derivatives with respect to parameters</span>
    <span class="c1"># are given in columns or rows</span>
    <span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Fittable1DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for one-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,)</span>
    <span class="n">_separable</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Fittable2DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for two-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_make_arithmetic_operator</span><span class="p">(</span><span class="n">oper</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">make_binary_operator_eval</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">op</span>


<span class="k">def</span> <span class="nf">_composition_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">),</span> <span class="n">params</span><span class="p">),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_join_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[:</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span>
                                    <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]:],</span> <span class="n">params</span><span class="p">)),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="c1"># TODO: Support a couple unary operators--at least negation?</span>
<span class="n">BINARY_OPERATORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">),</span>
    <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">),</span>
    <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">),</span>
    <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">),</span>
    <span class="s1">&#39;**&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">),</span>
    <span class="s1">&#39;|&#39;</span><span class="p">:</span> <span class="n">_composition_operator</span><span class="p">,</span>
    <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span> <span class="n">_join_operator</span>
<span class="p">}</span>


<span class="n">_ORDER_OF_OPERATORS</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;|&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,)]</span>
<span class="n">OPERATOR_PRECEDENCE</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_ORDER_OF_OPERATORS</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
<span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">ops</span>


<span class="k">class</span> <span class="nc">_CompoundModelMeta</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">):</span>
    <span class="n">_tree</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_submodels</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_submodel_names</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_nextid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">_param_names</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># _param_map is a mapping of the compound model&#39;s generated param names to</span>
    <span class="c1"># the parameters of submodels they are associated with.  The values in this</span>
    <span class="c1"># mapping are (idx, name) tuples were idx is the index of the submodel this</span>
    <span class="c1"># parameter is associated with, and name is the same parameter&#39;s name on</span>
    <span class="c1"># the submodel</span>
    <span class="c1"># In principle this will allow compound models to give entirely new names</span>
    <span class="c1"># to parameters that don&#39;t have to be the same as their original names on</span>
    <span class="c1"># the submodels, but right now that isn&#39;t taken advantage of</span>
    <span class="n">_param_map</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_slice_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># When taking slices of a compound model, this keeps track of how offset</span>
    <span class="c1"># the first model in the slice is from the first model in the original</span>
    <span class="c1"># compound model it was taken from</span>

    <span class="c1"># This just inverts _param_map, swapping keys with values.  This is also</span>
    <span class="c1"># useful to have.</span>
    <span class="n">_param_map_inverse</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_fittable</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_evaluate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># Make sure the _tree attribute is set; otherwise we are not looking up</span>
        <span class="c1"># an attribute on a concrete compound model class and should just raise</span>
        <span class="c1"># the AttributeError</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_init_param_descriptors</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This case is mostly for debugging purposes</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">()</span>

        <span class="n">expression</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_format_expression</span><span class="p">()</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_format_components</span><span class="p">()</span>
        <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Expression&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Components&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">indent</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">(</span><span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of attributes defined on a compound model, including</span>
<span class="sd">        all of its parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">basedir</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">basedir</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="n">basedir</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">basedir</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># Delete _evaluate from the members dict</span>
            <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">rv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;_evaluate&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rv</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">submodel_names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_submodel_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">submodel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">submodel</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">jdx</span> <span class="o">=</span> <span class="n">seen</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                        <span class="n">names</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">jdx</span><span class="p">],</span> <span class="n">jdx</span><span class="p">)</span>
                        <span class="n">seen</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">seen</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_submodel_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_submodel_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_param_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_init_param_names</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_param_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fittable</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_fittable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_fittable</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">fittable</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_fittable</span>

    <span class="c1"># TODO: Maybe we could use make_function_with_signature for evaluate, but</span>
    <span class="c1"># it&#39;s probably not worth it (and I&#39;m not sure what the limit is on number</span>
    <span class="c1"># of function arguments/local variables but we could break that limit for</span>
    <span class="c1"># complicated compound models...</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_evaluate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">BINARY_OPERATORS</span><span class="p">,</span>
                                      <span class="n">getter</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">_model_evaluate_getter</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_evaluate</span> <span class="o">=</span> <span class="n">func</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="bp">cls</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># TODO: This supports creating a new compound model from two existing</span>
    <span class="c1"># compound models (or normal models) and a single operator.  However, it</span>
    <span class="c1"># ought also to be possible to create a new model from an *entire*</span>
    <span class="c1"># expression, represented as a sequence of operators and their operands (or</span>
    <span class="c1"># an exiting ExpressionTree) and build that into a compound model without</span>
    <span class="c1"># creating an intermediate _CompoundModel class for every single operator</span>
    <span class="c1"># in the expression.  This will prove to be a useful optimization in many</span>
    <span class="c1"># cases</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_operator</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">additional_members</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Python operator (represented by a string, such as ``&#39;+&#39;``</span>
<span class="sd">        or ``&#39;*&#39;``, and two model classes or instances, return a new compound</span>
<span class="sd">        model that evaluates the given operator on the outputs of the left and</span>
<span class="sd">        right input models.</span>

<span class="sd">        If either of the input models are a model *class* (i.e. a subclass of</span>
<span class="sd">        `~astropy.modeling.Model`) then the returned model is a new subclass of</span>
<span class="sd">        `~astropy.modeling.Model` that may be instantiated with any parameter</span>
<span class="sd">        values.  If both input models are *instances* of a model, a new class</span>
<span class="sd">        is still created, but this method returns an *instance* of that class,</span>
<span class="sd">        taking the parameter values from the parameters of the input model</span>
<span class="sd">        instances.</span>

<span class="sd">        If given, the ``additional_members`` `dict` may provide additional</span>
<span class="sd">        class members that should be added to the generated</span>
<span class="sd">        `~astropy.modeling.Model` subclass. Some members that are generated by</span>
<span class="sd">        this method should not be provided by ``additional_members``. These</span>
<span class="sd">        include ``_tree``, ``inputs``, ``outputs``, ``linear``,</span>
<span class="sd">        ``standard_broadcasting``, and ``__module__`. This is currently for</span>
<span class="sd">        internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note, currently this only supports binary operators, but could be</span>
        <span class="c1"># easily extended to support unary operators (namely &#39;-&#39;) if/when</span>
        <span class="c1"># needed</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="p">(</span><span class="n">_CompoundModelMeta</span><span class="p">,</span> <span class="n">_CompoundModel</span><span class="p">)):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Although the original child models were copied we make another</span>
<span class="sd">                copy here to ensure that changes in this child compound model</span>
<span class="sd">                parameters will not propagate to the reuslt, that is</span>
<span class="sd">                cm1 = Gaussian1D(1, 5, .1) + Gaussian1D()</span>
<span class="sd">                cm2 = cm1 | Scale()</span>
<span class="sd">                cm1.amplitude_0 = 100</span>
<span class="sd">                assert(cm2.amplitude_0 == 1)</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_tree</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExpressionTree</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                               <span class="n">inputs</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                               <span class="n">outputs</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExpressionTree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>

        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="n">mcls</span><span class="o">.</span><span class="n">_check_inputs_and_outputs</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="n">ExpressionTree</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                              <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">outputs</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;CompoundModel</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">_nextid</span><span class="p">))</span>
        <span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">_nextid</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span>
            <span class="n">linear</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">linear</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">linear</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Which is not to say it is *definitely* not linear but it would be</span>
            <span class="c1"># trickier to determine</span>
            <span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">standard_broadcasting</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">standard_broadcasting</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">standard_broadcasting</span>

        <span class="c1"># Note: If any other members are added here, make sure to mention them</span>
        <span class="c1"># in the docstring of this method.</span>
        <span class="n">members</span> <span class="o">=</span> <span class="n">additional_members</span>
        <span class="n">members</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;_tree&#39;</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span>
            <span class="s1">&#39;_is_dynamic&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># See docs for _ModelMeta._is_dynamic</span>
            <span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">,</span>
            <span class="s1">&#39;outputs&#39;</span><span class="p">:</span> <span class="n">outputs</span><span class="p">,</span>
            <span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="n">linear</span><span class="p">,</span>
            <span class="s1">&#39;standard_broadcasting&#39;</span><span class="p">:</span> <span class="n">standard_broadcasting</span><span class="p">,</span>
            <span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">)})</span>

        <span class="n">new_cls</span> <span class="o">=</span> <span class="n">mcls</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">_CompoundModel</span><span class="p">,),</span> <span class="n">members</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
            <span class="c1"># Both models used in the operator were already instantiated models,</span>
            <span class="c1"># not model *classes*.  As such it&#39;s not particularly useful to return</span>
            <span class="c1"># the class itself, but to instead produce a new instance:</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="n">new_cls</span><span class="p">()</span>

            <span class="c1"># Workaround for https://github.com/astropy/astropy/issues/3542</span>
            <span class="c1"># TODO: Any effort to restructure the tree-like data structure for</span>
            <span class="c1"># compound models should try to obviate this workaround--if</span>
            <span class="c1"># intermediate compound models are stored in the tree as well then</span>
            <span class="c1"># we can immediately check for custom inverses on sub-models when</span>
            <span class="c1"># computing the inverse</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="n">mcls</span><span class="o">.</span><span class="n">_make_user_inverse</span><span class="p">(</span>
                    <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">==</span> <span class="n">right</span><span class="o">.</span><span class="n">_n_models</span><span class="p">:</span>
                <span class="n">instance</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_n_models</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Model sets must have the same number of &#39;</span>
                                 <span class="s1">&#39;components.&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">instance</span>

        <span class="c1"># Otherwise return the new uninstantiated class itself</span>
        <span class="k">return</span> <span class="n">new_cls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_check_inputs_and_outputs</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="c1"># TODO: These aren&#39;t the full rules for handling inputs and outputs, but</span>
        <span class="c1"># this will handle most basic cases correctly</span>
        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span>

            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported operands for |: </span><span class="si">{0}</span><span class="s2"> (n_inputs=</span><span class="si">{1}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;n_outputs=</span><span class="si">{2}</span><span class="s2">) and </span><span class="si">{3}</span><span class="s2"> (n_inputs=</span><span class="si">{4}</span><span class="s2">, n_outputs=</span><span class="si">{5}</span><span class="s2">); &quot;</span>
                    <span class="s2">&quot;n_outputs for the left-hand model must match n_inputs &quot;</span>
                    <span class="s2">&quot;for the right-hand model.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">left</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>

            <span class="n">inputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Without loss of generality</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">outputs</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span> <span class="ow">or</span>
                    <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported operands for </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2"> (n_inputs=</span><span class="si">{2}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;n_outputs=</span><span class="si">{3}</span><span class="s2">) and </span><span class="si">{4}</span><span class="s2"> (n_inputs=</span><span class="si">{5}</span><span class="s2">, n_outputs=</span><span class="si">{6}</span><span class="s2">); &quot;</span>
                    <span class="s2">&quot;models must have the same n_inputs and the same &quot;</span>
                    <span class="s2">&quot;n_outputs for this operator&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span>
                        <span class="n">right</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_make_user_inverse</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates an inverse `Model` for this `_CompoundModel` when either</span>
<span class="sd">        model in the operation has a *custom inverse* that was manually</span>
<span class="sd">        assigned by the user.</span>

<span class="sd">        If either model has a custom inverse, and in particular if another</span>
<span class="sd">        `_CompoundModel` has a custom inverse, then none of that model&#39;s</span>
<span class="sd">        sub-models should be considered at all when computing the inverse.</span>
<span class="sd">        So in that case we just compute the inverse ahead of time and set</span>
<span class="sd">        it as the new compound model&#39;s custom inverse.</span>

<span class="sd">        Note, this use case only applies when combining model instances,</span>
<span class="sd">        since model classes don&#39;t currently have a notion of a &quot;custom</span>
<span class="sd">        inverse&quot; (though it could probably be supported by overriding the</span>
<span class="sd">        class&#39;s inverse property).</span>

<span class="sd">        TODO: Consider fixing things so the aforementioned class-based case</span>
<span class="sd">        works as well.  However, for the present purposes this is good enough.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">_user_inverse</span><span class="p">)):</span>
            <span class="c1"># These are the only operators that support an inverse right now</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">left_inv</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inverse</span>
            <span class="n">right_inv</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="c1"># If either inverse is undefined then just return False; this</span>
            <span class="c1"># means the normal _CompoundModel.inverse routine will fail</span>
            <span class="c1"># naturally anyways, since it requires all sub-models to have</span>
            <span class="c1"># an inverse defined</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left_inv</span> <span class="o">&amp;</span> <span class="n">right_inv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">right_inv</span> <span class="o">|</span> <span class="n">left_inv</span>

    <span class="c1"># TODO: Perhaps, just perhaps, the post-order (or ???-order) ordering of</span>
    <span class="c1"># leaf nodes is something the ExpressionTree class itself could just know</span>
    <span class="k">def</span> <span class="nf">_get_submodels</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># Would make this a lazyproperty but those don&#39;t currently work with</span>
        <span class="c1"># type objects</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_submodels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_submodels</span>

        <span class="n">submodels</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">()</span>
                     <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isleaf</span><span class="p">]</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_submodels</span> <span class="o">=</span> <span class="n">submodels</span>
        <span class="k">return</span> <span class="n">submodels</span>

    <span class="k">def</span> <span class="nf">_init_param_descriptors</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This routine sets up the names for all the parameters on a compound</span>
<span class="sd">        model, including figuring out unique names for those parameters and</span>
<span class="sd">        also mapping them back to their associated parameters of the underlying</span>
<span class="sd">        submodels.</span>

<span class="sd">        Setting this all up is costly, and only necessary for compound models</span>
<span class="sd">        that a user will directly interact with.  For example when building an</span>
<span class="sd">        expression like::</span>

<span class="sd">            &gt;&gt;&gt; M = (Model1 + Model2) * Model3  # doctest: +SKIP</span>

<span class="sd">        the user will generally never interact directly with the temporary</span>
<span class="sd">        result of the subexpression ``(Model1 + Model2)``.  So there&#39;s no need</span>
<span class="sd">        to setup all the parameters for that temporary throwaway.  Only once</span>
<span class="sd">        the full expression is built and the user initializes or introspects</span>
<span class="sd">        ``M`` is it necessary to determine its full parameterization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Accessing cls.param_names will implicitly call _init_param_names if</span>
        <span class="c1"># needed and thus also set up the _param_map; I&#39;m not crazy about that</span>
        <span class="c1"># design but it stands for now</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">submodel_idx</span><span class="p">,</span> <span class="n">submodel_param</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_param_map</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
            <span class="n">submodel</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="n">submodel_idx</span><span class="p">]</span>

            <span class="n">orig_param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="n">submodel_param</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                <span class="c1"># Take the parameter&#39;s default from the model&#39;s value for that</span>
                <span class="c1"># parameter</span>
                <span class="n">default</span> <span class="o">=</span> <span class="n">orig_param</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="n">orig_param</span><span class="o">.</span><span class="n">default</span>

            <span class="c1"># Copy constraints</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">orig_param</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                               <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">Model</span><span class="o">.</span><span class="n">parameter_constraints</span><span class="p">)</span>

            <span class="c1"># Note: Parameter.copy() returns a new unbound Parameter, never</span>
            <span class="c1"># a bound Parameter even if submodel is a Model instance (as</span>
            <span class="c1"># opposed to a Model subclass)</span>
            <span class="n">new_param</span> <span class="o">=</span> <span class="n">orig_param</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">param_name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span>
                                        <span class="n">unit</span><span class="o">=</span><span class="n">orig_param</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">constraints</span><span class="p">)</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">new_param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_param_names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This subroutine is solely for setting up the ``param_names`` attribute</span>
<span class="sd">        itself.</span>

<span class="sd">        See ``_init_param_descriptors`` for the full parameter setup.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Currently this skips over Model *instances* in the expression tree;</span>
        <span class="c1"># basically these are treated as constants and do not add</span>
        <span class="c1"># fittable/tunable parameters to the compound model.</span>
        <span class="c1"># TODO: I&#39;m not 100% happy with this design, and maybe we need some</span>
        <span class="c1"># interface for distinguishing fittable/settable parameters with</span>
        <span class="c1"># *constant* parameters (which would be distinct from parameters with</span>
        <span class="c1"># fixed constraints since they&#39;re permanently locked in place). But I&#39;m</span>
        <span class="c1"># not sure if this is really the best way to treat the issue.</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">param_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Start counting the suffix indices to put on parameter names from the</span>
        <span class="c1"># slice_offset.  Usually this will just be zero, but for compound</span>
        <span class="c1"># models that were sliced from another compound model this may be &gt; 0</span>
        <span class="n">param_suffix</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_slice_offset</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="c1"># Skip models that don&#39;t have parameters in the numbering</span>
                <span class="c1"># TODO: Reevaluate this if it turns out to be confusing, though</span>
                <span class="c1"># parameter-less models are not very common in practice (there</span>
                <span class="c1"># are a few projections that don&#39;t take parameters)</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="c1"># This is sort of heuristic, but we want to check that</span>
                <span class="c1"># model.param_name *actually* returns a Parameter descriptor,</span>
                <span class="c1"># and that the model isn&#39;t some inconsistent type that happens</span>
                <span class="c1"># to have a param_names attribute but does not actually</span>
                <span class="c1"># implement settable parameters.</span>
                <span class="c1"># In the future we can probably remove this check, but this is</span>
                <span class="c1"># here specifically to support the legacy compat</span>
                <span class="c1"># _CompositeModel which can be considered a pathological case</span>
                <span class="c1"># in the context of the new framework</span>
                <span class="c1"># if not isinstance(getattr(model, param_name, None),</span>
                <span class="c1">#                  Parameter):</span>
                <span class="c1">#    break</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">param_suffix</span> <span class="o">+</span> <span class="n">idx</span><span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">param_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_param_map</span> <span class="o">=</span> <span class="n">param_map</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_param_map_inverse</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_map</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_format_expression</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># TODO: At some point might be useful to make a public version of this,</span>
        <span class="c1"># albeit with more formatting options</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">format_expression</span><span class="p">(</span><span class="n">OPERATOR_PRECEDENCE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_components</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">{0}</span><span class="s1">]: </span><span class="si">{1!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_normalize_index</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an index given to __getitem__ to either an integer, or</span>
<span class="sd">        a slice with integer start and stop values.</span>

<span class="sd">        If the length of the slice is exactly 1 this converts the index to a</span>
<span class="sd">        simple integer lookup.</span>

<span class="sd">        Negative integers are converted to positive integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_index_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s1">&#39;Compound model </span><span class="si">{0}</span><span class="s1"> does not have a component named &#39;</span>
                    <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">check_for_negative_index</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span>
                <span class="k">if</span> <span class="n">new_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># If still &lt; 0 then this is an invalid index</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                            <span class="s2">&quot;Model index </span><span class="si">{0}</span><span class="s2"> out of range.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>

            <span class="k">return</span> <span class="n">index</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">get_index_from_name</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># In principle it could be but I can scarcely imagine a case</span>
                <span class="c1"># where it would be useful.  If someone can think of one then</span>
                <span class="c1"># we can enable it.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Step not supported for compound model slicing.&quot;</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span>
                    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">check_for_negative_index</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">check_for_negative_index</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">get_index_from_name</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">get_index_from_name</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

            <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">start</span>
            <span class="k">elif</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty slice of a compound model.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s2">&quot;Model index </span><span class="si">{0}</span><span class="s2"> out of range.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">check_for_negative_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;Submodels can be indexed either by their integer order or &#39;</span>
            <span class="s1">&#39;their name (got </span><span class="si">{0!r}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_slice</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new model build from a sub-expression of the expression</span>
<span class="sd">        represented by this model.</span>

<span class="sd">        Right now this is highly inefficient, as it creates a new temporary</span>
<span class="sd">        model for each operator that appears in the sub-expression.  It would</span>
<span class="sd">        be better if this just built a new expression tree, and the new model</span>
<span class="sd">        instantiated directly from that tree.</span>

<span class="sd">        Once tree -&gt; model instantiation is possible this should be fixed to</span>
<span class="sd">        use that instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">members</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_slice_offset&#39;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_slice_offset</span> <span class="o">+</span> <span class="n">start</span><span class="p">}</span>
        <span class="n">operators</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">oper</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">additional_members</span><span class="o">=</span><span class="n">members</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">oper</span> <span class="ow">in</span> <span class="n">BINARY_OPERATORS</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_model_evaluate_getter</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
        <span class="n">n_inputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span>
        <span class="n">n_outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span>

        <span class="c1"># If model is not an instance, we need to instantiate it to make sure</span>
        <span class="c1"># that we can call _validate_input_units (since e.g. input_units can</span>
        <span class="c1"># be an instance property).</span>

        <span class="k">def</span> <span class="nf">evaluate_wrapper</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">param_values</span><span class="p">):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_validate_input_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">*</span><span class="n">param_values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">_process_output_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
                <span class="n">param_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">evaluate_wrapper</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">param_values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Where previously model was a class, now make an instance</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
                <span class="n">param_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">))</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">param_values</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">evaluate_wrapper</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">param_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_outputs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_CompoundModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_CompoundModelMeta</span><span class="p">):</span>
    <span class="n">fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_submodels</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_expression</span><span class="p">()</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_components</span><span class="p">()</span>
        <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Expression&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Components&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">indent</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_format_str</span><span class="p">(</span><span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_input_output_units_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to transform dict or bool settings from</span>
<span class="sd">        submodels into a single dictionary for the composite model,</span>
<span class="sd">        taking into account renaming of input parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">inp</span><span class="p">,</span> <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">orig_inp</span><span class="p">)</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mattr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mattr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">orig_inp</span> <span class="ow">in</span> <span class="n">mattr</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mattr</span><span class="p">[</span><span class="n">orig_inp</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mattr</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mattr</span>

        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>  <span class="c1"># Note that if d is empty, we just return None</span>
            <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_allow_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_input_output_units_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">,</span>
                                                      <span class="s1">&#39;input_units_allow_dimensionless&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_strict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_input_output_units_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">,</span>
                                                      <span class="s1">&#39;input_units_strict&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_input_output_units_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">,</span> <span class="s1">&#39;input_units&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_input_output_units_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">,</span>
                                                      <span class="s1">&#39;input_units_equivalencies&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">return_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_input_output_units_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">,</span>
                                                      <span class="s1">&#39;return_units&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># This __getattr__ is necessary, because _CompoundModelMeta creates</span>
        <span class="c1"># Parameter descriptors *lazily*--they do not exist in the class</span>
        <span class="c1"># __dict__ until one of them has been accessed.</span>
        <span class="c1"># However, this is at odds with how Python looks up descriptors (see</span>
        <span class="c1"># (https://docs.python.org/3/reference/datamodel.html#invoking-descriptors)</span>
        <span class="c1"># which is to look directly in the class __dict__</span>
        <span class="c1"># This workaround allows descriptors to work correctly when they are</span>
        <span class="c1"># not initially found in the class __dict__</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__get__&#39;</span><span class="p">):</span>
            <span class="c1"># Object is a descriptor, so we should really return the result of</span>
            <span class="c1"># its __get__</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_param_map_inverse</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param_map</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">_from_existing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">submodel_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">submodel_names</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">n_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">submodel_names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">param_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fittable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">fittable</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># TODO: The way this works is highly inefficient--the inverse is created by</span>
    <span class="c1"># making a new model for each operator in the compound model, which could</span>
    <span class="c1"># potentially mean creating a large number of temporary throwaway model</span>
    <span class="c1"># classes.  This can definitely be optimized in the future by implementing</span>
    <span class="c1"># a way to construct a single model class from an existing tree</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_not_implemented</span><span class="p">(</span><span class="n">oper</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_raise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;The inverse is not currently defined for compound &quot;</span>
                    <span class="s2">&quot;models created using the </span><span class="si">{0}</span><span class="s2"> operator.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">oper</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">_raise</span>

        <span class="n">operators</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">oper</span><span class="p">,</span> <span class="n">_not_implemented</span><span class="p">(</span><span class="n">oper</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">oper</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">))</span>
        <span class="n">operators</span><span class="p">[</span><span class="s1">&#39;&amp;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span>
        <span class="c1"># Reverse the order of compositions</span>
        <span class="n">operators</span><span class="p">[</span><span class="s1">&#39;|&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># By indexing on self[] this will return an instance of the</span>
                <span class="c1"># model, with all the appropriate parameters set, which is</span>
                <span class="c1"># currently required to return an inverse</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">inverse</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;All models in a composite model must have an inverse &quot;</span>
                    <span class="s2">&quot;defined in order for the composite model to have an &quot;</span>
                    <span class="s2">&quot;inverse.  </span><span class="si">{0!r}</span><span class="s2"> does not have an inverse.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">getter</span><span class="p">)</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">_get_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_parameter_units_for_data_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_units</span><span class="p">,</span> <span class="n">output_units</span><span class="p">):</span>
        <span class="n">units_for_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">imodel</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_submodels</span><span class="p">):</span>
            <span class="n">units_for_data_sub</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">input_units</span><span class="p">,</span> <span class="n">output_units</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param_sub</span> <span class="ow">in</span> <span class="n">units_for_data_sub</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_map_inverse</span><span class="p">[(</span><span class="n">imodel</span><span class="p">,</span> <span class="n">param_sub</span><span class="p">)]</span>
                <span class="n">units_for_data</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">units_for_data_sub</span><span class="p">[</span><span class="n">param_sub</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">units_for_data</span>

    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deep copy of a compound model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_submodels</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_submodels</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_model</span>


<span class="k">def</span> <span class="nf">custom_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a model from a user defined function. The inputs and parameters of</span>
<span class="sd">    the model will be inferred from the arguments of the function.</span>

<span class="sd">    This can be used either as a function or as a decorator.  See below for</span>
<span class="sd">    examples of both usages.</span>

<span class="sd">    .. note::</span>

<span class="sd">        All model parameters have to be defined as keyword arguments with</span>
<span class="sd">        default values in the model function.  Use `None` as a default argument</span>
<span class="sd">        value if you do not want to have a default value for that parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Function which defines the model.  It should take N positional</span>
<span class="sd">        arguments where ``N`` is dimensions of the model (the number of</span>
<span class="sd">        independent variable in the model), and any number of keyword arguments</span>
<span class="sd">        (the parameters).  It must return the value of the model (typically as</span>
<span class="sd">        an array, but can also be a scalar for scalar inputs).  This</span>
<span class="sd">        corresponds to the `~astropy.modeling.Model.evaluate` method.</span>
<span class="sd">    fit_deriv : function, optional</span>
<span class="sd">        Function which defines the Jacobian derivative of the model. I.e., the</span>
<span class="sd">        derivative with respect to the *parameters* of the model.  It should</span>
<span class="sd">        have the same argument signature as ``func``, but should return a</span>
<span class="sd">        sequence where each element of the sequence is the derivative</span>
<span class="sd">        with respect to the corresponding argument. This corresponds to the</span>
<span class="sd">        :meth:`~astropy.modeling.FittableModel.fit_deriv` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define a sinusoidal model function as a custom 1D model::</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import custom_model</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; def sine_model(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return amplitude * np.sin(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; def sine_deriv(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return 2 * np.pi * amplitude * np.cos(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; SineModel = custom_model(sine_model, fit_deriv=sine_deriv)</span>

<span class="sd">    Create an instance of the custom model and evaluate it::</span>

<span class="sd">        &gt;&gt;&gt; model = SineModel()</span>
<span class="sd">        &gt;&gt;&gt; model(0.25)</span>
<span class="sd">        1.0</span>

<span class="sd">    This model instance can now be used like a usual astropy model.</span>

<span class="sd">    The next example demonstrates a 2D Moffat function model, and also</span>
<span class="sd">    demonstrates the support for docstrings (this example could also include</span>
<span class="sd">    a derivative, but it has been omitted for simplicity)::</span>

<span class="sd">        &gt;&gt;&gt; @custom_model</span>
<span class="sd">        ... def Moffat2D(x, y, amplitude=1.0, x_0=0.0, y_0=0.0, gamma=1.0,</span>
<span class="sd">        ...            alpha=1.0):</span>
<span class="sd">        ...     \&quot;\&quot;\&quot;Two dimensional Moffat function.\&quot;\&quot;\&quot;</span>
<span class="sd">        ...     rr_gg = ((x - x_0) ** 2 + (y - y_0) ** 2) / gamma ** 2</span>
<span class="sd">        ...     return amplitude * (1 + rr_gg) ** (-alpha)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; print(Moffat2D.__doc__)</span>
<span class="sd">        Two dimensional Moffat function.</span>
<span class="sd">        &gt;&gt;&gt; model = Moffat2D()</span>
<span class="sd">        &gt;&gt;&gt; model(1, 1)  # doctest: +FLOAT_CMP</span>
<span class="sd">        0.3333333333333333</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Function received unexpected arguments (</span><span class="si">{}</span><span class="s2">) these &quot;</span>
            <span class="s2">&quot;are ignored but will raise an Exception in the &quot;</span>
            <span class="s2">&quot;future.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)),</span>
            <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">_custom_model_wrapper</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_custom_model_wrapper</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> takes at most one positional argument (the callable/&quot;</span>
            <span class="s2">&quot;function to be turned into a model.  When used as a decorator &quot;</span>
            <span class="s2">&quot;it should be passed keyword arguments only (if &quot;</span>
            <span class="s2">&quot;any).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="vm">__name__</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_custom_model_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal implementation `custom_model`.</span>

<span class="sd">    When `custom_model` is called as a function its arguments are passed to</span>
<span class="sd">    this function, and the result of this function is returned.</span>

<span class="sd">    When `custom_model` is used as a decorator a partial evaluation of this</span>
<span class="sd">    function is returned by `custom_model`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s2">&quot;func is not callable; it must be a function or other callable &quot;</span>
            <span class="s2">&quot;object&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s2">&quot;fit_deriv not callable; it must be a function or other &quot;</span>
            <span class="s2">&quot;callable object&quot;</span><span class="p">)</span>

    <span class="n">model_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">get_inputs_and_params</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fit_deriv</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s2">&quot;derivative function should accept &quot;</span>
                                   <span class="s2">&quot;same number of parameters as func.&quot;</span><span class="p">)</span>

    <span class="c1"># TODO: Maybe have a clever scheme for default output name?</span>
    <span class="k">if</span> <span class="n">inputs</span><span class="p">:</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span>

    <span class="n">members</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">),</span>
        <span class="s1">&#39;__doc__&#39;</span><span class="p">:</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
        <span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">),</span>
        <span class="s1">&#39;outputs&#39;</span><span class="p">:</span> <span class="n">output_names</span><span class="p">,</span>
        <span class="s1">&#39;evaluate&#39;</span><span class="p">:</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">members</span><span class="p">[</span><span class="s1">&#39;fit_deriv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">)</span>

    <span class="n">members</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="p">(</span><span class="n">FittableModel</span><span class="p">,),</span> <span class="n">members</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">render_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates a model on an input array. Evaluation is limited to</span>
<span class="sd">    a bounding box if the `Model.bounding_box` attribute is set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `Model`</span>
<span class="sd">        Model to be evaluated.</span>
<span class="sd">    arr : `numpy.ndarray`, optional</span>
<span class="sd">        Array on which the model is evaluated.</span>
<span class="sd">    coords : array-like, optional</span>
<span class="sd">        Coordinate arrays mapping to ``arr``, such that</span>
<span class="sd">        ``arr[coords] == arr``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        The model evaluated on the input ``arr`` or a new array from ``coords``.</span>
<span class="sd">        If ``arr`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">        limited to the `Model.bounding_box` limits. If</span>
<span class="sd">        `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be passed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    :ref:`bounding-boxes`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bbox</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bounding_box</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set, coords or arr must be input.&#39;</span><span class="p">)</span>

    <span class="c1"># for consistent indexing</span>
    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Check dimensions match model</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;number of array dimensions inconsistent with &#39;</span>
                             <span class="s1">&#39;number of model inputs.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check dimensions match arr and model</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;coordinate length inconsistent with the number &#39;</span>
                             <span class="s1">&#39;of model inputs.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;coordinate shape inconsistent with the &#39;</span>
                                 <span class="s1">&#39;array shape.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assures position is at center pixel, important when using add_array</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

        <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The `bounding_box` is larger than the input&#39;</span>
                                 <span class="s1">&#39; arr in one or more dimensions. Set &#39;</span>
                                 <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im_shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

        <span class="n">arr</span> <span class="o">+=</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">arr</span>


<span class="k">def</span> <span class="nf">_prepare_inputs_single_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">broadcasts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Ensure that array scalars are always upgrade to 1-D arrays for the</span>
        <span class="c1"># sake of consistency with how parameters work.  They will be cast back</span>
        <span class="c1"># to scalars at the end</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_shape</span><span class="p">:</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_broadcast</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">:</span>
                    <span class="n">broadcast</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
            <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Model input argument </span><span class="si">{0!r}</span><span class="s2"> of shape </span><span class="si">{1!r}</span><span class="s2"> cannot be &quot;</span>
                    <span class="s2">&quot;broadcast with parameter </span><span class="si">{2!r}</span><span class="s2"> of shape &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{3!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">,</span>
                                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">broadcast</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">,</span> <span class="n">broadcast</span><span class="p">)</span>

        <span class="n">broadcasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">&gt;</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">broadcasts</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;For models with n_outputs &gt; n_inputs, the combination of &quot;</span>
                <span class="s2">&quot;all inputs and parameters must broadcast to the same shape, &quot;</span>
                <span class="s2">&quot;which will be used as the shape of all outputs.  In this &quot;</span>
                <span class="s2">&quot;case some of the inputs had different shapes, so it is &quot;</span>
                <span class="s2">&quot;ambiguous how to format outputs for this model.  Try using &quot;</span>
                <span class="s2">&quot;inputs that are all the same size and shape.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extend the broadcasts list to include shapes for all outputs</span>
            <span class="n">extra_outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcasts</span><span class="p">:</span>
                <span class="c1"># If there were no inputs then the broadcasts list is empty</span>
                <span class="c1"># just add a None since there is no broadcasting of outputs and</span>
                <span class="c1"># inputs necessary (see _prepare_outputs_single_model)</span>
                <span class="n">broadcasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">broadcasts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">broadcasts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">extra_outputs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="n">broadcasts</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_prepare_outputs_single_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">):</span>
    <span class="n">broadcasts</span> <span class="o">=</span> <span class="n">format_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">broadcasts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcast_shape</span><span class="p">:</span>
                <span class="c1"># Shape is (), i.e. a scalar should be returned</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepare_inputs_model_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">reshaped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pivots</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">max_param_shape</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># Use the shape of the input *excluding* the model axis</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">+</span>
                           <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Model input argument </span><span class="si">{0!r}</span><span class="s2"> of shape </span><span class="si">{1!r}</span><span class="s2"> cannot be &quot;</span>
                    <span class="s2">&quot;broadcast with parameter </span><span class="si">{2!r}</span><span class="s2"> of shape &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{3!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">,</span>
                                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">):</span>
                <span class="n">max_param_shape</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># We&#39;ve now determined that, excluding the model_set_axis, the</span>
        <span class="c1"># input can broadcast with all the parameters</span>
        <span class="n">input_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">input_ndim</span><span class="p">:</span>
                <span class="c1"># Just needs to prepend new axes to the input</span>
                <span class="n">n_new_axes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">input_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span>
                             <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span><span class="p">:])</span>
            <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">input_ndim</span><span class="p">:</span>
                <span class="n">n_new_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_axes</span> <span class="o">+</span>
                             <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">new_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                                        <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">pivots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span>
        <span class="n">reshaped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_input</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">&lt;</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">:</span>
        <span class="n">pivots</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reshaped</span><span class="p">,</span> <span class="p">(</span><span class="n">pivots</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_prepare_outputs_model_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">):</span>
    <span class="n">pivots</span> <span class="o">=</span> <span class="n">format_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If model_set_axis = False was passed then use</span>
    <span class="c1"># model._model_set_axis to format the output.</span>
    <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">pivots</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pivot</span> <span class="o">&lt;</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="n">model_set_axis</span><span class="p">:</span>
            <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span>
                                       <span class="n">model_set_axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">argnames</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                           <span class="n">validate_broadcasting</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform basic validation of model inputs--that they are mutually</span>
<span class="sd">    broadcastable and that they have the minimum dimensions for the given</span>
<span class="sd">    model_set_axis.</span>

<span class="sd">    If validation succeeds, returns the total shape that will result from</span>
<span class="sd">    broadcasting the input arrays with each other.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check_model_set_axis</span> <span class="o">=</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">validate_broadcasting</span> <span class="ow">or</span> <span class="n">check_model_set_axis</span><span class="p">):</span>
        <span class="c1"># Nothing else needed here</span>
        <span class="k">return</span>

    <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>

        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">_input</span><span class="p">)</span>
        <span class="c1"># Ensure that the input&#39;s model_set_axis matches the model&#39;s</span>
        <span class="c1"># n_models</span>
        <span class="k">if</span> <span class="n">input_shape</span> <span class="ow">and</span> <span class="n">check_model_set_axis</span><span class="p">:</span>
            <span class="c1"># Note: Scalar inputs *only* get a pass on this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;For model_set_axis=</span><span class="si">{0}</span><span class="s2">, all inputs must be at &quot;</span>
                    <span class="s2">&quot;least </span><span class="si">{1}</span><span class="s2">-dimensional.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">input_shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">argname</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># the case of model.inputs = ()</span>
                    <span class="n">argname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Input argument </span><span class="si">{0!r}</span><span class="s2"> does not have the correct &quot;</span>
                    <span class="s2">&quot;dimensions in model_set_axis=</span><span class="si">{1}</span><span class="s2"> for a model set with &quot;</span>
                    <span class="s2">&quot;n_models=</span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">argname</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                                           <span class="n">n_models</span><span class="p">))</span>
        <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">validate_broadcasting</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">input_broadcast</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">IncompatibleShapeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">shape_a</span><span class="p">,</span> <span class="n">shape_a_idx</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">,</span> <span class="n">shape_b_idx</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span>
        <span class="n">arg_a</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[</span><span class="n">shape_a_idx</span><span class="p">]</span>
        <span class="n">arg_b</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[</span><span class="n">shape_b_idx</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Model input argument </span><span class="si">{0!r}</span><span class="s2"> of shape </span><span class="si">{1!r}</span><span class="s2"> cannot &quot;</span>
            <span class="s2">&quot;be broadcast with input </span><span class="si">{2!r}</span><span class="s2"> of shape </span><span class="si">{3!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">arg_a</span><span class="p">,</span> <span class="n">shape_a</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">input_broadcast</span>


<span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">,</span> <span class="n">_ModelMeta</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">)</span>
<span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">_CompoundModelMeta</span><span class="p">,</span> <span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, The Gammapy developers
      <span class="lastupdated">
        Last updated on 01 Oct 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>