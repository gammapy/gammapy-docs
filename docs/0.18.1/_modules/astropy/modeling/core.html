

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>astropy.modeling.core &mdash; gammapy v0.18.1</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gammapy.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/gammapy_logo.ico"/>
  
  
  
    <link rel="canonical" href="https://docs.gammapy.org/dev/_modules/astropy/modeling/core.html"/>
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script src="../../../_static/gammapy.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> gammapy
          

          
          </a>

          
            
            
              <div class="version">
                0.18.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#workflow">Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#data-reduction">Data reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#datasets">Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#modeling-and-fitting">Modeling and Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#time-analysis">Time analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#simulation">Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#other-topics">Other topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#what-next">What next?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../overview/DL3.html">The Data Level 3 (DL3) format</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../overview/DL3.html#data-levels-in-cta">Data levels in CTA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../overview/DL3.html#application-in-gammapy">Application in gammapy</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#using-anaconda">Using Anaconda</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#using-other-package-managers">Using other package managers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#download-tutorials">Download tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#what-next">What next?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../install/dependencies.html">Gammapy Dependencies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../install/dependencies.html#required-dependencies">Required dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/dependencies.html#optional-dependencies">Optional dependencies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/other.html">Other package managers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/pip.html">Installation with pip</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting-started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#help">Help!?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#check-your-setup">Check your setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#use-gammapy">Use Gammapy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#id2">Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#id3">IPython</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#python-script">Python script</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getting-started.html#jupyter-notebooks">Jupyter notebooks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting-started.html#install-issues">Install issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#getting-started">Getting started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/analysis_1.html">First analysis with gammapy high level interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Prerequisites:">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Analysis-configuration">Analysis configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Running-the-analysis">Running the analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Data-reduction">Data reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Save-dataset-to-disk">Save dataset to disk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#Model-fitting">Model fitting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_1.html#What’s-next">What’s next</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/analysis_2.html">First analysis with gammapy library API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Prerequisites:">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Defining-the-datastore-and-selecting-observations">Defining the datastore and selecting observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Preparing-reduced-datasets-geometry">Preparing reduced datasets geometry</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Data-reduction">Data reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Save-dataset-to-disk">Save dataset to disk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Define-the-model">Define the model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Fit-the-model">Fit the model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_2.html#Plot-the-fitted-spectrum">Plot the fitted spectrum</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#core-tutorials">Core tutorials</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/cta.html">CTA with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#Tutorial-overview">Tutorial overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#CTA-1DC">CTA 1DC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#Events">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#IRFs">IRFs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#Source-models">Source models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#CTA-performance-files">CTA performance files</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta.html#Next-steps">Next steps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/hess.html">H.E.S.S. data with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/hess.html#DL3-DR1">DL3 DR1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/hess.html#Theta-squared-event-distribution">Theta squared event distribution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/hess.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/hess.html#Next-steps">Next steps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/fermi_lat.html">Fermi-LAT data with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Events">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Counts">Counts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Exposure">Exposure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Galactic-diffuse-background">Galactic diffuse background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Isotropic-diffuse-background">Isotropic diffuse background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#PSF">PSF</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Fit">Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/fermi_lat.html#Summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html">CTA data analysis with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Select-observations">Select observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Make-sky-images">Make sky images</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Source-Detection">Source Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Spatial-analysis">Spatial analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Spectrum">Spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_data_analysis.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/analysis_3d.html">3D analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_3d.html#Analysis-configuration">Analysis configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_3d.html#Configuration-for-stacked-and-joint-analysis">Configuration for stacked and joint analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_3d.html#Stacked-analysis">Stacked analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_3d.html#Joint-analysis">Joint analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_3d.html#Summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_3d.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/simulate_3d.html">3D simulation and fitting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/simulate_3d.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/simulate_3d.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/simulate_3d.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/simulate_3d.html#Imports-and-versions">Imports and versions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/simulate_3d.html#Simulation">Simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/simulate_3d.html#Fit">Fit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html">Spectral analysis with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Load-Data">Load Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Define-Target-Region">Define Target Region</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Create-exclusion-mask">Create exclusion mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Run-data-reduction-chain">Run data reduction chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Plot-off-regions">Plot off regions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Source-statistic">Source statistic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Fit-spectrum">Fit spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Fit-quality-and-model-residuals">Fit quality and model residuals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Compute-Flux-Points">Compute Flux Points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Stack-observations">Stack observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_analysis.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/sed_fitting.html">Flux point fitting in Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Proposed-approach">Proposed approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Load-spectral-points">Load spectral points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Power-Law-Fit">Power Law Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Exponential-Cut-Off-Powerlaw-Fit">Exponential Cut-Off Powerlaw Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Log-Parabola-Fit">Log-Parabola Fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/sed_fitting.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/light_curve.html">Light curve estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Proposed-approach">Proposed approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Analysis-configuration">Analysis configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Light-Curve-estimation:-by-observation">Light Curve estimation: by observation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Running-the-light-curve-extraction-in-1D">Running the light curve extraction in 1D</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#Night-wise-LC-estimation">Night-wise LC estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/light_curve_flare.html">Light curve - Flare</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Prerequisites:">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Select-the-data">Select the data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Define-time-intervals">Define time intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Filter-the-observations-list-in-time-intervals">Filter the observations list in time intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Building-1D-datasets-from-the-new-observations">Building 1D datasets from the new observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Define-the-Model">Define the Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_flare.html#Extract-the-light-curve">Extract the light curve</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html">Binned light curve simulation and fitting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Prerequisites:">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#id1">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Simulating-a-light-curve">Simulating a light curve</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Extract-the-lightcurve">Extract the lightcurve</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Fit-the-datasets">Fit the datasets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/light_curve_simulation.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/spectrum_simulation.html">Spectrum simulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_simulation.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_simulation.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_simulation.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_simulation.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_simulation.html#Simulation-of-a-single-spectrum">Simulation of a single spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/spectrum_simulation.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/modeling_2D.html">Modeling and fitting 2D images using Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Prerequisites:">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Context:">Context:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Objective:">Objective:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Creating-the-config-file">Creating the config file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Getting-the-reduced-dataset">Getting the reduced dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Modelling">Modelling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/ring_background.html">Ring Background Estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Context:">Context:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Objective:">Objective:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Creating-the-config-file">Creating the config file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Getting-the-reduced-dataset">Getting the reduced dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Extracting-the-ring-background">Extracting the ring background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Compute-correlated-significance-and-correlated-excess-maps">Compute correlated significance and correlated excess maps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/event_sampling.html">Event Sampling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/event_sampling.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/event_sampling.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/event_sampling.html#Objective">Objective</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/event_sampling.html#Proposed-approach">Proposed approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/event_sampling.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/event_sampling.html#Extended-source-using-a-template">Extended source using a template</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/event_sampling.html#Exercises">Exercises</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#advanced-tutorials">Advanced tutorials</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/analysis_mwl.html">Joint modeling, fitting, and serialization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#Proposed-approach">Proposed approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#The-setup">The setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#Data-and-models-files">Data and models files</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#Reading-different-datasets">Reading different datasets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#Datasets-serialization">Datasets serialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/analysis_mwl.html#Joint-analysis">Joint analysis</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html">Spectral analysis of extended sources</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Prerequisites:">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Select-the-data">Select the data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Prepare-the-datasets-creation">Prepare the datasets creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Perform-the-data-reduction-loop.">Perform the data reduction loop.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Explore-the-results">Explore the results</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/extended_source_spectral_analysis.html#Perform-spectral-model-fitting">Perform spectral model fitting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/detect.html">Source detection with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#Proposed-approach">Proposed approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#Read-in-input-images">Read in input images</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#Adaptive-smoothing">Adaptive smoothing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#TS-map-estimation">TS map estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#Source-candidates">Source candidates</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/detect.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html">Estimation of the CTA point source sensitivity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html#Define-analysis-region-and-energy-binning">Define analysis region and energy binning</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html#Load-IRFs-and-prepare-dataset">Load IRFs and prepare dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html#Compute-sensitivity">Compute sensitivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html#Results">Results</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/cta_sensitivity.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/modeling_2D.html">Modeling and fitting 2D images using Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Prerequisites:">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Context:">Context:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Objective:">Objective:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Creating-the-config-file">Creating the config file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Getting-the-reduced-dataset">Getting the reduced dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling_2D.html#Modelling">Modelling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/ring_background.html">Ring Background Estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Context:">Context:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Objective:">Objective:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Proposed-approach:">Proposed approach:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Creating-the-config-file">Creating the config file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Getting-the-reduced-dataset">Getting the reduced dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Extracting-the-ring-background">Extracting the ring background</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/ring_background.html#Compute-correlated-significance-and-correlated-excess-maps">Compute correlated significance and correlated excess maps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/exclusion_mask.html">Creating exclusion masks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/exclusion_mask.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/exclusion_mask.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/exclusion_mask.html#Create-the-mask-from-a-list-of-regions">Create the mask from a list of regions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/exclusion_mask.html#Create-the-mask-from-a-catalog-of-sources">Create the mask from a catalog of sources</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/exclusion_mask.html#Create-the-mask-from-statistically-significant-pixels-in-a-dataset">Create the mask from statistically significant pixels in a dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/exclusion_mask.html#Reading-and-writing-exclusion-masks">Reading and writing exclusion masks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/overview.html">Getting started with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/overview.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/overview.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/overview.html#Maps">Maps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/overview.html#Event-lists">Event lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/overview.html#Source-catalogs">Source catalogs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/overview.html#Spectral-models-and-flux-points">Spectral models and flux points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/overview.html#What-next?">What next?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/maps.html">Gammapy Maps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/maps.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/maps.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/maps.html#Creating-WCS-Maps">Creating WCS Maps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/maps.html#Accessing-and-Modifying-Data">Accessing and Modifying Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/maps.html#Reading-and-Writing">Reading and Writing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/maps.html#Visualizing-and-Plotting">Visualizing and Plotting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/maps.html#Interpolating-and-Miscellaneous">Interpolating and Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/modeling.html">Modeling and fitting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#Prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#Proposed-approach">Proposed approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#The-setup">The setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#Model-and-dataset">Model and dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#Fitting-options">Fitting options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#Fit-quality-assessment">Fit quality assessment</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#Covariance-and-parameters-errors">Covariance and parameters errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/modeling.html#Confidence-contours">Confidence contours</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html">Gammapy Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html#Setup">Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html#Spectral-Models">Spectral Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html#Spatial-Models">Spatial Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html#SkyModel">SkyModel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html#Model-Lists-and-Serialisation">Model Lists and Serialisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html#Implementing-a-Custom-Model">Implementing a Custom Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models.html#Models-with-Energy-dependent-morphology">Models with Energy dependent morphology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/catalog.html">Source catalogs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#List-available-catalogs">List available catalogs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Load-catalogs">Load catalogs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Select-a-source">Select a source</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Pretty-print-source-information">Pretty-print source information</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Source-models">Source models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Flux-points">Flux points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Lightcurves">Lightcurves</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Catalog-table-and-source-dictionary">Catalog table and source dictionary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/catalog.html#Next-steps">Next steps</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#scripts">Scripts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/survey_map.html">Survey map</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#extra-topics">Extra topics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/astro_dark_matter.html">Dark matter utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/astro_dark_matter.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/astro_dark_matter.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/astro_dark_matter.html#Profiles">Profiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/astro_dark_matter.html#J-Factors">J Factors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/astro_dark_matter.html#Gamma-ray-spectra-at-production">Gamma-ray spectra at production</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/astro_dark_matter.html#Flux-maps">Flux maps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/background_model.html">Make template background model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Proposed-approach">Proposed approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Select-off-data">Select off data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Background-model">Background model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Zenith-dependence">Zenith dependence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Index-tables">Index tables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/background_model.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html">Fitting and error estimation with MCMC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html#Simulate-an-observation">Simulate an observation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html#Estimate-parameter-correlations-with-MCMC">Estimate parameter correlations with MCMC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html#Plot-the-results">Plot the results</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html#Plot-the-model-dispersion">Plot the model dispersion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html#Fun-Zone">Fun Zone</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/mcmc_sampling.html#PeVatrons-in-CTA-?">PeVatrons in CTA ?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/pulsar_analysis.html">Pulsar analysis with Gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/pulsar_analysis.html#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/pulsar_analysis.html#Opening-the-data">Opening the data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/pulsar_analysis.html#Phasogram">Phasogram</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/pulsar_analysis.html#Phase-resolved-map">Phase-resolved map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/pulsar_analysis.html#Phase-resolved-spectrum">Phase-resolved spectrum</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">How To</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#access-iact-data">Access IACT data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#check-irfs">Check IRFs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#use-gammapy-for-modeling-2d-images">Use gammapy for modeling 2D images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#extract-1d-spectra">Extract 1D spectra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#extract-a-lightcurve">Extract a lightcurve</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#compute-source-significance">Compute source significance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#compute-cumulative-significance">Compute cumulative significance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#detect-sources-in-a-map">Detect sources in a map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#astrophysical-source-modeling">Astrophysical source modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#implement-a-custom-model">Implement a custom model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto.html#energy-dependent-spatial-models">Energy Dependent Spatial Models</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Glossary and references</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#glossary">Glossary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#publications">Publications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#other-gamma-ray-packages">Other gamma-ray packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../references.html#other-useful-packages">Other useful packages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#nov-6th-2020">0.18.1 (Nov 6th, 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#pull-requests">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#nov-4th-2020">0.18 (Nov 4th, 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id2">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#apr-1-2020">0.17 (Apr 1, 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id3">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#feb-1-2020">0.16 (Feb 1, 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id4">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id5">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#dec-3-2019">0.15 (Dec 3, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id6">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id7">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#sep-30-2019">0.14 (Sep 30, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id8">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id9">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#jul-26-2019">0.13 (Jul 26, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id10">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id11">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#may-30-2019">0.12 (May 30, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id12">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id13">Pull Requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#mar-29-2019">0.11 (Mar 29, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id14">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id15">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#jan-28-2019">0.10 (Jan 28, 2019)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id16">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id17">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#nov-29-2018">0.9 (Nov 29, 2018)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id18">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id19">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#sep-23-2018">0.8 (Sep 23, 2018)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id20">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id21">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#feb-28-2018">0.7 (Feb 28, 2018)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id22">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id23">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#apr-28-2017">0.6 (Apr 28, 2017)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id24">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id25">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#nov-22-2016">0.5 (Nov 22, 2016)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id26">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id27">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#apr-20-2016">0.4 (Apr 20, 2016)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id28">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id29">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#aug-13-2015">0.3 (Aug 13, 2015)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id30">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id31">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#apr-13-2015">0.2 (Apr 13, 2015)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id32">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id33">Pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#aug-25-2014">0.1 (Aug 25, 2014)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id34">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog.html#id35">Pull requests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Gammapy Package</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis/index.html">analysis - High-level interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis/index.html#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis/index.html#configuration-and-methods">Configuration and methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#general-settings">General settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#observations-selection">Observations selection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#data-reduction-and-datasets">Data reduction and datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#model">Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#fitting">Fitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#flux-points">Flux points</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#residuals">Residuals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#using-the-high-level-interface">Using the high-level interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../analysis/index.html#module-gammapy.analysis">gammapy.analysis Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../analysis/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../data/index.html">data - DL3 data access and observations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#using-gammapy-data">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.data</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../data/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../data/index.html#module-gammapy.data">gammapy.data Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../data/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../data/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../makers/index.html">makers - Data reduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../makers/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../makers/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../makers/index.html#safe-data-range-handling">Safe Data Range Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../makers/index.html#stacking-of-datasets">Stacking of Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../makers/index.html#combining-data-reduction-steps">Combining Data Reduction Steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../makers/reflected.html">Reflected regions background</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../makers/reflected.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../makers/reflected.html#using-regions">Using regions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../makers/reflected.html#the-reflected-region-finder">The reflected region finder</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../makers/reflected.html#using-the-reflected-background-estimator">Using the reflected background estimator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../makers/ring.html">Ring background</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../makers/ring.html#overview">Overview</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../makers/index.html#using-gammapy-makers">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.makers</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../makers/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../makers/index.html#module-gammapy.makers">gammapy.makers Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../makers/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../makers/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasets/index.html">datasets - Reduced datasets</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../datasets/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../datasets/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../datasets/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../datasets/index.html#module-gammapy.datasets">gammapy.datasets Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../datasets/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../datasets/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../modeling/index.html">modeling - Models and fitting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../modeling/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../modeling/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../modeling/index.html#tutorials">Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../modeling/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#module-gammapy.modeling">gammapy.modeling Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modeling/index.html#module-gammapy.modeling.models">gammapy.modeling.models Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#id1">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#id2">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modeling/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../estimators/index.html">estimators - High level estimators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../estimators/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../estimators/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../estimators/detect.html">Flux and significance maps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/detect.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/detect.html#computation-of-ts-images">Computation of TS images</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/detect.html#computation-of-significance-images-a-la-li-ma">Computation of significance images a la Li &amp; Ma</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/detect.html#using-gammapy-estimators">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.estimators</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../estimators/lightcurve.html">Lightcurves</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/lightcurve.html#id1">Lightcurve</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/lightcurve.html#light-curve-extraction">Light Curve Extraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/lightcurve.html#tutorials">Tutorials</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../estimators/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../estimators/index.html#module-gammapy.estimators">gammapy.estimators Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../estimators/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../irf/index.html">irf - Instrument response functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/index.html#irf-axis-naming">IRF Axis naming</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#using-gammapy-irf">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.irf</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/theory.html">IRF Theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/theory.html#modeling-the-expected-number-of-detected-events">Modeling the expected number of detected events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/theory.html#the-instrument-response-functions">The Instrument Response Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/aeff.html">Effective area</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/aeff.html#as-a-function-of-true-energy-and-offset-angle-gadf-aeff-2d">as a function of true energy and offset angle (<span class="xref std std-ref">gadf:aeff_2d</span>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/aeff.html#as-a-function-of-true-energy-gadf-ogip-arf">as a function of true energy (<span class="xref std std-ref">gadf:ogip-arf</span>)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/edisp.html">Energy Dispersion</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/edisp.html#as-a-function-of-of-true-energy-and-offset-angle-gadf-edisp-2d">as a function of of true energy and offset angle (<span class="xref std std-ref">gadf:edisp_2d</span>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/edisp.html#as-a-function-of-true-energy-gadf-ogip-rmf">as a function of true energy (<span class="xref std std-ref">gadf:ogip-rmf</span>)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/psf.html">Point Spread Function</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/psf.html#as-a-function-of-of-true-energy-and-offset-angle-gadf-psf-table">as a function of of true energy and offset angle (<span class="xref std std-ref">gadf:psf_table</span>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/psf.html#as-a-function-of-true-energy-gadf-psf-gtpsf">as a function of true energy (<span class="xref std std-ref">gadf:psf_gtpsf</span>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/psf.html#additional-psf-classes">additional PSF classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/bkg.html">Background</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/bkg.html#as-a-function-of-reconstructed-energy-and-detector-coordinates-gadf-bkg-3d">as a function of reconstructed energy and detector coordinates (<span class="xref std std-ref">gadf:bkg_3d</span>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/bkg.html#as-a-function-of-reconstructed-energy-and-offset-angle-radially-symmetric-gadf-bkg-2d">as a function of reconstructed energy and offset angle, radially symmetric (<span class="xref std std-ref">gadf:bkg_2d</span>)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../irf/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../irf/index.html#module-gammapy.irf">gammapy.irf Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../irf/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../maps/index.html">maps - Sky maps</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#constructing-with-factory-methods">Constructing with Factory Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#indexing-and-slicing">Indexing and Slicing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#accessor-methods">Accessor Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#interface-with-mapcoord-and-skycoord">Interface with <code class="xref py py-obj docutils literal notranslate"><span class="pre">MapCoord</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">SkyCoord</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#differential-and-integral-maps">Differential and integral maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#mapcoord">MapCoord</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#interpolation">Interpolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#iterating-by-image">Iterating by image</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#fits-i-o">FITS I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#visualization">Visualization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#creating-counts-cubes-from-event-lists">Creating counts cubes from event lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#generating-a-cutout-of-a-model-cube">Generating a Cutout of a Model Cube</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#using-gammapy-maps">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.maps</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/hpxmap.html">HEALPix-based Maps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../maps/hpxmap.html#healpix-geometry">HEALPix Geometry</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maps/index.html#module-gammapy.maps">gammapy.maps Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../maps/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../catalog/index.html">catalog - Source catalogs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../catalog/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../catalog/index.html#tutorials">Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../catalog/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../catalog/index.html#module-gammapy.catalog">gammapy.catalog Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../catalog/index.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../catalog/index.html#variables">Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../astro/index.html">astro - Astrophysics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../astro/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../astro/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../astro/index.html#sub-packages">Sub-packages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../astro/source/index.html">Astrophysical source models (<code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.astro.source</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#using-gammapy-astro-source">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.astro.source</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/source/index.html#reference-api">Reference/API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../astro/population/index.html">Astrophysical source population models (<code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.astro.population</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/population/index.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/population/index.html#getting-started">Getting Started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/population/index.html#reference-api">Reference/API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../astro/darkmatter/index.html">Dark matter (<code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.astro.darkmatter</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#other-packages">Other packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#using-gammapy-astro-darkmatter">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.astro.darkmatter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../astro/darkmatter/index.html#reference-api">Reference/API</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">scripts - Command line tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#execute">Execute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#running-config-driven-data-reduction">Running config driven data reduction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#write-your-own-cli">Write your own CLI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#troubleshooting">Troubleshooting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#command-not-found">Command not found</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts/index.html#reference">Reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../scripts/index.html#gammapy">gammapy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/index.html#gammapy-analysis">analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/index.html#gammapy-check">check</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/index.html#gammapy-download">download</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/index.html#gammapy-info">info</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scripts/index.html#gammapy-jupyter">jupyter</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../stats/index.html">stats - Statistics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#counts-and-fit-statistics">Counts and fit statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#estimating-ts">Estimating TS</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#counts-statistics-classes">Counts statistics classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#cash-counts-statistic">Cash counts statistic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#excess-and-significance">Excess and Significance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#excess-errors">Excess errors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#wstat-counts-statistic">WStat counts statistic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#id2">Excess and Significance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#id4">Excess errors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#using-gammapy-stats">Using <code class="xref py py-obj docutils literal notranslate"><span class="pre">gammapy.stats</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/fit_statistics.html">Fit statistics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#cash-poisson-data-with-background-model">Cash : Poisson data with background model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#wstat-poisson-data-with-background-measurement">WStat : Poisson data with background measurement</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/fit_statistics.html#further-references">Further references</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/wstat_derivation.html">Derivation of the WStat formula</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/wstat_derivation.html#profile-likelihood">Profile Likelihood</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/wstat_derivation.html#goodness-of-fit">Goodness of fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/wstat_derivation.html#final-result">Final result</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/wstat_derivation.html#special-cases">Special cases</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../stats/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stats/index.html#module-gammapy.stats">gammapy.stats Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../stats/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">visualization - Plotting and Visualization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../visualization/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../visualization/index.html#colormaps">Colormaps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../visualization/index.html#survey-panel-plots">Survey Panel Plots</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../visualization/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../visualization/index.html#module-gammapy.visualization">gammapy.visualization Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../visualization/index.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../visualization/index.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/index.html">utils - Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#time-handling-in-gammapy">Time handling in Gammapy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#time-format-and-scale">Time format and scale</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#mission-elapsed-times-met">Mission elapsed times (MET)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#time-differences">Time differences</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#reference-api">Reference/API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.units">gammapy.utils.units Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.coordinates">gammapy.utils.coordinates Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id1">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#variables">Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.integrate">gammapy.utils.integrate Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id2">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.interpolation">gammapy.utils.interpolation Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id3">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.table">gammapy.utils.table Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id4">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.fits">gammapy.utils.fits Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id5">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id6">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.random">gammapy.utils.random Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id7">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id8">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.regions">gammapy.utils.regions Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id9">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.scripts">gammapy.utils.scripts Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id10">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.testing">gammapy.utils.testing Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id11">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id12">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.nddata">gammapy.utils.nddata Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id13">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../utils/index.html#module-gammapy.utils.time">gammapy.utils.time Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../utils/index.html#id14">Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../development/index.html">Developer documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../development/intro.html">How to contribute to Gammapy?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/setup.html">Gammapy project setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/howto.html">Developer HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/release.html">How to make a Gammapy release</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/pigs/index.html">PIGs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-001.html">PIG 1 - PIG purpose and guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-002.html">PIG 2 - Organization of low-level analysis code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-003.html">PIG 3 - Plan for dropping Python 2.7 support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-004.html">PIG 4 - Setup for tutorial notebooks and data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-005.html">PIG 5 - Gammapy 1.0 Roadmap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-006.html">PIG 6 - CTA observation handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-007.html">PIG 7 - Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-008.html">PIG 8 - Datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-009.html">PIG 9 - Event Sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-010.html">PIG 10 - Regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-011.html">PIG 11 - Light curves</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-012.html">PIG 12 - High-level interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-013.html">PIG 13 - Gammapy dependencies and distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-014.html">PIG 14 - Uncertainty estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-016.html">PIG 16 - Gammapy package structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-018.html">PIG 18 - Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-019.html">PIG 19 - Gammapy package structure follow up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../development/pigs/pig-021.html">PIG 21 - Models Improvements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../development/dataformats.html">Data Formats</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gammapy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>astropy.modeling.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for astropy.modeling.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines base classes for all models.  The base class of all</span>
<span class="sd">models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is</span>
<span class="sd">the base class for all fittable models. Fittable models can be linear or</span>
<span class="sd">nonlinear in a regression analysis sense.</span>

<span class="sd">All models provide a `__call__` method which performs the transformation in</span>
<span class="sd">a purely mathematical way, i.e. the models are unitless.  Model instances can</span>
<span class="sd">represent either a single model, or a &quot;model set&quot; representing multiple copies</span>
<span class="sd">of the same type of model, but with potentially different values of the</span>
<span class="sd">parameters in each model making up the set.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=invalid-name, protected-access, redefined-outer-name</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="n">indent</span><span class="p">,</span> <span class="n">metadata</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">UnitsError</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span>
<span class="kn">from</span> <span class="nn">astropy.units.utils</span> <span class="kn">import</span> <span class="n">quantity_asanyarray</span>
<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">sharedmethod</span><span class="p">,</span> <span class="n">find_current_module</span><span class="p">,</span>
                           <span class="n">check_broadcast</span><span class="p">,</span> <span class="n">IncompatibleShapeError</span><span class="p">,</span> <span class="n">isiterable</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">astropy.utils.codegen</span> <span class="kn">import</span> <span class="n">make_function_with_signature</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">astropy.utils.misc</span> <span class="kn">import</span> <span class="n">get_parameters</span>
<span class="kn">from</span> <span class="nn">astropy.nddata.utils</span> <span class="kn">import</span> <span class="n">add_array</span><span class="p">,</span> <span class="n">extract_array</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">combine_labels</span><span class="p">,</span> <span class="n">make_binary_operator_eval</span><span class="p">,</span>
                    <span class="n">get_inputs_and_params</span><span class="p">,</span> <span class="n">_BoundingBox</span><span class="p">,</span> <span class="n">_combine_equivalency_dict</span><span class="p">,</span>
                    <span class="n">_ConstraintsDict</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.parameters</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="n">InputParameterError</span><span class="p">,</span>
                         <span class="n">param_repr_oneline</span><span class="p">,</span> <span class="n">_tofloat</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="s1">&#39;FittableModel&#39;</span><span class="p">,</span> <span class="s1">&#39;Fittable1DModel&#39;</span><span class="p">,</span> <span class="s1">&#39;Fittable2DModel&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CompoundModel&#39;</span><span class="p">,</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">,</span> <span class="s1">&#39;custom_model&#39;</span><span class="p">,</span> <span class="s1">&#39;ModelDefinitionError&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_model_oper</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a function that evaluates a given Python arithmetic operator</span>
<span class="sd">    between two models.  The operator should be given as a string, like ``&#39;+&#39;``</span>
<span class="sd">    or ``&#39;**&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ModelDefinitionError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for incorrect models definitions.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_ModelMeta</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metaclass for Model.</span>

<span class="sd">    Currently just handles auto-generating the param_names list based on</span>
<span class="sd">    Parameter descriptors declared at the class-level of Model subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="fm">__prepare__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="n">_is_dynamic</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This flag signifies whether this class was created in the &quot;normal&quot; way,</span>
<span class="sd">    with a class statement in the body of a module, as opposed to a call to</span>
<span class="sd">    `type` or some other metaclass constructor, such that the resulting class</span>
<span class="sd">    does not belong to a specific module.  This is important for pickling of</span>
<span class="sd">    dynamic classes.</span>

<span class="sd">    This flag is always forced to False for new classes, so code that creates</span>
<span class="sd">    dynamic classes should manually set it to True on those classes when</span>
<span class="sd">    creating them.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default empty dict for _parameters_, which will be empty on model</span>
    <span class="c1"># classes that don&#39;t have any Parameters</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="c1"># See the docstring for _is_dynamic above</span>
        <span class="k">if</span> <span class="s1">&#39;_is_dynamic&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="n">members</span><span class="p">[</span><span class="s1">&#39;_is_dynamic&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcls</span><span class="o">.</span><span class="n">_is_dynamic</span>
        <span class="n">get_parameters</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="n">opermethods</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__or__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__and__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;_fix_inputs&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">opermethod</span><span class="p">,</span> <span class="n">opercall</span> <span class="ow">in</span> <span class="n">opermethods</span><span class="p">:</span>
            <span class="n">members</span><span class="p">[</span><span class="n">opermethod</span><span class="p">]</span> <span class="o">=</span> <span class="n">opercall</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>

        <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s1">&#39;_parameters_&#39;</span><span class="p">])</span>

        <span class="c1"># Need to walk each base MRO to collect all parameter names</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tbase</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">tbase</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="c1"># Preserve order of definitions</span>
                    <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tbase</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">)</span> <span class="o">+</span> <span class="n">param_names</span>
        <span class="c1"># Remove duplicates (arising from redefintion in subclass).</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">param_names</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_param_names&#39;</span><span class="p">):</span>
                <span class="c1"># Slight kludge to support compound models, where</span>
                <span class="c1"># cls.param_names is a property; could be improved with a</span>
                <span class="c1"># little refactoring but fine for now</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s2">&quot;CompoundModel&quot;</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_create_inverse_property</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_bounding_box_property</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="n">pdict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tbase</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">tbase</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">parname</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">pdict</span><span class="p">[</span><span class="n">parname</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handle_special_methods</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="n">pdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom repr for Model subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repr for IPython&#39;s pretty printer.</span>

<span class="sd">        By default IPython &quot;pretty prints&quot; classes, so we need to implement</span>
<span class="sd">        this so that IPython displays the custom repr for Models.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_dynamic</span><span class="p">:</span>
            <span class="c1"># Just return a string specifying where the class can be imported</span>
            <span class="c1"># from</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">members</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="c1"># Delete any ABC-related attributes--these will be restored when</span>
        <span class="c1"># the class is reconstructed:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">members</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_abc_&#39;</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">members</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Delete custom __init__ and __call__ if they exist:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">members</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">),</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="n">members</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of this model class--equivalent to ``cls.__name__``.</span>

<span class="sd">        This attribute is provided for symmetry with the `Model.name` attribute</span>
<span class="sd">        of model instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_concrete</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class-level property that determines whether the class is a concrete</span>
<span class="sd">        implementation of a Model--i.e. it is not some abstract base class or</span>
<span class="sd">        internal implementation detail (i.e. begins with &#39;_&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of this model class with a new name, inputs or outputs.</span>

<span class="sd">        The new class is technically a subclass of the original class, so that</span>
<span class="sd">        instance and type checks will still work.  For example::</span>

<span class="sd">            &gt;&gt;&gt; from astropy.modeling.models import Rotation2D</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation = Rotation2D.rename(&#39;SkyRotation&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation</span>
<span class="sd">            &lt;class &#39;astropy.modeling.core.SkyRotation&#39;&gt;</span>
<span class="sd">            Name: SkyRotation (Rotation2D)</span>
<span class="sd">            N_inputs: 2</span>
<span class="sd">            N_outputs: 2</span>
<span class="sd">            Fittable parameters: (&#39;angle&#39;,)</span>
<span class="sd">            &gt;&gt;&gt; issubclass(SkyRotation, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; r = SkyRotation(90)</span>
<span class="sd">            &gt;&gt;&gt; isinstance(r, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected &#39;inputs&#39; to be a tuple of strings.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> expects </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s1"> inputs&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected &#39;outputs&#39; to be a tuple of strings.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> expects </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s1"> outputs&#39;</span><span class="p">)</span>
        <span class="n">new_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">:</span> <span class="n">outputs</span><span class="p">})</span>
        <span class="n">new_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">modname</span>
        <span class="n">new_cls</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">return</span> <span class="n">new_cls</span>

    <span class="k">def</span> <span class="nf">_create_inverse_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inverse&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="c1"># The latter clause is the prevent the below code from running on</span>
            <span class="c1"># the Model base class, which implements the default getter and</span>
            <span class="c1"># setter for .inverse</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="c1"># We allow the @property decorator to be omitted entirely from</span>
            <span class="c1"># the class definition, though its use should be encouraged for</span>
            <span class="c1"># clarity</span>
            <span class="n">inverse</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">fget</span>

        <span class="c1"># Store the inverse getter internally, then delete the given .inverse</span>
        <span class="c1"># attribute so that cls.inverse resolves to Model.inverse instead</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_inverse</span> <span class="o">=</span> <span class="n">inverse</span>
        <span class="k">del</span> <span class="bp">cls</span><span class="o">.</span><span class="n">inverse</span>

    <span class="k">def</span> <span class="nf">_create_bounding_box_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes any bounding_box defined on a concrete Model subclass (either</span>
<span class="sd">        as a fixed tuple or a property or method) and wraps it in the generic</span>
<span class="sd">        getter/setter interface for the bounding_box attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Much of this is verbatim from _create_inverse_property--I feel</span>
        <span class="c1"># like there could be a way to generify properties that work this way,</span>
        <span class="c1"># but for the time being that would probably only confuse things more.</span>
        <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bounding_box&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span><span class="o">.</span><span class="n">fget</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">):</span>
            <span class="c1"># See if it&#39;s a hard-coded bounding_box (as a sequence) and</span>
            <span class="c1"># normalize it</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">_BoundingBox</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">)</span>
            <span class="c1"># May be a method that only takes &#39;self&#39; as an argument (like a</span>
            <span class="c1"># property, but the @property decorator was forgotten)</span>
            <span class="c1">#</span>
            <span class="c1"># However, if the method takes additional arguments then this is a</span>
            <span class="c1"># parameterized bounding box and should be callable</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> \
                        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_bounding_box_subclass</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

        <span class="c1"># See the Model.bounding_box getter definition for how this attribute</span>
        <span class="c1"># is used</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="k">del</span> <span class="bp">cls</span><span class="o">.</span><span class="n">bounding_box</span>

    <span class="k">def</span> <span class="nf">_create_bounding_box_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For Models that take optional arguments for defining their bounding</span>
<span class="sd">        box, we create a subclass of _BoundingBox with a ``__call__`` method</span>
<span class="sd">        that supports those additional arguments.</span>

<span class="sd">        Takes the function&#39;s Signature as an argument since that is already</span>
<span class="sd">        computed in _create_bounding_box_property, so no need to duplicate that</span>
<span class="sd">        effort.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Might be convenient if calling the bounding box also</span>
        <span class="c1"># automatically sets the _user_bounding_box.  So that</span>
        <span class="c1">#</span>
        <span class="c1">#    &gt;&gt;&gt; model.bounding_box(arg=1)</span>
        <span class="c1">#</span>
        <span class="c1"># in addition to returning the computed bbox, also sets it, so that</span>
        <span class="c1"># it&#39;s a shortcut for</span>
        <span class="c1">#</span>
        <span class="c1">#    &gt;&gt;&gt; model.bounding_box = model.bounding_box(arg=1)</span>
        <span class="c1">#</span>
        <span class="c1"># Not sure if that would be non-obvious / confusing though...</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Presumed to be a &#39;self&#39; argument</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s1">&#39;The bounding_box method for </span><span class="si">{0}</span><span class="s1"> is not correctly &#39;</span>
                    <span class="s1">&#39;defined: If defined as a method all arguments to that &#39;</span>
                    <span class="s1">&#39;method (besides self) must be keyword arguments with &#39;</span>
                    <span class="s1">&#39;default values that can be used to compute a default &#39;</span>
                    <span class="s1">&#39;bounding box.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="n">kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">))</span>

        <span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;_</span><span class="si">{0}</span><span class="s1">BoundingBox&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span><span class="n">_BoundingBox</span><span class="p">,),</span>
                    <span class="p">{</span><span class="s1">&#39;__call__&#39;</span><span class="p">:</span> <span class="fm">__call__</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_handle_special_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">pdict</span><span class="p">):</span>

        <span class="c1"># Handle init creation from inputs</span>
        <span class="k">def</span> <span class="nf">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="c1"># Set up the new __call__&#39;s metadata attributes as though it were</span>
            <span class="c1"># manually defined in the class definition</span>
            <span class="c1"># A bit like functools.update_wrapper but uses the class instead of</span>
            <span class="c1"># the wrapped function</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="vm">__doc__</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">):</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;__call__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="s1">&#39;n_inputs&#39;</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s1">&#39;n_inputs&#39;</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">members</span><span class="p">[</span><span class="s1">&#39;n_inputs&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="c1"># Don&#39;t create a custom __call__ for classes that already have one</span>
            <span class="c1"># explicitly defined (this includes the Model base class, and any</span>
            <span class="c1"># other classes that manually override __call__</span>

            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Evaluate this model on the supplied inputs.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># When called, models can take two optional keyword arguments:</span>
            <span class="c1">#</span>
            <span class="c1"># * model_set_axis, which indicates (for multi-dimensional input)</span>
            <span class="c1">#   which axis is used to indicate different models</span>
            <span class="c1">#</span>
            <span class="c1"># * equivalencies, a dictionary of equivalencies to be applied to</span>
            <span class="c1">#   the input values, where each key should correspond to one of</span>
            <span class="c1">#   the inputs.</span>
            <span class="c1">#</span>
            <span class="c1"># The following code creates the __call__ function with these</span>
            <span class="c1"># two keyword arguments.</span>

            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;equivalencies&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;inputs_map&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>

            <span class="n">new_call</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                <span class="fm">__call__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">varargs</span><span class="o">=</span><span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="n">varkwargs</span><span class="o">=</span><span class="s1">&#39;new_inputs&#39;</span><span class="p">)</span>

            <span class="c1"># The following makes it look like __call__</span>
            <span class="c1"># was defined in the class</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_call</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span> <span class="o">=</span> <span class="n">new_call</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;__init__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">):</span>
            <span class="c1"># Build list of all parameters including inherited ones</span>

            <span class="c1"># If *all* the parameters have default values we can make them</span>
            <span class="c1"># keyword arguments; otherwise they must all be positional</span>
            <span class="c1"># arguments</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pdict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_val</span> <span class="ow">in</span> <span class="n">pdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">default</span> <span class="o">=</span> <span class="n">param_val</span><span class="o">.</span><span class="n">default</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">param_val</span><span class="o">.</span><span class="n">unit</span>
                    <span class="c1"># If the unit was specified in the parameter but the</span>
                    <span class="c1"># default is not a Quantity, attach the unit to the</span>
                    <span class="c1"># default.</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">default</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param_name</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">new_init</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                <span class="fm">__init__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">varkwargs</span><span class="o">=</span><span class="s1">&#39;kwargs&#39;</span><span class="p">)</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_init</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">new_init</span>

    <span class="c1"># *** Arithmetic operators for creating compound models ***</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
    <span class="n">_fix_inputs</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">)</span>

    <span class="c1"># *** Other utilities ***</span>

    <span class="k">def</span> <span class="nf">_format_cls_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For the sake of familiarity start the output with the standard class</span>
        <span class="c1"># __repr__</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">format_inheritance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">or</span>
                      <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)):</span>
                    <span class="k">break</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bases</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> (</span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39; -&gt; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bases</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="n">format_inheritance</span><span class="p">(</span><span class="bp">cls</span><span class="p">)),</span>
                <span class="p">(</span><span class="s1">&#39;N_inputs&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;N_outputs&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">),</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">default_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Fittable parameters&#39;</span><span class="p">,</span>
                                         <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span> <span class="o">+</span> <span class="n">keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If any of the above formatting fails fall back on the basic repr</span>
            <span class="c1"># (this is particularly useful in debugging)</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_ModelMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all models.</span>

<span class="sd">    This is an abstract class and should not be instantiated directly.</span>

<span class="sd">    The following initialization arguments apply to the majority of Model</span>
<span class="sd">    subclasses by default (exceptions include specialized utility models</span>
<span class="sd">    like `~astropy.modeling.mappings.Mapping`).  Parametric models take all</span>
<span class="sd">    their parameters as arguments, followed by any of the following optional</span>
<span class="sd">    keyword arguments:</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A human-friendly name associated with this model instance</span>
<span class="sd">        (particularly useful for identifying the individual components of a</span>
<span class="sd">        compound model).</span>

<span class="sd">    meta : dict, optional</span>
<span class="sd">        An optional dict of user-defined metadata to attach to this model.</span>
<span class="sd">        How this is used and interpreted is up to the user or individual use</span>
<span class="sd">        case.</span>

<span class="sd">    n_models : int, optional</span>
<span class="sd">        If given an integer greater than 1, a *model set* is instantiated</span>
<span class="sd">        instead of a single model.  This affects how the parameter arguments</span>
<span class="sd">        are interpreted.  In this case each parameter must be given as a list</span>
<span class="sd">        or array--elements of this array are taken along the first axis (or</span>
<span class="sd">        ``model_set_axis`` if specified), such that the Nth element is the</span>
<span class="sd">        value of that parameter for the Nth model in the set.</span>

<span class="sd">        See the section on model sets in the documentation for more details.</span>

<span class="sd">    model_set_axis : int, optional</span>
<span class="sd">        This argument only applies when creating a model set (i.e. ``n_models &gt;</span>
<span class="sd">        1``).  It changes how parameter values are interpreted.  Normally the</span>
<span class="sd">        first axis of each input parameter array (properly the 0th axis) is</span>
<span class="sd">        taken as the axis corresponding to the model sets.  However, any axis</span>
<span class="sd">        of an input array may be taken as this &quot;model set axis&quot;.  This accepts</span>
<span class="sd">        negative integers as well--for example use ``model_set_axis=-1`` if the</span>
<span class="sd">        last (most rapidly changing) axis should be associated with the model</span>
<span class="sd">        sets. Also, ``model_set_axis=False`` can be used to tell that a given</span>
<span class="sd">        input should be used to evaluate all the models in the model set.</span>

<span class="sd">    fixed : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: bool}`` setting the fixed constraint</span>
<span class="sd">        for one or more parameters.  `True` means the parameter is held fixed</span>
<span class="sd">        during fitting and is prevented from updates once an instance of the</span>
<span class="sd">        model has been created.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.fixed` property of a</span>
<span class="sd">        parameter may be used to lock or unlock individual parameters.</span>

<span class="sd">    tied : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: callable}`` of parameters which are</span>
<span class="sd">        linked to some other parameter. The dictionary values are callables</span>
<span class="sd">        providing the linking relationship.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.tied` property of a</span>
<span class="sd">        parameter may be used to set the ``tied`` constraint on individual</span>
<span class="sd">        parameters.</span>

<span class="sd">    bounds : dict, optional</span>
<span class="sd">        A dictionary ``{parameter_name: value}`` of lower and upper bounds of</span>
<span class="sd">        parameters. Keys are parameter names. Values are a list or a tuple</span>
<span class="sd">        of length 2 giving the desired range for the parameter.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.min` and</span>
<span class="sd">        `~astropy.modeling.Parameter.max` or</span>
<span class="sd">        ~astropy.modeling.Parameter.bounds` properties of a parameter may be</span>
<span class="sd">        used to set bounds on individual parameters.</span>

<span class="sd">    eqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``eqcons[j](x0, *args) == 0.0``</span>
<span class="sd">        in a successfully optimized problem.</span>

<span class="sd">    ineqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``ieqcons[j](x0, *args) &gt;=</span>
<span class="sd">        0.0`` is a successfully optimized problem.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.modeling import models</span>
<span class="sd">    &gt;&gt;&gt; def tie_center(model):</span>
<span class="sd">    ...         mean = 50 * model.stddev</span>
<span class="sd">    ...         return mean</span>
<span class="sd">    &gt;&gt;&gt; tied_parameters = {&#39;mean&#39;: tie_center}</span>

<span class="sd">    Specify that ``&#39;mean&#39;`` is a tied parameter in one of two ways:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        tied=tied_parameters)</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied = tie_center</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    &lt;function tie_center at 0x...&gt;</span>

<span class="sd">    Fixed parameters:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        fixed={&#39;stddev&#39;: True})</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed = True</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameter_constraints</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">constraints</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that can be set on a model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">model_constraints</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;eqcons&#39;</span><span class="p">,</span> <span class="s1">&#39;ineqcons&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that constrain model evaluation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">param_names</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Names of the parameters that describe models of this type.</span>

<span class="sd">    The parameters in this tuple are in the same order they should be passed in</span>
<span class="sd">    when initializing a model of a specific type.  Some types of models, such</span>
<span class="sd">    as polynomial models, have a different number of parameters depending on</span>
<span class="sd">    some other property of the model, such as the degree.</span>

<span class="sd">    When defining a custom model class the value of this attribute is</span>
<span class="sd">    automatically set by the `~astropy.modeling.Parameter` attributes defined</span>
<span class="sd">    in the class body.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_inputs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;The number of inputs.&quot;&quot;&quot;</span>
    <span class="n">n_outputs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot; The number of outputs.&quot;&quot;&quot;</span>

    <span class="n">standard_broadcasting</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_separable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot; A boolean flag to indicate whether a model is separable.&quot;&quot;&quot;</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">MetaData</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;A dict-like object to store optional information.&quot;&quot;&quot;</span>

    <span class="c1"># By default models either use their own inverse property or have no</span>
    <span class="c1"># inverse at all, but users may also assign a custom inverse to a model,</span>
    <span class="c1"># optionally; in that case it is of course up to the user to determine</span>
    <span class="c1"># whether their inverse is *actually* an inverse to the model they assign</span>
    <span class="c1"># it to.</span>
    <span class="n">_inverse</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_user_inverse</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Default n_models attribute, so that __len__ is still defined even when a</span>
    <span class="c1"># model hasn&#39;t completed initialization yet</span>
    <span class="n">_n_models</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># New classes can set this as a boolean value.</span>
    <span class="c1"># It is converted to a dictionary mapping input name to a boolean value.</span>
    <span class="n">_input_units_strict</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Allow dimensionless input (and corresponding output). If this is True,</span>
    <span class="c1"># input values to evaluate will gain the units specified in input_units. If</span>
    <span class="c1"># this is a dictionary then it should map input name to a bool to allow</span>
    <span class="c1"># dimensionless numbers for that input.</span>
    <span class="c1"># Only has an effect if input_units is defined.</span>
    <span class="n">_input_units_allow_dimensionless</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Default equivalencies to apply to input values. If set, this should be a</span>
    <span class="c1"># dictionary where each key is a string that corresponds to one of the</span>
    <span class="c1"># model inputs. Only has an effect if input_units is defined.</span>
    <span class="n">input_units_equivalencies</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_inputs_outputs</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># add parameters to instance level by walking MRO list</span>
        <span class="n">mro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__mro__</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">parname</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">newpar</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">newpar</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="n">parname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">parname</span><span class="p">]</span> <span class="o">=</span> <span class="n">newpar</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_constraints</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Remaining keyword args are either parameter values or invalid</span>
        <span class="c1"># Parameter values must be passed in as keyword arguments in order to</span>
        <span class="c1"># distinguish them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_slices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_unit_support</span><span class="p">()</span>

        <span class="c1"># Raise DeprecationWarning on classes with class attributes</span>
        <span class="c1"># ``inputs`` and ``outputs``.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs_deprecation</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_inputs_deprecation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Class </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> defines class attributes ``inputs``.</span>
<span class="s2">                This has been deprecated in v4.0 and support will be removed in v4.1.</span>
<span class="s2">                Starting with v4.0 classes must define a class attribute ``n_inputs``.</span>
<span class="s2">                Please consult the documentation for details.</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_default_inputs_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># self.n_inputs and self.n_outputs are properties</span>
                <span class="c1"># This is the case when subclasses of Model do not define</span>
                <span class="c1"># ``n_inputs``, ``n_outputs``, ``inputs`` or ``outputs``.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span>

    <span class="nd">@inputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2"> number of inputs, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_unit_support</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span>

    <span class="nd">@outputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="si">}</span><span class="s2"> number of outputs, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: remove the code in the ``if`` block when support</span>
        <span class="c1"># for models with ``inputs`` as class variables is removed.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;n_inputs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_inputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: remove the code in the ``if`` block when support</span>
        <span class="c1"># for models with ``outputs`` as class variables is removed.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;n_outputs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_outputs</span>

    <span class="k">def</span> <span class="nf">_initialize_unit_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert self._input_units_strict and</span>
<span class="sd">        self.input_units_allow_dimensionless to dictionaries</span>
<span class="sd">        mapping input name to a boolean value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span> <span class="k">for</span>
                                        <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span>
                                                     <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_strict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enforce strict units on inputs to evaluate. If this is set to True,</span>
<span class="sd">        input values to evaluate will be in the exact units specified by</span>
<span class="sd">        input_units. If the input quantities are convertible to input_units,</span>
<span class="sd">        they are converted. If this is a dictionary then it should map input</span>
<span class="sd">        name to a bool to set strict input units for that parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_allow_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow dimensionless input (and corresponding output). If this is True,</span>
<span class="sd">        input values to evaluate will gain the units specified in input_units. If</span>
<span class="sd">        this is a dictionary then it should map input name to a bool to allow</span>
<span class="sd">        dimensionless numbers for that input.</span>
<span class="sd">        Only has an effect if input_units is defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uses_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if this model has been created with `~astropy.units.Quantity`</span>
<span class="sd">        objects or if there are no parameters.</span>

<span class="sd">        This can be used to determine if this model should be evaluated with</span>
<span class="sd">        `~astropy.units.Quantity` or regular floats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pisq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pisq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">pisq</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_str</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">param_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_tofloat</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># check consistency with previous shape and size</span>
            <span class="n">eshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">eshape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">eshape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="n">vshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">vshape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">vshape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">esize</span> <span class="ow">or</span>
                    <span class="n">_strip_ones</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_strip_ones</span><span class="p">(</span><span class="n">eshape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                    <span class="s2">&quot;Value for parameter </span><span class="si">{0}</span><span class="s2"> does not match shape or size</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;expected by model (</span><span class="si">{1}</span><span class="s2">, </span><span class="si">{2}</span><span class="s2">) vs (</span><span class="si">{3}</span><span class="s2">, </span><span class="si">{4}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">attr</span><span class="p">,</span> <span class="n">vshape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">eshape</span><span class="p">,</span> <span class="n">esize</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The &#39;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; parameter should be given as a&quot;</span>
                                     <span class="s2">&quot; Quantity because it was originally &quot;</span>
                                     <span class="s2">&quot;initialized as a Quantity&quot;</span><span class="p">)</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span>
                <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fittable&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate this model using the given input(s) and the parameter values</span>
<span class="sd">        that were specified when the model was instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_renamed_inputs_as_positional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">generic_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_renamed_inputs_as_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_keyword2positional</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Inputs were passed as keyword (not positional) arguments.</span>
            <span class="c1"># Because the signature of the ``__call__`` is defined at</span>
            <span class="c1"># the class level, the name of the inputs cannot be changed at</span>
            <span class="c1"># the instance level and the old names are always present in the</span>
            <span class="c1"># signature of the method. In order to use the new names of the</span>
            <span class="c1"># inputs, the old names are taken out of ``kwargs``, the input</span>
            <span class="c1"># values are sorted in the order of self.inputs and passed as</span>
            <span class="c1"># positional arguments to ``__call__``.</span>

            <span class="c1"># These are the keys that are always present as keyword arguments.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;equivalencies&#39;</span><span class="p">,</span> <span class="s1">&#39;inputs_map&#39;</span><span class="p">]</span>

            <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># kwargs contain the names of the new inputs + ``keys``</span>
            <span class="n">allkeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="c1"># Remove the names of the new inputs from kwargs and save them</span>
            <span class="c1"># to a dict ``new_inputs``.</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">allkeys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">new_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">new_inputs</span><span class="p">,</span> <span class="n">kwargs</span>
        <span class="n">n_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="n">new_inputs</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_keyword2positional</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">n_all_args</span> <span class="o">=</span> <span class="n">n_args</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span>

        <span class="k">if</span>  <span class="n">n_all_args</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing input arguments - expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">n_all_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_all_args</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too many input arguments - expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">n_all_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_args</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Create positional arguments from the keyword arguments in ``new_inputs``.</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">n_args</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="c1"># Some inputs are passed as positional, others as keyword arguments.</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># Create positional arguments from the keyword arguments in ``new_inputs``.</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_inputs</span><span class="p">:</span>
                    <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">return</span> <span class="n">new_args</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="c1"># *** Properties ***</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;User-provided name for this model instance.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign a (new) name to this model.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of the model set axis--that is the axis of a parameter array</span>
<span class="sd">        that pertains to which model a parameter value pertains to--as</span>
<span class="sd">        specified when the model was initialized.</span>

<span class="sd">        See the documentation on :ref:`modeling-model-sets`</span>
<span class="sd">        for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return parameters as a pset.</span>

<span class="sd">        This is a list with one item per parameter set, which is an array of</span>
<span class="sd">        that parameter&#39;s values across all parameter sets, with the last axis</span>
<span class="sd">        associated with the parameter set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flattened array of all parameter values in all parameter sets.</span>

<span class="sd">        Fittable parameters maintain this list and fitters modify it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Currently the sequence of a model&#39;s parameters must be contiguous</span>
        <span class="c1"># within the _parameters array (which may be a view of a larger array,</span>
        <span class="c1"># for example when taking a sub-expression of a compound model), so</span>
        <span class="c1"># the assumption here is reliable:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="c1"># Trivial, but not unheard of</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_to_array</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>

    <span class="nd">@parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigning to this attribute updates the parameters array rather than</span>
<span class="sd">        replacing it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s2">&quot;Input parameter values not compatible with the model &quot;</span>
                <span class="s2">&quot;parameters array: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array_to_parameters</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fixed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A ``dict`` mapping parameter names to their fixed constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_ConstraintsDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A ``dict`` mapping parameter names to their upper and lower bounds as</span>
<span class="sd">        ``(min, max)`` tuples or ``[min, max]`` lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_ConstraintsDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tied</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A ``dict`` mapping parameter names to their tied constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_ConstraintsDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;tied&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter equality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span><span class="p">[</span><span class="s1">&#39;eqcons&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter inequality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span><span class="p">[</span><span class="s1">&#39;ineqcons&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `~astropy.modeling.Model` instance which performs the</span>
<span class="sd">        inverse transform, if an analytic inverse is defined for this model.</span>

<span class="sd">        Even on models that don&#39;t have an inverse defined, this property can be</span>
<span class="sd">        set with a manually-defined inverse, such a pre-computed or</span>
<span class="sd">        experimentally determined inverse (often given as a</span>
<span class="sd">        `~astropy.modeling.polynomial.PolynomialModel`, but not by</span>
<span class="sd">        requirement).</span>

<span class="sd">        A custom inverse can be deleted with ``del model.inverse``.  In this</span>
<span class="sd">        case the model&#39;s inverse is reset to its default, if a default exists</span>
<span class="sd">        (otherwise the default is to raise `NotImplementedError`).</span>

<span class="sd">        Note to authors of `~astropy.modeling.Model` subclasses:  To define an</span>
<span class="sd">        inverse for a model simply override this property to return the</span>
<span class="sd">        appropriate model representing the inverse.  The machinery that will</span>
<span class="sd">        make the inverse manually-overridable is added automatically by the</span>
<span class="sd">        base class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span><span class="p">()</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;An analytical inverse transform has not &quot;</span>
                                  <span class="s2">&quot;been implemented for this model.&quot;</span><span class="p">)</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ``inverse`` attribute may be assigned a `Model` &quot;</span>
                <span class="s2">&quot;instance or `None` (where `None` explicitly forces the &quot;</span>
                <span class="s2">&quot;model to have no inverse.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the model&#39;s inverse to its default (if one exists, otherwise</span>
<span class="sd">        the model will have no inverse).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom inverse model has been</span>
<span class="sd">        assigned to this model by a user, via assignment to ``model.inverse``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `tuple` of length `n_inputs` defining the bounding box limits, or</span>
<span class="sd">        `None` for no bounding box.</span>

<span class="sd">        The default limits are given by a ``bounding_box`` property or method</span>
<span class="sd">        defined in the class body of a specific model.  If not defined then</span>
<span class="sd">        this property just raises `NotImplementedError` by default (but may be</span>
<span class="sd">        assigned a custom value by a user).  ``bounding_box`` can be set</span>
<span class="sd">        manually to an array-like object of shape ``(model.n_inputs, 2)``. For</span>
<span class="sd">        further usage, see :ref:`bounding-boxes`</span>

<span class="sd">        The limits are ordered according to the `numpy` indexing</span>
<span class="sd">        convention, and are the reverse of the model input order,</span>
<span class="sd">        e.g. for inputs ``(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;)``, ``bounding_box`` is defined:</span>

<span class="sd">        * for 1D: ``(x_low, x_high)``</span>
<span class="sd">        * for 2D: ``((y_low, y_high), (x_low, x_high))``</span>
<span class="sd">        * for 3D: ``((z_low, z_high), (y_low, y_high), (x_low, x_high))``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Setting the ``bounding_box`` limits for a 1D and 2D model:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import Gaussian1D, Gaussian2D</span>
<span class="sd">        &gt;&gt;&gt; model_1d = Gaussian1D()</span>
<span class="sd">        &gt;&gt;&gt; model_2d = Gaussian2D(x_stddev=1, y_stddev=1)</span>
<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box = (-5, 5)</span>
<span class="sd">        &gt;&gt;&gt; model_2d.bounding_box = ((-6, 6), (-5, 5))</span>

<span class="sd">        Setting the bounding_box limits for a user-defined 3D `custom_model`:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import custom_model</span>
<span class="sd">        &gt;&gt;&gt; def const3d(x, y, z, amp=1):</span>
<span class="sd">        ...    return amp</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Const3D = custom_model(const3d)</span>
<span class="sd">        &gt;&gt;&gt; model_3d = Const3D()</span>
<span class="sd">        &gt;&gt;&gt; model_3d.bounding_box = ((-6, 6), (-5, 5), (-4, 4))</span>

<span class="sd">        To reset ``bounding_box`` to its default limits just delete the</span>
<span class="sd">        user-defined value--this will reset it back to the default defined</span>
<span class="sd">        on the class:</span>

<span class="sd">        &gt;&gt;&gt; del model_1d.bounding_box</span>

<span class="sd">        To disable the bounding box entirely (including the default),</span>
<span class="sd">        set ``bounding_box`` to `None`:</span>

<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box = None</span>
<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">          File &quot;astropy\modeling\core.py&quot;, line 980, in bounding_box</span>
<span class="sd">            &quot;No bounding box is defined for this model (note: the &quot;</span>
<span class="sd">        NotImplementedError: No bounding box is defined for this model (note:</span>
<span class="sd">        the bounding box was explicitly disabled for this model; use `del</span>
<span class="sd">        model.bounding_box` to restore the default bounding box, if one is</span>
<span class="sd">        defined for this model).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;No bounding box is defined for this model (note: the &quot;</span>
                    <span class="s2">&quot;bounding box was explicitly disabled for this model; &quot;</span>
                    <span class="s2">&quot;use `del model.bounding_box` to restore the default &quot;</span>
                    <span class="s2">&quot;bounding box, if one is defined for this model).&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;No bounding box is defined for this model.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">_BoundingBox</span><span class="p">):</span>
            <span class="c1"># This typically implies a hard-coded bounding box.  This will</span>
            <span class="c1"># probably be rare, but it is an option</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The only other allowed possibility is that it&#39;s a _BoundingBox</span>
            <span class="c1"># subclass, so we call it with its default arguments and return an</span>
            <span class="c1"># instance of it (that can be called to recompute the bounding box</span>
            <span class="c1"># with any optional parameters)</span>
            <span class="c1"># (In other words, in this case self._bounding_box is a *class*)</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">((),</span> <span class="n">_model</span><span class="o">=</span><span class="bp">self</span><span class="p">)()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">_model</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@bounding_box</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns the bounding box limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># We use this to explicitly set an unimplemented bounding box (as</span>
            <span class="c1"># opposed to no user bounding box defined)</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span>
              <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">_BoundingBox</span><span class="p">)):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">_BoundingBox</span>

        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>

    <span class="nd">@bounding_box</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom bounding_box has been</span>
<span class="sd">        assigned to this model by a user, via assignment to</span>
<span class="sd">        ``model.bounding_box``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A flag indicating whether a model is separable.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separable</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;The &quot;separable&quot; property is not defined for &#39;</span>
            <span class="s1">&#39;model </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="c1"># *** Public methods ***</span>

    <span class="k">def</span> <span class="nf">without_units_for_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of the model for which the parameter values have</span>
<span class="sd">        been converted to the right units for the data, then the units have</span>
<span class="sd">        been stripped away.</span>

<span class="sd">        The input and output Quantity objects should be given as keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is needed in order to be able to fit models with units in</span>
<span class="sd">        the parameters, since we need to temporarily strip away the units from</span>
<span class="sd">        the model during the fitting (which might be done by e.g. scipy</span>
<span class="sd">        functions).</span>

<span class="sd">        The units that the parameters should be converted to are not</span>
<span class="sd">        necessarily the units of the input data, but are derived from them.</span>
<span class="sd">        Model subclasses that want fitting to work in the presence of</span>
<span class="sd">        quantities need to define a ``_parameter_units_for_data_units`` method</span>
<span class="sd">        that takes the input and output units (as two dictionaries) and</span>
<span class="sd">        returns a dictionary giving the target units for each parameter.</span>

<span class="sd">        For compound models this will only work when the expression only</span>
<span class="sd">        involves the addition or subtraction operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_opset</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opset</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">((</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Fitting a compound model without units can only be performed on&quot;</span>
                    <span class="s2">&quot;compound models that only use the arithmetic operators + and -&quot;</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">inputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">outputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="n">parameter_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">inputs_unit</span><span class="p">,</span>
                                                               <span class="n">outputs_unit</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">parameter_units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parameter</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parameter</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">quantity</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">parameter</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">model</span><span class="o">.</span><span class="n">strip_units_from_tree</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">strip_units_from_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parname</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">par</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">parname</span><span class="p">)</span>
                <span class="n">par</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_units_from_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of the model which has units for which the parameter</span>
<span class="sd">        values are compatible with the data units specified.</span>

<span class="sd">        The input and output Quantity objects should be given as keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is needed in order to be able to fit models with units in</span>
<span class="sd">        the parameters, since we need to temporarily strip away the units from</span>
<span class="sd">        the model during the fitting (which might be done by e.g. scipy</span>
<span class="sd">        functions).</span>

<span class="sd">        The units that the parameters will gain are not necessarily the units</span>
<span class="sd">        of the input data, but are derived from them. Model subclasses that</span>
<span class="sd">        want fitting to work in the presence of quantities need to define a</span>
<span class="sd">        ``_parameter_units_for_data_units`` method that takes the input and output</span>
<span class="sd">        units (as two dictionaries) and returns a dictionary giving the target</span>
<span class="sd">        units for each parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">inputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">outputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">parameter_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">inputs_unit</span><span class="p">,</span>
                                                               <span class="n">outputs_unit</span><span class="p">)</span>

        <span class="c1"># We are adding units to parameters that already have a value, but we</span>
        <span class="c1"># don&#39;t want to convert the parameter, just add the unit directly,</span>
        <span class="c1"># hence the call to ``_set_unit``.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">parameter_units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">parameter</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_has_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Returns True if any of the parameters have units</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_supports_unit_fitting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If the model has a ``_parameter_units_for_data_units`` method, this</span>
        <span class="c1"># indicates that we have enough information to strip the units away</span>
        <span class="c1"># and add them back after fitting, when fitting quantities</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_parameter_units_for_data_units&#39;</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the model on some input variables.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sum_of_implicit_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the sum of any implicit model terms on some input variables.</span>
<span class="sd">        This includes any fixed terms used in evaluating a linear model that</span>
<span class="sd">        do not have corresponding parameters exposed to the user. The</span>
<span class="sd">        prototypical case is `astropy.modeling.functional_models.Shift`, which</span>
<span class="sd">        corresponds to a function y = a + bx, where b=1 is intrinsically fixed</span>
<span class="sd">        by the type of model, such that sum_of_implicit_terms(x) == x. This</span>
<span class="sd">        method is needed by linear fitters to correct the dependent variable</span>
<span class="sd">        for the implicit term(s) when solving for the remaining terms</span>
<span class="sd">        (ie. a = y - bx).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a model at fixed positions, respecting the ``bounding_box``.</span>

<span class="sd">        The key difference relative to evaluating the model directly is that</span>
<span class="sd">        this method is limited to a bounding box if the `Model.bounding_box`</span>
<span class="sd">        attribute is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            An array that the evaluated model will be added to.  If this is not</span>
<span class="sd">            given (or given as ``None``), a new array will be created.</span>
<span class="sd">        coords : array_like, optional</span>
<span class="sd">            An array to be used to translate from the model&#39;s input coordinates</span>
<span class="sd">            to the ``out`` array. It should have the property that</span>
<span class="sd">            ``self(coords)`` yields the same shape as ``out``.  If ``out`` is</span>
<span class="sd">            not specified, ``coords`` will be used to determine the shape of</span>
<span class="sd">            the returned array. If this is not provided (or None), the model</span>
<span class="sd">            will be evaluated on a grid determined by `Model.bounding_box`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            The model added to ``out`` if  ``out`` is not ``None``, or else a</span>
<span class="sd">            new array from evaluating the model over ``coords``.</span>
<span class="sd">            If ``out`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">            limited to the `Model.bounding_box` limits. If</span>
<span class="sd">            `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be</span>
<span class="sd">            passed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``coords`` are not given and the the `Model.bounding_box` of</span>
<span class="sd">            this model is not set.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`bounding-boxes`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set, &#39;</span>
                             <span class="s1">&#39;coords or out must be input.&#39;</span><span class="p">)</span>

        <span class="c1"># for consistent indexing</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Check dimensions match out and model</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndim</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;inconsistent shape of the output.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the array and model must have the same &#39;</span>
                                 <span class="s1">&#39;number of dimensions.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assures position is at center pixel,</span>
            <span class="c1"># important when using add_array.</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">pd</span>

            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;The `bounding_box` is larger than the input out in &#39;</span>
                        <span class="s1">&#39;one or more dimensions. Set &#39;</span>
                        <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_shape</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property is used to indicate what units or sets of units the</span>
<span class="sd">        evaluate method expects, and returns a dictionary mapping inputs to</span>
<span class="sd">        units (or `None` if any units are accepted).</span>

<span class="sd">        Model sub-classes can also use function annotations in evaluate to</span>
<span class="sd">        indicate valid input units, in which case this property should</span>
<span class="sd">        not be overridden since it will return the input units based on the</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_input_units&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">):</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="o">.</span><span class="vm">__annotations__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">annotations</span><span class="p">:</span>
                <span class="c1"># If there are not annotations for all inputs this will error.</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">annotations</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># None means any unit is accepted</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">return_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property is used to indicate what units or sets of units the</span>
<span class="sd">        output of evaluate should be in, and returns a dictionary mapping</span>
<span class="sd">        outputs to units (or `None` if any units are accepted).</span>

<span class="sd">        Model sub-classes can also use function annotations in evaluate to</span>
<span class="sd">        indicate valid output units, in which case this property should not be</span>
<span class="sd">        overridden since it will return the return units based on the</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_return_units&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_units</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="o">.</span><span class="vm">__annotations__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># None means any unit is accepted</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">prepare_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used in `~astropy.modeling.Model.__call__` to ensure</span>
<span class="sd">        that all the inputs to the model can be broadcast into compatible</span>
<span class="sd">        shapes (if one or both of them are input as arrays), particularly if</span>
<span class="sd">        there are more than one parameter sets. This also makes sure that (if</span>
<span class="sd">        applicable) the units of the input will be compatible with the evaluate</span>
<span class="sd">        method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># When we instantiate the model class, we make sure that __call__ can</span>
        <span class="c1"># take the following two keyword arguments: model_set_axis and</span>
        <span class="c1"># equivalencies.</span>

        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># By default the model_set_axis for the input is assumed to be the</span>
            <span class="c1"># same as that for the parameters the model was defined with</span>
            <span class="c1"># TODO: Ensure that negative model_set_axis arguments are respected</span>
            <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span>

        <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">_input</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="n">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span>
                               <span class="n">model_set_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">)</span>

        <span class="n">inputs_map</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inputs_map&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">,</span> <span class="n">inputs_map</span><span class="p">)</span>

        <span class="c1"># The input formatting required for single models versus a multiple</span>
        <span class="c1"># model set are different enough that they&#39;ve been split into separate</span>
        <span class="c1"># subroutines</span>
        <span class="k">if</span> <span class="n">n_models</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_inputs_single_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_inputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span>
                                             <span class="n">model_set_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inputs_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="c1"># Check that the units are correct, if applicable</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If a leaflist is provided that means this is in the context of</span>
            <span class="c1"># a compound model and it is necessary to create the appropriate</span>
            <span class="c1"># alias for the input coordinate name for the equivalencies dict</span>
            <span class="k">if</span> <span class="n">inputs_map</span><span class="p">:</span>
                <span class="n">edict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">mod</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">mod</span><span class="p">:</span>
                        <span class="n">edict</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">equivalencies</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edict</span> <span class="o">=</span> <span class="n">equivalencies</span>
            <span class="c1"># We combine any instance-level input equivalencies with user</span>
            <span class="c1"># specified ones at call-time.</span>
            <span class="n">input_units_equivalencies</span> <span class="o">=</span> <span class="n">_combine_equivalency_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                                                  <span class="n">edict</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">input_units_equivalencies</span><span class="p">)</span>

            <span class="c1"># We now iterate over the different inputs and make sure that their</span>
            <span class="c1"># units are consistent with those specified in input_units.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)):</span>

                <span class="n">input_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">input_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Quantity</span><span class="p">):</span>

                    <span class="c1"># We check for consistency of the units with input_units,</span>
                    <span class="c1"># taking into account any equivalencies</span>

                    <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span>
                            <span class="n">input_unit</span><span class="p">,</span>
                            <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">input_name</span><span class="p">]):</span>

                        <span class="c1"># If equivalencies have been specified, we need to</span>
                        <span class="c1"># convert the input to the input units - this is</span>
                        <span class="c1"># because some equivalencies are non-linear, and</span>
                        <span class="c1"># we need to be sure that we evaluate the model in</span>
                        <span class="c1"># its own frame of reference. If input_units_strict</span>
                        <span class="c1"># is set, we also need to convert to the input units.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_units_equivalencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units_strict</span><span class="p">[</span><span class="n">input_name</span><span class="p">]:</span>
                            <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">input_unit</span><span class="p">,</span>
                                                     <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">input_name</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="c1"># We consider the following two cases separately so as</span>
                        <span class="c1"># to be able to raise more appropriate/nicer exceptions</span>

                        <span class="k">if</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="n">dimensionless_unscaled</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: Units of input &#39;</span><span class="si">{1}</span><span class="s2">&#39;, </span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{3}</span><span class="s2">),&quot;</span>
                                             <span class="s2">&quot;could not be converted to &quot;</span>
                                             <span class="s2">&quot;required dimensionless &quot;</span>
                                             <span class="s2">&quot;input&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                            <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                                                            <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: Units of input &#39;</span><span class="si">{1}</span><span class="s2">&#39;, </span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{3}</span><span class="s2">),&quot;</span>
                                             <span class="s2">&quot; could not be &quot;</span>
                                             <span class="s2">&quot;converted to required input&quot;</span>
                                             <span class="s2">&quot; units of </span><span class="si">{4}</span><span class="s2"> (</span><span class="si">{5}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                 <span class="n">name</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                 <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                                                 <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">,</span>
                                                 <span class="n">input_unit</span><span class="p">,</span>
                                                 <span class="n">input_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># If we allow dimensionless input, we add the units to the</span>
                    <span class="c1"># input values without conversion, otherwise we raise an</span>
                    <span class="c1"># exception.</span>

                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units_allow_dimensionless</span><span class="p">[</span><span class="n">input_name</span><span class="p">]</span> <span class="ow">and</span>
                        <span class="n">input_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dimensionless_unscaled</span> <span class="ow">and</span>
                        <span class="n">input_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: Units of input &#39;</span><span class="si">{1}</span><span class="s2">&#39;, (dimensionless), could not be &quot;</span>
                                             <span class="s2">&quot;converted to required input units of &quot;</span>
                                             <span class="s2">&quot;</span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{3}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">input_unit</span><span class="p">,</span>
                                                                <span class="n">input_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">inputs</span>

    <span class="k">def</span> <span class="nf">_process_output_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">inputs_are_quantity</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span> <span class="ow">and</span> <span class="n">inputs_are_quantity</span><span class="p">:</span>
            <span class="c1"># We allow a non-iterable unit only if there is one output</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_units</span><span class="p">):</span>
                <span class="n">return_units</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span>

            <span class="n">outputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Quantity</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">return_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">out_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="k">def</span> <span class="nf">prepare_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_info</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_outputs_single_model</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_outputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model.</span>

<span class="sd">        Uses a deep copy so that all model attributes, including parameter</span>
<span class="sd">        values, are copied as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deep copy of this model.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model with a new name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">new_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of components in a single model, which is</span>
<span class="sd">        obviously 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_initialize_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop parameter constraint values off the keyword arguments passed to</span>
<span class="sd">        `Model.__init__` and store them in private instance attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Pop any constraints off the keyword arguments</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">for</span> <span class="n">ckey</span><span class="p">,</span> <span class="n">cvalue</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ckey</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_initialize_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the _parameters array that stores raw parameter values for</span>
<span class="sd">        all parameter sets for use with vectorized fitting algorithms; on</span>
<span class="sd">        FittableModels the _param_name attributes actually just reference</span>
<span class="sd">        slices of this array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_models&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n_models</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;n_models must be either None (in which case it is &quot;</span>
                <span class="s2">&quot;determined from the model_set_axis of the parameter initial &quot;</span>
                <span class="s2">&quot;values) or it must be a positive integer &quot;</span>
                <span class="s2">&quot;(got </span><span class="si">{0!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_models</span><span class="p">))</span>

        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Default to zero</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise disable</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;model_set_axis must be either False or an integer &quot;</span>
                    <span class="s2">&quot;specifying the parameter array axis to map to each &quot;</span>
                    <span class="s2">&quot;model in a set of models (got </span><span class="si">{0!r}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">model_set_axis</span><span class="p">))</span>

        <span class="c1"># Process positional arguments by matching them up with the</span>
        <span class="c1"># corresponding parameters in self.param_names--if any also appear as</span>
        <span class="c1"># keyword arguments this presents a conflict</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() takes at most </span><span class="si">{1}</span><span class="s2"> positional arguments (</span><span class="si">{2}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;given)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">model_set_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># A value of None implies using the default value, if exists</span>
                <span class="k">continue</span>
            <span class="c1"># We use quantity_asanyarray here instead of np.asanyarray because</span>
            <span class="c1"># if any of the arguments are quantities, we need to return a</span>
            <span class="c1"># Quantity object not a plain Numpy array.</span>
            <span class="n">param_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">quantity_asanyarray</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_value</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># At this point the only remaining keyword arguments should be</span>
        <span class="c1"># parameter names; any others are in error.</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() got multiple values for parameter &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">param_name</span><span class="p">))</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># We use quantity_asanyarray here instead of np.asanyarray</span>
                <span class="c1"># because if any of the arguments are quantities, we need</span>
                <span class="c1"># to return a Quantity object not a plain Numpy array.</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">quantity_asanyarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_value</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Now deal with case where param_name is not supplied by args or kwargs</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_value</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># If any keyword arguments were left over at this point they are</span>
            <span class="c1"># invalid--the base class should only be passed the parameter</span>
            <span class="c1"># values, constraints, and param_dim</span>
            <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="c1"># Just raise an error on the first unrecognized argument</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.__init__() got an unrecognized parameter &#39;</span>
                    <span class="s1">&#39;</span><span class="si">{1!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">))</span>

        <span class="c1"># Determine the number of model sets: If the model_set_axis is</span>
        <span class="c1"># None then there is just one parameter set; otherwise it is determined</span>
        <span class="c1"># by the size of that axis on the first parameter--if the other</span>
        <span class="c1"># parameters don&#39;t have the right number of axes or the sizes of their</span>
        <span class="c1"># model_set_axis don&#39;t match an error is raised</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">max_ndim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">param_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">min_ndim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="s2">&quot;All parameter values must be arrays of dimension &quot;</span>
                        <span class="s2">&quot;at least </span><span class="si">{0}</span><span class="s2"> for model_set_axis=</span><span class="si">{1}</span><span class="s2"> (the value &quot;</span>
                        <span class="s2">&quot;given for </span><span class="si">{2!r}</span><span class="s2"> is only </span><span class="si">{3}</span><span class="s2">-dimensional)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">min_ndim</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">param_ndim</span><span class="p">))</span>

                <span class="n">max_ndim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_ndim</span><span class="p">,</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Use the dimensions of the first parameter to determine</span>
                    <span class="c1"># the number of model sets</span>
                    <span class="n">n_models</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="s2">&quot;Inconsistent dimensions for parameter </span><span class="si">{0!r}</span><span class="s2"> for &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2"> model sets.  The length of axis </span><span class="si">{2}</span><span class="s2"> must be the &quot;</span>
                        <span class="s2">&quot;same for all input parameter values&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="n">max_ndim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_models</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="n">n_models</span>
        <span class="c1"># now validate parameters</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_parameter_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mostly deals with consistency checks and determining unit issues.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
        <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
        <span class="c1"># Use default if value is not provided</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>
            <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># No value was supplied for the parameter and the</span>
                <span class="c1"># parameter does not have a default, therefore the model</span>
                <span class="c1"># is underspecified</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() requires a value for parameter &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">param_name</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">default</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.__init__() requires a Quantity for parameter &quot;</span>
                <span class="s2">&quot;</span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">param_name</span><span class="p">))</span>
        <span class="n">param</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_val</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">unit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_val</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_val</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="o">=</span> <span class="n">_val</span><span class="o">.</span><span class="n">unit</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_internal_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_val</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_internal_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">param_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">param_size</span><span class="p">)</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_slice</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_shape</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_size</span>
            <span class="n">total_size</span> <span class="o">+=</span> <span class="n">param_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parameters_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Now set the parameter values (this will also fill</span>
        <span class="c1"># self._parameters)</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Finally validate all the parameters; we do this last so that</span>
        <span class="c1"># validators that depend on one of the other parameters&#39; values will</span>
        <span class="c1"># work</span>

    <span class="k">def</span> <span class="nf">_array_to_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]]</span>
            <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
            <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_check_param_broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_ndim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This subroutine checks that all parameter arrays can be broadcast</span>
<span class="sd">        against each other, and determines the shapes parameters must have in</span>
<span class="sd">        order to broadcast correctly.</span>

<span class="sd">        If model_set_axis is None this merely checks that the parameters</span>
<span class="sd">        broadcast and returns an empty dict if so.  This mode is only used for</span>
<span class="sd">        single model sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_ndim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">max_ndim</span><span class="p">:</span>
                <span class="c1"># All arrays have the same number of dimensions up to the</span>
                <span class="c1"># model_set_axis dimension, but after that they may have a</span>
                <span class="c1"># different number of trailing axes.  The number of trailing</span>
                <span class="c1"># axes must be extended for mutual compatibility.  For example</span>
                <span class="c1"># if max_ndim = 3 and model_set_axis = 0, an array with the</span>
                <span class="c1"># shape (2, 2) must be extended to (2, 1, 2).  However, an</span>
                <span class="c1"># array with shape (2,) is extended to (2, 1).</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_ndim</span> <span class="o">-</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Just need to prepend axes to make up the difference</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">param_shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">param_shape</span><span class="p">[:</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">new_axes</span> <span class="o">+</span>
                                       <span class="n">param_shape</span><span class="p">[</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;broadcast_shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_shape</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>

        <span class="c1"># Now check mutual broadcastability of all shapes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">IncompatibleShapeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">shape_a</span><span class="p">,</span> <span class="n">shape_a_idx</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">,</span> <span class="n">shape_b_idx</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span>
            <span class="n">param_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">shape_a_idx</span><span class="p">]</span>
            <span class="n">param_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">shape_b_idx</span><span class="p">]</span>

            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s2">&quot;Parameter </span><span class="si">{0!r}</span><span class="s2"> of shape </span><span class="si">{1!r}</span><span class="s2"> cannot be broadcast with &quot;</span>
                <span class="s2">&quot;parameter </span><span class="si">{2!r}</span><span class="s2"> of shape </span><span class="si">{3!r}</span><span class="s2">.  All parameter arrays &quot;</span>
                <span class="s2">&quot;must have shapes that are mutually compatible according &quot;</span>
                <span class="s2">&quot;to the broadcasting rules.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_a</span><span class="p">,</span> <span class="n">shape_a</span><span class="p">,</span>
                                                    <span class="n">param_b</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of the Model.param_sets property.</span>

<span class="sd">        This internal implementation has a ``raw`` argument which controls</span>
<span class="sd">        whether or not to return the raw parameter values (i.e. the values that</span>
<span class="sd">        are actually stored in the ._parameters array, as opposed to the values</span>
<span class="sd">        displayed to users.  In most cases these are one in the same but there</span>
<span class="sd">        are currently a few exceptions.</span>

<span class="sd">        Note: This is notably an overcomplicated device and may be removed</span>
<span class="sd">        entirely in the near future.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">raw</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_internal_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>

            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_shape&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

            <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Add a single param set axis to the parameter&#39;s value (thus</span>
                <span class="c1"># converting scalars to shape (1,) array values) for</span>
                <span class="c1"># consistency</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">units</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raw</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">units</span><span class="p">:</span>
            <span class="c1"># If the parameters are not all the same shape, converting to an</span>
            <span class="c1"># array is going to produce an object array</span>
            <span class="c1"># However the way Numpy creates object arrays is tricky in that it</span>
            <span class="c1"># will recurse into array objects in the list and break them up</span>
            <span class="c1"># into separate objects.  Doing things this way ensures a 1-D</span>
            <span class="c1"># object array the elements of which are the individual parameter</span>
            <span class="c1"># arrays.  There&#39;s not much reason to do this over returning a list</span>
            <span class="c1"># except for consistency</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">psets</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">return</span> <span class="n">psets</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                             <span class="n">param_repr_oneline</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;name=</span><span class="si">{0!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">defaults</span> <span class="ow">and</span> <span class="n">defaults</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">=</span><span class="si">{1!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwarg</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;n_models=</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{0}</span><span class="s1">(</span><span class="si">{1}</span><span class="s1">)&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__str__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__str__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Inputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Outputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Model set size&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span> <span class="o">+</span> <span class="n">keywords</span>
                 <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Parameters:&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">param_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
            <span class="c1"># Set units on the columns</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">param_table</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">param_table</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FittableModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for models that can be fitted using the built-in fitting</span>
<span class="sd">    algorithms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># derivative with respect to parameters</span>
    <span class="n">fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function (similar to the model&#39;s `~Model.evaluate`) to compute the</span>
<span class="sd">    derivatives of the model with respect to its parameters, for use by fitting</span>
<span class="sd">    algorithms.  In other words, this computes the Jacobian matrix with respect</span>
<span class="sd">    to the model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Flag that indicates if the model derivatives with respect to parameters</span>
    <span class="c1"># are given in columns or rows</span>
    <span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Fittable1DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for one-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_inputs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">n_outputs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">_separable</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Fittable2DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for two-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_inputs</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n_outputs</span> <span class="o">=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_make_arithmetic_operator</span><span class="p">(</span><span class="n">oper</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">make_binary_operator_eval</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">op</span>


<span class="k">def</span> <span class="nf">_composition_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">),</span> <span class="n">params</span><span class="p">),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_join_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[:</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span>
                                    <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]:],</span> <span class="n">params</span><span class="p">)),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="n">BINARY_OPERATORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">),</span>
    <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">),</span>
    <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">),</span>
    <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">),</span>
    <span class="s1">&#39;**&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">),</span>
    <span class="s1">&#39;|&#39;</span><span class="p">:</span> <span class="n">_composition_operator</span><span class="p">,</span>
    <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span> <span class="n">_join_operator</span>
<span class="p">}</span>

<span class="n">SPECIAL_OPERATORS</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">_add_special_operator</span><span class="p">(</span><span class="n">sop_name</span><span class="p">,</span> <span class="n">sop</span><span class="p">):</span>
    <span class="n">SPECIAL_OPERATORS</span><span class="p">[</span><span class="n">sop_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sop</span>


<span class="k">class</span> <span class="nc">CompoundModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Base class for compound models.</span>

<span class="sd">    While it can be used directly, the recommended way</span>
<span class="sd">    to combine models is through the model operators.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_param_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_submodels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tdict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_inverse</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># may be set to True in following code</span>
        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">inverse</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;fix_inputs&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Both operands must have equal values for n_models&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;fix_inputs&#39;</span> <span class="ow">and</span> <span class="p">((</span><span class="n">left</span><span class="o">.</span><span class="n">model_set_axis</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">)</span>
                                   <span class="ow">or</span> <span class="n">left</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">):</span>  <span class="c1"># not False and not 0</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;model_set_axis must be False or 0 and consistent for operands&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">model_set_axis</span>

        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">SPECIAL_OPERATORS</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s1">&#39;Both operands must match numbers of inputs and outputs&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">both_inverses_exist</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_inverse</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span>
                                    <span class="n">inverse</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="n">inv</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">_has_inverse</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span><span class="o">.</span><span class="n">_user_inverse</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">_has_inverse</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span> <span class="o">=</span> <span class="n">inv</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported operands for |: </span><span class="si">{0}</span><span class="s2"> (n_inputs=</span><span class="si">{1}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;n_outputs=</span><span class="si">{2}</span><span class="s2">) and </span><span class="si">{3}</span><span class="s2"> (n_inputs=</span><span class="si">{4}</span><span class="s2">, n_outputs=</span><span class="si">{5}</span><span class="s2">); &quot;</span>
                    <span class="s2">&quot;n_outputs for the left-hand model must match n_inputs &quot;</span>
                    <span class="s2">&quot;for the right-hand model.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">left</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span>
            <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">both_inverses_exist</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_inverse</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span>
                                    <span class="n">inverse</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="n">inv</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">_has_inverse</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span><span class="o">.</span><span class="n">_user_inverse</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">_has_inverse</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span> <span class="o">=</span> <span class="n">inv</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;First argument to &quot;fix_inputs&quot; must be an instance of an astropy Model.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected a dictionary for second argument of &quot;fix_inputs&quot;.&#39;</span><span class="p">)</span>

            <span class="c1"># Dict keys must match either possible indices</span>
            <span class="c1"># for model on left side, or names for inputs.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="c1"># Assign directly to the private attribute (instead of using the setter)</span>
            <span class="c1"># to avoid asserting the new number of outputs matches the old one.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="n">newinputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">input_ind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Substitution key integer value &#39;</span>
                            <span class="s1">&#39;not among possible input choices.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_ind</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate specification of &quot;</span>
                                         <span class="s2">&quot;same input (index/name).&quot;</span><span class="p">)</span>
                    <span class="n">input_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Substitution key string not among possible &#39;</span>
                            <span class="s1">&#39;input choices.&#39;</span><span class="p">)</span>
                    <span class="c1"># Check to see it doesn&#39;t match positional</span>
                    <span class="c1"># specification.</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">input_ind</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate specification of &quot;</span>
                                         <span class="s2">&quot;same input (index/name).&quot;</span><span class="p">)</span>
                    <span class="n">input_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="c1"># Remove substituted inputs</span>
            <span class="n">input_ind</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">input_ind</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">input_ind</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">newinputs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newinputs</span><span class="p">)</span>
            <span class="c1"># Now check to see if the input model has bounding_box defined.</span>
            <span class="c1"># If so, remove the appropriate dimensions and set it for this</span>
            <span class="c1"># instance.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">bounding_box</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fix_input_bounding_box</span><span class="p">(</span><span class="n">input_ind</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s1">&#39;Illegal operator: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">linear</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">linear</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eqcons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ineqcons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">submodel_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the names of submodels in a ``CompoundModel``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">]</span>
        <span class="n">nonecount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;None_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nonecount</span><span class="p">))</span>
                <span class="n">nonecount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newnames</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">both_inverses_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if both members of this compound model have inverses return True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">linv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inverse</span>
            <span class="n">rinv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># Turn any keyword arguments into positional arguments.</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_renamed_inputs_as_positional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="c1"># If equivalencies are provided, necessary to map parameters and pass</span>
        <span class="c1"># the leaflist as a keyword input for use by model evaluation so that</span>
        <span class="c1"># the compound model input names can be matched to the model input</span>
        <span class="c1"># names.</span>

        <span class="k">if</span> <span class="s1">&#39;equivalencies&#39;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="c1"># Restructure to be useful for the individual model lookup</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;inputs_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span> <span class="k">for</span>
                                <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="n">with_bbox</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># Use of bounding box for compound models requires special treatment</span>
        <span class="c1"># in selecting only valid inputs to pass along to constituent models.</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">get_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_bbox</span> <span class="ow">and</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># first check inputs are consistent in shape</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_validate_input_shapes</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">)</span>
            <span class="n">vinputs</span><span class="p">,</span> <span class="n">valid_ind</span><span class="p">,</span> <span class="n">allout</span> <span class="o">=</span> <span class="n">prepare_bounding_box_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">bbox</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allout</span><span class="p">:</span>
                <span class="n">valid_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">vinputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">valid_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">valid_result</span><span class="p">]</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="n">prepare_bounding_box_outputs</span><span class="p">(</span><span class="n">valid_result</span><span class="p">,</span> <span class="n">valid_ind</span><span class="p">,</span>
                                                       <span class="n">input_shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">fill_value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">)]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">outputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="n">leftval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
                    <span class="n">rightval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">leftval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">]),</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="n">rightval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:]),</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;**&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">leftval</span> <span class="o">=</span> <span class="p">(</span><span class="n">leftval</span><span class="p">,)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rightval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">rightval</span> <span class="o">=</span> <span class="p">(</span><span class="n">rightval</span><span class="p">,)</span>
                <span class="k">return</span> <span class="n">leftval</span> <span class="o">+</span> <span class="n">rightval</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">*</span><span class="n">leftval</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">SPECIAL_OPERATORS</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">SPECIAL_OPERATORS</span><span class="p">[</span><span class="n">op</span><span class="p">],</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s1">&#39;Unrecognized operator </span><span class="si">{op}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">subinds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">subvals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">subs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">subinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">subinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">subvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Turn inputs specified in kw into positional indices.</span>
            <span class="c1"># Names for compound inputs do not propagate to sub models.</span>
            <span class="n">kwind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kwval</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">kwkey</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">kwkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kwkey</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Keyword argument duplicates &quot;</span>
                                         <span class="s2">&quot;positional value supplied.&quot;</span><span class="p">)</span>
                    <span class="n">kwind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                    <span class="n">kwval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="n">kwkey</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">kw</span><span class="p">[</span><span class="n">kwkey</span><span class="p">]</span>
            <span class="c1"># Build new argument list</span>
            <span class="c1"># Append keyword specified args first</span>
            <span class="k">if</span> <span class="n">kwind</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">kwind</span><span class="p">,</span> <span class="n">kwval</span><span class="p">))</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">kwindsorted</span><span class="p">,</span> <span class="n">kwvalsorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="n">newargs</span> <span class="o">=</span> <span class="n">newargs</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwvalsorted</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subinds</span><span class="p">:</span>
                <span class="n">subargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">subinds</span><span class="p">,</span> <span class="n">subvals</span><span class="p">))</span>
                <span class="n">subargs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="c1">#subindsorted, subvalsorted = list(zip(*subargs))</span>
            <span class="c1"># The substitutions must be inserted in order</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">subargs</span><span class="p">:</span>
                <span class="n">newargs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An ordered list of parameter names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>

    <span class="k">def</span> <span class="nf">_make_leaflist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">leaflist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">make_subtree_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="o">=</span> <span class="n">leaflist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tdict</span> <span class="o">=</span> <span class="n">tdict</span>

    <span class="k">def</span> <span class="nf">_make_opset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine the set of operations used in this tree.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">get_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opset</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If someone accesses an attribute not already defined, map the</span>
<span class="sd">        parameters, and then see if the requested attribute is one of</span>
<span class="sd">        the parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The following test is needed to avoid infinite recursion</span>
        <span class="c1"># caused by deepcopy. There may be other such cases discovered.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;__setstate__&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Attribute &quot;</span><span class="si">{}</span><span class="s1">&quot; not found&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="n">leaflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span>
        <span class="n">tdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tdict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Steps in slices not supported &#39;</span>
                                 <span class="s1">&#39;for compound models&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_index_to_int</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_index_to_int</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Slice endpoint cannot be 0&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span> <span class="o">+</span> <span class="n">stop</span>
            <span class="c1"># now search for matching node:</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>  <span class="c1"># only single value, get leaf instead in code below</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tdict</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">leftind</span><span class="p">,</span> <span class="n">rightind</span> <span class="o">=</span> <span class="n">tdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">leftind</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">rightind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">node</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;No appropriate subtree matches slice&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">leaflist</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">leaflist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_str_index_to_int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;index must be integer, slice, or model name string&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_str_index_to_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">str_index</span><span class="p">):</span>
                <span class="c1"># Search through leaflist for item with that name</span>
        <span class="n">found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nleaf</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">str_index</span><span class="p">:</span>
                <span class="n">found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nleaf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;No component with name &#39;</span><span class="si">{}</span><span class="s2">&#39; found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">str_index</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Multiple components found using &#39;</span><span class="si">{}</span><span class="s2">&#39; as name</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;at indices </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">str_index</span><span class="p">,</span> <span class="n">found</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The number of inputs of a model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_inputs</span>

    <span class="nd">@n_inputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_inputs</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The number of outputs of a model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_outputs</span>

    <span class="nd">@n_outputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_outputs</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span>

    <span class="nd">@eqcons</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span>

    <span class="nd">@ineqcons</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">traverse_postorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_operator</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Postorder traversal of the CompoundModel tree.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">(</span><span class="n">include_operator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">(</span><span class="n">include_operator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">include_operator</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_format_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_leaf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">leaf_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">operands</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">format_leaf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">format_leaf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s1">&#39;[</span><span class="si">{0}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_leaf</span><span class="p">(</span><span class="n">leaf_idx</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                <span class="n">leaf_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">oper_order</span> <span class="o">=</span> <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">]</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">op</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">oper_order</span><span class="p">):</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">op</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">oper_order</span><span class="p">):</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

            <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">right</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">{0}</span><span class="s1">]: </span><span class="si">{1!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_expression</span><span class="p">()</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_components</span><span class="p">()</span>
        <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Expression&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Components&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">indent</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_format_str</span><span class="p">(</span><span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isleaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_inverse</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Inverse function not provided&quot;</span><span class="p">)</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempt to assign non model to inverse&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_inverse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_inverse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fittable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the fittable attribute on a compound model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">fittable</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span>

    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_map_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map all the constituent model parameters to the compound object,</span>
<span class="sd">        renaming as necessary by appending a suffix number.</span>

<span class="sd">        This can be an expensive operation, particularly for a complex</span>
<span class="sd">        expression tree.</span>

<span class="sd">        All the corresponding parameter attributes are created that one</span>
<span class="sd">        expects for the Model class.</span>

<span class="sd">        The parameter objects that the attributes point to are the same</span>
<span class="sd">        objects as in the constiutent models. Changes made to parameter</span>
<span class="sd">        values to either are seen by both.</span>

<span class="sd">        Prior to calling this, none of the associated attributes will</span>
<span class="sd">        exist. This method must be called to make the model usable by</span>
<span class="sd">        fitting engines.</span>

<span class="sd">        If oldnames=True, then parameters are named as in the original</span>
<span class="sd">        implementation of compound models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># do nothing</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">param_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lindex</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">leaf</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                    <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                    <span class="n">new_param_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">lindex</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">new_param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">[</span><span class="n">new_param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_param_name</span><span class="p">)</span>
                    <span class="n">param_map</span><span class="p">[</span><span class="n">new_param_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lindex</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_map</span> <span class="o">=</span> <span class="n">param_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_map_inverse</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_map</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_slices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">param_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">param_size</span><span class="p">)</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_slice</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_shape</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_size</span>
            <span class="n">total_size</span> <span class="o">+=</span> <span class="n">param_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_lookup</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">adict</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">adict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">branch</span><span class="p">,</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">inputs_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map the names of the inputs to this ExpressionTree to the inputs to the leaf models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># If we don&#39;t have an operator the mapping is trivial</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">inp</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">r_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>  <span class="c1"># Get from left</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_inputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Get from right</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_inputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">)]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">inp</span>
        <span class="k">return</span> <span class="n">inputs_map</span>

    <span class="k">def</span> <span class="nf">_parameter_units_for_data_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_units</span><span class="p">,</span> <span class="n">output_units</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>
        <span class="n">units_for_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">imodel</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">):</span>
            <span class="n">units_for_data_leaf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">input_units</span><span class="p">,</span> <span class="n">output_units</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param_leaf</span> <span class="ow">in</span> <span class="n">units_for_data_leaf</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_map_inverse</span><span class="p">[(</span><span class="n">imodel</span><span class="p">,</span> <span class="n">param_leaf</span><span class="p">)]</span>
                <span class="n">units_for_data</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">units_for_data_leaf</span><span class="p">[</span><span class="n">param_leaf</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">units_for_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="n">input_units_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">input_units_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">input_units_dict</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_equivalencies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_allow_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_allow_dimensionless</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_strict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_strict</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">return_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">return_units</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">return_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">outputs_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map the names of the outputs to this ExpressionTree to the outputs to the leaf models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outputs_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># If we don&#39;t have an operator the mapping is trivial</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">}</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="n">r_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="n">out</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="n">l_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="n">r_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>  <span class="c1"># Get from left</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_outputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Get from right</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_outputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">)]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">)]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_outputs_map</span><span class="p">()[</span><span class="n">out</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">outputs_map</span>

    <span class="k">def</span> <span class="nf">_fix_input_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the ``fix_inputs`` operator is used and the model it is applied to</span>
<span class="sd">        has a bounding box definition, delete the corresponding inputs from</span>
<span class="sd">        that bounding box. This method presumes the bounding_box is not None.</span>
<span class="sd">        This also presumes that the list of input indices to remove (i.e.,</span>
<span class="sd">        input_ind has already been put in reverse sorted order).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounding_box</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">input_ind</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">bounding_box</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom bounding_box has been</span>
<span class="sd">        assigned to this model by a user, via assignment to</span>
<span class="sd">        ``model.bounding_box``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a model at fixed positions, respecting the ``bounding_box``.</span>

<span class="sd">        The key difference relative to evaluating the model directly is that</span>
<span class="sd">        this method is limited to a bounding box if the `Model.bounding_box`</span>
<span class="sd">        attribute is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            An array that the evaluated model will be added to.  If this is not</span>
<span class="sd">            given (or given as ``None``), a new array will be created.</span>
<span class="sd">        coords : array_like, optional</span>
<span class="sd">            An array to be used to translate from the model&#39;s input coordinates</span>
<span class="sd">            to the ``out`` array. It should have the property that</span>
<span class="sd">            ``self(coords)`` yields the same shape as ``out``.  If ``out`` is</span>
<span class="sd">            not specified, ``coords`` will be used to determine the shape of</span>
<span class="sd">            the returned array. If this is not provided (or None), the model</span>
<span class="sd">            will be evaluated on a grid determined by `Model.bounding_box`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            The model added to ``out`` if  ``out`` is not ``None``, or else a</span>
<span class="sd">            new array from evaluating the model over ``coords``.</span>
<span class="sd">            If ``out`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">            limited to the `Model.bounding_box` limits. If</span>
<span class="sd">            `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be</span>
<span class="sd">            passed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``coords`` are not given and the the `Model.bounding_box` of</span>
<span class="sd">            this model is not set.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`bounding-boxes`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set, &#39;</span>
                             <span class="s1">&#39;coords or out must be input.&#39;</span><span class="p">)</span>

        <span class="c1"># for consistent indexing</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Check dimensions match out and model</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndim</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;inconsistent shape of the output.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the array and model must have the same &#39;</span>
                                 <span class="s1">&#39;number of dimensions.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assures position is at center pixel, important when usin</span>
            <span class="c1"># add_array.</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">pd</span>

            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;The `bounding_box` is larger than the input out in &#39;</span>
                        <span class="s1">&#39;one or more dimensions. Set &#39;</span>
                        <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_shape</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">binary_operation</span><span class="p">(</span><span class="n">binoperator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform binary operation. Operands may be matching tuples of operands.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">binoperator</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">binoperator</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_ops</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">opset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursive function to collect operators used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
        <span class="n">opset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
        <span class="n">get_ops</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">opset</span><span class="p">)</span>
        <span class="n">get_ops</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">opset</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span>


<span class="k">def</span> <span class="nf">make_subtree_dict</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">nodepath</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Traverse a tree noting each node by a key that indicates all the</span>
<span class="sd">    left/right choices necessary to reach that node. Each key will</span>
<span class="sd">    reference a tuple that contains:</span>

<span class="sd">    - reference to the compound model for that node.</span>
<span class="sd">    - left most index contained within that subtree</span>
<span class="sd">       (relative to all indices for the whole tree)</span>
<span class="sd">    - right most index contained within that subtree</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># if this is a leaf, just append it to the leaflist</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s1">&#39;isleaf&#39;</span><span class="p">):</span>
        <span class="n">leaflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">leftmostind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span>
        <span class="n">make_subtree_dict</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">nodepath</span><span class="o">+</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">)</span>
        <span class="n">make_subtree_dict</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">nodepath</span><span class="o">+</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">)</span>
        <span class="n">rightmostind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">tdict</span><span class="p">[</span><span class="n">nodepath</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">leftmostind</span><span class="p">,</span> <span class="n">rightmostind</span><span class="p">)</span>


<span class="n">_ORDER_OF_OPERATORS</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,)]</span>
<span class="n">OPERATOR_PRECEDENCE</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_ORDER_OF_OPERATORS</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
<span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">ops</span>


<span class="k">def</span> <span class="nf">fix_inputs</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a compound model with one or more of the input</span>
<span class="sd">    values of the input model assigned fixed values (scalar or array).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    modelinstance : Model instance. This is the model that one or more of the</span>
<span class="sd">        model input values will be fixed to some constant value.</span>
<span class="sd">    values : A dictionary where the key identifies which input to fix</span>
<span class="sd">        and its value is the value to fix it at. The key may either be the</span>
<span class="sd">        name of the input or a number reflecting its order in the inputs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from astropy.modeling.models import Gaussian2D</span>
<span class="sd">    &gt;&gt;&gt; g = Gaussian2D(1, 2, 3, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; gv = fix_inputs(g, {0: 2.5})</span>

<span class="sd">    Results in a 1D function equivalent to Gaussian2D(1, 2, 3, 4, 5)(x=2.5, y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">,</span> <span class="n">modelinstance</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">custom_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a model from a user defined function. The inputs and parameters of</span>
<span class="sd">    the model will be inferred from the arguments of the function.</span>

<span class="sd">    This can be used either as a function or as a decorator.  See below for</span>
<span class="sd">    examples of both usages.</span>

<span class="sd">    .. note::</span>

<span class="sd">        All model parameters have to be defined as keyword arguments with</span>
<span class="sd">        default values in the model function.  Use `None` as a default argument</span>
<span class="sd">        value if you do not want to have a default value for that parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Function which defines the model.  It should take N positional</span>
<span class="sd">        arguments where ``N`` is dimensions of the model (the number of</span>
<span class="sd">        independent variable in the model), and any number of keyword arguments</span>
<span class="sd">        (the parameters).  It must return the value of the model (typically as</span>
<span class="sd">        an array, but can also be a scalar for scalar inputs).  This</span>
<span class="sd">        corresponds to the `~astropy.modeling.Model.evaluate` method.</span>
<span class="sd">    fit_deriv : function, optional</span>
<span class="sd">        Function which defines the Jacobian derivative of the model. I.e., the</span>
<span class="sd">        derivative with respect to the *parameters* of the model.  It should</span>
<span class="sd">        have the same argument signature as ``func``, but should return a</span>
<span class="sd">        sequence where each element of the sequence is the derivative</span>
<span class="sd">        with respect to the corresponding argument. This corresponds to the</span>
<span class="sd">        :meth:`~astropy.modeling.FittableModel.fit_deriv` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define a sinusoidal model function as a custom 1D model::</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import custom_model</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; def sine_model(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return amplitude * np.sin(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; def sine_deriv(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return 2 * np.pi * amplitude * np.cos(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; SineModel = custom_model(sine_model, fit_deriv=sine_deriv)</span>

<span class="sd">    Create an instance of the custom model and evaluate it::</span>

<span class="sd">        &gt;&gt;&gt; model = SineModel()</span>
<span class="sd">        &gt;&gt;&gt; model(0.25)</span>
<span class="sd">        1.0</span>

<span class="sd">    This model instance can now be used like a usual astropy model.</span>

<span class="sd">    The next example demonstrates a 2D Moffat function model, and also</span>
<span class="sd">    demonstrates the support for docstrings (this example could also include</span>
<span class="sd">    a derivative, but it has been omitted for simplicity)::</span>

<span class="sd">        &gt;&gt;&gt; @custom_model</span>
<span class="sd">        ... def Moffat2D(x, y, amplitude=1.0, x_0=0.0, y_0=0.0, gamma=1.0,</span>
<span class="sd">        ...            alpha=1.0):</span>
<span class="sd">        ...     \&quot;\&quot;\&quot;Two dimensional Moffat function.\&quot;\&quot;\&quot;</span>
<span class="sd">        ...     rr_gg = ((x - x_0) ** 2 + (y - y_0) ** 2) / gamma ** 2</span>
<span class="sd">        ...     return amplitude * (1 + rr_gg) ** (-alpha)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; print(Moffat2D.__doc__)</span>
<span class="sd">        Two dimensional Moffat function.</span>
<span class="sd">        &gt;&gt;&gt; model = Moffat2D()</span>
<span class="sd">        &gt;&gt;&gt; model(1, 1)  # doctest: +FLOAT_CMP</span>
<span class="sd">        0.3333333333333333</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Function received unexpected arguments (</span><span class="si">{}</span><span class="s2">) these &quot;</span>
            <span class="s2">&quot;are ignored but will raise an Exception in the &quot;</span>
            <span class="s2">&quot;future.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)),</span>
            <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">_custom_model_wrapper</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_custom_model_wrapper</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> takes at most one positional argument (the callable/&quot;</span>
            <span class="s2">&quot;function to be turned into a model.  When used as a decorator &quot;</span>
            <span class="s2">&quot;it should be passed keyword arguments only (if &quot;</span>
            <span class="s2">&quot;any).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="vm">__name__</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_custom_model_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal implementation `custom_model`.</span>

<span class="sd">    When `custom_model` is called as a function its arguments are passed to</span>
<span class="sd">    this function, and the result of this function is returned.</span>

<span class="sd">    When `custom_model` is used as a decorator a partial evaluation of this</span>
<span class="sd">    function is returned by `custom_model`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s2">&quot;func is not callable; it must be a function or other callable &quot;</span>
            <span class="s2">&quot;object&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s2">&quot;fit_deriv not callable; it must be a function or other &quot;</span>
            <span class="s2">&quot;callable object&quot;</span><span class="p">)</span>

    <span class="n">model_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">get_inputs_and_params</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fit_deriv</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s2">&quot;derivative function should accept &quot;</span>
                                   <span class="s2">&quot;same number of parameters as func.&quot;</span><span class="p">)</span>

    <span class="c1"># TODO: Maybe have a clever scheme for default output name?</span>
    <span class="k">if</span> <span class="n">inputs</span><span class="p">:</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                <span class="n">default</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">))</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span>

    <span class="n">members</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([</span>
        <span class="p">(</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;n_inputs&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)),</span>
        <span class="c1">#tuple(x.name for x in inputs)),</span>
        <span class="p">(</span><span class="s1">&#39;n_outputs&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;evaluate&#39;</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">func</span><span class="p">))])</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">members</span><span class="p">[</span><span class="s1">&#39;fit_deriv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">)</span>

    <span class="n">members</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="p">(</span><span class="n">FittableModel</span><span class="p">,),</span> <span class="n">members</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">render_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates a model on an input array. Evaluation is limited to</span>
<span class="sd">    a bounding box if the `Model.bounding_box` attribute is set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `Model`</span>
<span class="sd">        Model to be evaluated.</span>
<span class="sd">    arr : `numpy.ndarray`, optional</span>
<span class="sd">        Array on which the model is evaluated.</span>
<span class="sd">    coords : array_like, optional</span>
<span class="sd">        Coordinate arrays mapping to ``arr``, such that</span>
<span class="sd">        ``arr[coords] == arr``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        The model evaluated on the input ``arr`` or a new array from</span>
<span class="sd">        ``coords``.</span>
<span class="sd">        If ``arr`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">        limited to the `Model.bounding_box` limits. If</span>
<span class="sd">        `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be passed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    :ref:`bounding-boxes`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bbox</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bounding_box</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set,&#39;</span>
                         <span class="s1">&#39;coords or arr must be input.&#39;</span><span class="p">)</span>

    <span class="c1"># for consistent indexing</span>
    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Check dimensions match model</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;number of array dimensions inconsistent with &#39;</span>
                             <span class="s1">&#39;number of model inputs.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check dimensions match arr and model</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;coordinate length inconsistent with the number &#39;</span>
                             <span class="s1">&#39;of model inputs.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;coordinate shape inconsistent with the &#39;</span>
                                 <span class="s1">&#39;array shape.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assures position is at center pixel, important when using add_array</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

        <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The `bounding_box` is larger than the input&#39;</span>
                                 <span class="s1">&#39; arr in one or more dimensions. Set &#39;</span>
                                 <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im_shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

        <span class="n">arr</span> <span class="o">+=</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">arr</span>


<span class="k">def</span> <span class="nf">_prepare_inputs_single_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">broadcasts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Ensure that array scalars are always upgrade to 1-D arrays for the</span>
        <span class="c1"># sake of consistency with how parameters work.  They will be cast back</span>
        <span class="c1"># to scalars at the end</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_shape</span><span class="p">:</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_broadcast</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">:</span>
                    <span class="n">broadcast</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
            <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Model input argument </span><span class="si">{0!r}</span><span class="s2"> of shape </span><span class="si">{1!r}</span><span class="s2"> cannot be &quot;</span>
                    <span class="s2">&quot;broadcast with parameter </span><span class="si">{2!r}</span><span class="s2"> of shape &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{3!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">,</span>
                                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">broadcast</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">,</span> <span class="n">broadcast</span><span class="p">)</span>

        <span class="n">broadcasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">&gt;</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">broadcasts</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;For models with n_outputs &gt; n_inputs, the combination of &quot;</span>
                <span class="s2">&quot;all inputs and parameters must broadcast to the same shape, &quot;</span>
                <span class="s2">&quot;which will be used as the shape of all outputs.  In this &quot;</span>
                <span class="s2">&quot;case some of the inputs had different shapes, so it is &quot;</span>
                <span class="s2">&quot;ambiguous how to format outputs for this model.  Try using &quot;</span>
                <span class="s2">&quot;inputs that are all the same size and shape.&quot;</span><span class="p">)</span>
        <span class="c1"># Extend the broadcasts list to include shapes for all outputs</span>
        <span class="n">extra_outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcasts</span><span class="p">:</span>
            <span class="c1"># If there were no inputs then the broadcasts list is empty</span>
            <span class="c1"># just add a None since there is no broadcasting of outputs and</span>
            <span class="c1"># inputs necessary (see _prepare_outputs_single_model)</span>
            <span class="n">broadcasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">broadcasts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">broadcasts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">extra_outputs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="n">broadcasts</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_prepare_outputs_single_model</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">):</span>
    <span class="n">broadcasts</span> <span class="o">=</span> <span class="n">format_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">broadcasts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcast_shape</span><span class="p">:</span>
                <span class="c1"># Shape is (), i.e. a scalar should be returned</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepare_inputs_model_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis_input</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">reshaped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pivots</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">model_set_axis_param</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>  <span class="c1"># needed to reshape param</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">max_param_shape</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis_input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># Use the shape of the input *excluding* the model axis</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">model_set_axis_input</span><span class="p">]</span> <span class="o">+</span>
                           <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis_input</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span>
                                <span class="n">remove_axes_from_shape</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">model_set_axis_param</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Model input argument </span><span class="si">{0!r}</span><span class="s2"> of shape </span><span class="si">{1!r}</span><span class="s2"> cannot be &quot;</span>
                    <span class="s2">&quot;broadcast with parameter </span><span class="si">{2!r}</span><span class="s2"> of shape &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{3!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">,</span>
                                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">remove_axes_from_shape</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                           <span class="n">model_set_axis_param</span><span class="p">)))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">):</span>
                <span class="n">max_param_shape</span> <span class="o">=</span> <span class="n">remove_axes_from_shape</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                         <span class="n">model_set_axis_param</span><span class="p">)</span>

        <span class="c1"># We&#39;ve now determined that, excluding the model_set_axis, the</span>
        <span class="c1"># input can broadcast with all the parameters</span>
        <span class="n">input_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_set_axis_input</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">input_ndim</span><span class="p">:</span>
                <span class="c1"># Just needs to prepend new axes to the input</span>
                <span class="n">n_new_axes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">model_set_axis_param</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">input_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span>
                             <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span><span class="p">:])</span>
            <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">input_ndim</span><span class="p">:</span>
                <span class="n">n_new_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_axes</span> <span class="o">+</span>
                             <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">new_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">model_set_axis_input</span><span class="p">,</span>
                                        <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pivots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span>
        <span class="n">reshaped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_input</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">&lt;</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">:</span>
        <span class="n">pivots</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">model_set_axis_input</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reshaped</span><span class="p">,</span> <span class="p">(</span><span class="n">pivots</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_prepare_outputs_model_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">):</span>
    <span class="n">pivots</span> <span class="o">=</span> <span class="n">format_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># If model_set_axis = False was passed then use</span>
    <span class="c1"># model._model_set_axis to format the output.</span>
    <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">pivots</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pivot</span> <span class="o">&lt;</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="n">model_set_axis</span><span class="p">:</span>
            <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span>
                                       <span class="n">model_set_axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">argnames</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                           <span class="n">validate_broadcasting</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform basic validation of model inputs--that they are mutually</span>
<span class="sd">    broadcastable and that they have the minimum dimensions for the given</span>
<span class="sd">    model_set_axis.</span>

<span class="sd">    If validation succeeds, returns the total shape that will result from</span>
<span class="sd">    broadcasting the input arrays with each other.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check_model_set_axis</span> <span class="o">=</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>

    <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">_input</span><span class="p">)</span>
        <span class="c1"># Ensure that the input&#39;s model_set_axis matches the model&#39;s</span>
        <span class="c1"># n_models</span>
        <span class="k">if</span> <span class="n">input_shape</span> <span class="ow">and</span> <span class="n">check_model_set_axis</span><span class="p">:</span>
            <span class="c1"># Note: Scalar inputs *only* get a pass on this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;For model_set_axis=</span><span class="si">{0}</span><span class="s2">, all inputs must be at &quot;</span>
                    <span class="s2">&quot;least </span><span class="si">{1}</span><span class="s2">-dimensional.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">input_shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">argname</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># the case of model.inputs = ()</span>
                    <span class="n">argname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Input argument </span><span class="si">{0!r}</span><span class="s2"> does not have the correct &quot;</span>
                    <span class="s2">&quot;dimensions in model_set_axis=</span><span class="si">{1}</span><span class="s2"> for a model set with &quot;</span>
                    <span class="s2">&quot;n_models=</span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">argname</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                                           <span class="n">n_models</span><span class="p">))</span>
        <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>

    <span class="n">input_shape</span> <span class="o">=</span> <span class="n">check_consistent_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">input_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;All inputs must have identical shapes or must be scalars.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">input_shape</span>


<span class="k">def</span> <span class="nf">remove_axes_from_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a shape tuple as the first input, construct a new one by  removing</span>
<span class="sd">    that particular axis from the shape and all preceeding axes. Negative axis</span>
<span class="sd">    numbers are permittted, where the axis is relative to the last axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shape</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis</span>
        <span class="k">return</span> <span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">shape</span>


<span class="k">def</span> <span class="nf">check_consistent_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given shapes as arguments, check to see if all are the same (excluding</span>
<span class="sd">    scalars, i.e., shape==(); if all the same, return the common shape; if</span>
<span class="sd">    not, return None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># remove scalars from the list</span>
    <span class="n">ashapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span> <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="p">()]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ashapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ashapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ashapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rshape</span> <span class="o">=</span> <span class="n">ashapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">ashapes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">rshape</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">rshape</span>


<span class="k">def</span> <span class="nf">get_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the ``bounding_box`` of a model.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``bounding_box`` is not defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">bbox</span>


<span class="k">def</span> <span class="nf">generic_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The base ``Model. __call__`` method.&quot;&quot;&quot;</span>
    <span class="n">inputs</span><span class="p">,</span> <span class="n">format_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inputs</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
        <span class="c1"># CompoundModels do not normally hold parameters at that level</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">(</span><span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">with_bbox</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">get_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">with_bbox</span> <span class="ow">and</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_validate_input_shapes</span><span class="p">(</span>
            <span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">)</span>
        <span class="n">vinputs</span><span class="p">,</span> <span class="n">valid_ind</span><span class="p">,</span> <span class="n">allout</span> <span class="o">=</span> <span class="n">prepare_bounding_box_inputs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">bbox</span><span class="p">)</span>
        <span class="n">valid_result_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allout</span><span class="p">:</span>
            <span class="n">valid_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">vinputs</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span>
            <span class="n">valid_result_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">valid_result</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">valid_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">valid_result</span><span class="p">]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">prepare_bounding_box_outputs</span><span class="p">(</span><span class="n">valid_result</span><span class="p">,</span> <span class="n">valid_ind</span><span class="p">,</span>
                                                   <span class="n">input_shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">fill_value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">valid_result_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">valid_result_unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_outputs</span><span class="p">(</span><span class="n">format_info</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">outputs</span>


<span class="k">def</span> <span class="nf">prepare_bounding_box_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign a value of ``np.nan`` to indices outside the bounding box.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">allout</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># bounding_box is in python order -</span>
        <span class="c1"># convert it to the order of the inputs</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>
    <span class="c1"># indices where input is outside the bbox</span>
    <span class="c1"># have a value of 1 in ``nan_ind``</span>
    <span class="n">nan_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">inp</span> <span class="o">&lt;</span> <span class="n">bbox</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">inp</span> <span class="o">&gt;</span> <span class="n">bbox</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">nan_ind</span><span class="p">[</span><span class="n">outside</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nan_ind</span> <span class="o">|=</span> <span class="n">outside</span>
            <span class="k">if</span> <span class="n">nan_ind</span><span class="p">:</span>
                <span class="n">allout</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># get an array with indices of valid inputs</span>
    <span class="n">valid_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">nan_ind</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">allout</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># inputs holds only inputs within the bbox</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allout</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">input_shape</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inp</span><span class="p">)[</span><span class="n">valid_ind</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">valid_ind</span><span class="p">,</span> <span class="n">allout</span>


<span class="k">def</span> <span class="nf">prepare_bounding_box_outputs</span><span class="p">(</span><span class="n">valid_result</span><span class="p">,</span> <span class="n">valid_ind</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Populate the output arrays with ``fill_value``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">fill_value</span>
              <span class="k">for</span> <span class="n">vr</span> <span class="ow">in</span> <span class="n">valid_result</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valid_result</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">valid_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_strip_ones</span><span class="p">(</span><span class="n">intup</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">intup</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">hide_inverse</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a convenience function intended to disable automatic generation</span>
<span class="sd">    of the inverse in compound models by disabling one of the constituent</span>
<span class="sd">    model&#39;s inverse. This is to handle cases where user provided inverse</span>
<span class="sd">    functions are not compatible within an expression.</span>

<span class="sd">    Example:</span>
<span class="sd">        compound_model.inverse = hide_inverse(m1) + m2 + m3</span>

<span class="sd">    This will insure that the defined inverse itself won&#39;t attempt to</span>
<span class="sd">    build its own inverse, which would otherwise fail in this example</span>
<span class="sd">    (e.g., m = m1 + m2 + m3 happens to raises an exception for this</span>
<span class="sd">    reason.)</span>

<span class="sd">    Note that this permanently disables it. To prevent that either copy</span>
<span class="sd">    the model or restore the inverse later.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">del</span> <span class="n">model</span><span class="o">.</span><span class="n">inverse</span>
    <span class="k">return</span> <span class="n">model</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, The Gammapy developers
      <span class="lastupdated">
        Last updated on 06 Nov 2020.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>