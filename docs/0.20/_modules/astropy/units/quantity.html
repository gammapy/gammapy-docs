
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.units.quantity &#8212; gammapy v0.20</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gammapy.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <link rel="shortcut icon" href="../../../_static/gammapy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/gammapy_logo_nav.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../getting-started/index.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../userguide/index.html">
  User guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../tutorials/index.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../development/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../changelog/index.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-primary btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        0.20  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables _modules/astropy/units/quantity and {'json_url': 'https://docs.gammapy.org/stable/switcher.json', 'version_match': '0.20'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "_modules/astropy/units/quantity.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://docs.gammapy.org/stable/switcher.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "_modules/astropy/units/quantity.html";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 0.20 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "0.20") {
                node.classList.add("active");
                let btn = document.getElementById("version_switcher_button");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/gammapy/gammapy" rel="noopener" target="_blank" title="Github"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">Github</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/gammapyST" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://gammapy.slack.com/" rel="noopener" target="_blank" title="Slack"><span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for astropy.units.quantity</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the `Quantity` object, which represents a number with some</span>
<span class="sd">associated units. `Quantity` objects support operations like ordinary numbers,</span>
<span class="sd">but will deal with unit conversions internally.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># Standard library</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># AstroPy</span>
<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Unit</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">,</span> <span class="n">get_current_unit_registry</span><span class="p">,</span>
                   <span class="n">UnitBase</span><span class="p">,</span> <span class="n">UnitsError</span><span class="p">,</span> <span class="n">UnitConversionError</span><span class="p">,</span> <span class="n">UnitTypeError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.structured</span> <span class="kn">import</span> <span class="n">StructuredUnit</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">is_effectively_unity</span>
<span class="kn">from</span> <span class="nn">.format.latex</span> <span class="kn">import</span> <span class="n">Latex</span>
<span class="kn">from</span> <span class="nn">astropy.utils.compat</span> <span class="kn">import</span> <span class="n">NUMPY_LT_1_22</span>
<span class="kn">from</span> <span class="nn">astropy.utils.compat.misc</span> <span class="kn">import</span> <span class="n">override__dir__</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyDeprecationWarning</span><span class="p">,</span> <span class="n">AstropyWarning</span>
<span class="kn">from</span> <span class="nn">astropy.utils.introspection</span> <span class="kn">import</span> <span class="n">minversion</span>
<span class="kn">from</span> <span class="nn">astropy.utils.misc</span> <span class="kn">import</span> <span class="n">isiterable</span>
<span class="kn">from</span> <span class="nn">astropy.utils.data_info</span> <span class="kn">import</span> <span class="n">ParentDtypeInfo</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">config</span> <span class="k">as</span> <span class="n">_config</span>
<span class="kn">from</span> <span class="nn">.quantity_helper</span> <span class="kn">import</span> <span class="p">(</span><span class="n">converters_and_unit</span><span class="p">,</span> <span class="n">can_have_arbitrary_unit</span><span class="p">,</span>
                              <span class="n">check_output</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.quantity_helper.function_helpers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">SUBCLASS_SAFE_FUNCTIONS</span><span class="p">,</span> <span class="n">FUNCTION_HELPERS</span><span class="p">,</span> <span class="n">DISPATCHED_FUNCTIONS</span><span class="p">,</span>
    <span class="n">UNSUPPORTED_FUNCTIONS</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Quantity&quot;</span><span class="p">,</span> <span class="s2">&quot;SpecificTypeQuantity&quot;</span><span class="p">,</span>
           <span class="s2">&quot;QuantityInfoBase&quot;</span><span class="p">,</span> <span class="s2">&quot;QuantityInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;allclose&quot;</span><span class="p">,</span> <span class="s2">&quot;isclose&quot;</span><span class="p">]</span>


<span class="c1"># We don&#39;t want to run doctests in the docstrings we inherit from Numpy</span>
<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Quantity.*&#39;</span><span class="p">]</span>

<span class="n">_UNIT_NOT_INITIALISED</span> <span class="o">=</span> <span class="s2">&quot;(Unit not initialised)&quot;</span>
<span class="n">_UFUNCS_FILTER_WARNINGS</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">Conf</span><span class="p">(</span><span class="n">_config</span><span class="o">.</span><span class="n">ConfigNamespace</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configuration parameters for Quantity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">latex_array_threshold</span> <span class="o">=</span> <span class="n">_config</span><span class="o">.</span><span class="n">ConfigItem</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span>
        <span class="s1">&#39;The maximum size an array Quantity can be before its LaTeX &#39;</span>
        <span class="s1">&#39;representation for IPython gets &quot;summarized&quot; (meaning only the first &#39;</span>
        <span class="s1">&#39;and last few elements are shown with &quot;...&quot; between). Setting this to a &#39;</span>
        <span class="s1">&#39;negative number means that the value will instead be whatever numpy &#39;</span>
        <span class="s1">&#39;gets from get_printoptions.&#39;</span><span class="p">)</span>


<span class="n">conf</span> <span class="o">=</span> <span class="n">Conf</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">QuantityIterator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flat iterator object to iterate over Quantities</span>

<span class="sd">    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity</span>
<span class="sd">    ``q``.  It allows iterating over the array as if it were a 1-D array,</span>
<span class="sd">    either in a for-loop or by calling its `next` method.</span>

<span class="sd">    Iteration is done in C-contiguous style, with the last index varying the</span>
<span class="sd">    fastest. The iterator can also be indexed using basic slicing or</span>
<span class="sd">    advanced indexing.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Quantity.flatten : Returns a flattened copy of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It</span>
<span class="sd">    is not exported by the `~astropy.units` module.  Instead of</span>
<span class="sd">    instantiating a `QuantityIterator` directly, use `Quantity.flat`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
        <span class="c1"># For single elements, ndarray.flat.__getitem__ returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next value, or raise StopIteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">)</span>
        <span class="c1"># ndarray.flat._dataiter returns scalars, so need a view as a Quantity.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">)</span>

    <span class="c1">#### properties and methods to match `numpy.ndarray.flatiter` ####</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A reference to the array that is iterated over.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An N-dimensional tuple of current coordinates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="o">.</span><span class="n">coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Current flat index into the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="o">.</span><span class="n">index</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the iterator as a 1-D array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">QuantityInfoBase</span><span class="p">(</span><span class="n">ParentDtypeInfo</span><span class="p">):</span>
    <span class="c1"># This is on a base class rather than QuantityInfo directly, so that</span>
    <span class="c1"># it can be used for EarthLocationInfo yet make clear that that class</span>
    <span class="c1"># should not be considered a typical Quantity subclass by Table.</span>
    <span class="n">attrs_from_parent</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">}</span>  <span class="c1"># dtype and unit taken from parent</span>
    <span class="n">_supports_indexing</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_format</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">possible_string_format_functions</span><span class="p">(</span><span class="n">format_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through possible string-derived format functions.</span>

<span class="sd">        A string can either be a format specifier for the format built-in,</span>
<span class="sd">        a new-style format string, or an old-style format string.</span>

<span class="sd">        This method is overridden in order to suppress printing the unit</span>
<span class="sd">        in each row since it is already at the top in the column header.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">format</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">format_</span><span class="p">)</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">format_</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">format_</span> <span class="o">%</span> <span class="n">val</span><span class="o">.</span><span class="n">value</span>


<span class="k">class</span> <span class="nc">QuantityInfo</span><span class="p">(</span><span class="n">QuantityInfoBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for meta information like name, description, format.  This is</span>
<span class="sd">    required when the object is used as a mixin column within a table, but can</span>
<span class="sd">    be used as a general way to store meta information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_represent_as_dict_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span>
    <span class="n">_construct_from_dict_args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
    <span class="n">_represent_as_dict_primary_data</span> <span class="o">=</span> <span class="s1">&#39;value&#39;</span>

    <span class="k">def</span> <span class="nf">new_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Quantity instance which is consistent with the</span>
<span class="sd">        input ``cols`` and has ``length`` rows.</span>

<span class="sd">        This is intended for creating an empty column object whose elements can</span>
<span class="sd">        be set in-place for table operations like join or vstack.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cols : list</span>
<span class="sd">            List of input columns</span>
<span class="sd">        length : int</span>
<span class="sd">            Length of the output column object</span>
<span class="sd">        metadata_conflicts : str (&#39;warn&#39;|&#39;error&#39;|&#39;silent&#39;)</span>
<span class="sd">            How to handle metadata conflicts</span>
<span class="sd">        name : str</span>
<span class="sd">            Output column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col : `~astropy.units.Quantity` (or subclass)</span>
<span class="sd">            Empty instance of this class consistent with ``cols``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get merged info attributes like shape, dtype, format, description, etc.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cols_attributes</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                                           <span class="p">(</span><span class="s1">&#39;meta&#39;</span><span class="p">,</span> <span class="s1">&#39;format&#39;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">))</span>

        <span class="c1"># Make an empty quantity using the unit of the last one.</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span><span class="p">,)</span> <span class="o">+</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">)</span>
        <span class="c1"># Use zeros so we do not get problems for Quantity subclasses such</span>
        <span class="c1"># as Longitude and Latitude, which cannot take arbitrary values.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Get arguments needed to reconstruct class</span>
        <span class="nb">map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">(</span><span class="n">data</span> <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span> <span class="k">else</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span>
               <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_represent_as_dict_attrs</span><span class="p">}</span>
        <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_dict</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

        <span class="c1"># Set remaining info attributes</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">get_sortable_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of arrays which can be lexically sorted to represent</span>
<span class="sd">        the order of the parent column.</span>

<span class="sd">        For Quantity this is just the quantity itself.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrays : list of ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A `~astropy.units.Quantity` represents a number with some associated unit.</span>

<span class="sd">    See also: https://docs.astropy.org/en/stable/units/quantity.html</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str</span>
<span class="sd">        The numerical value of this quantity in the units given by unit.  If a</span>
<span class="sd">        `Quantity` or sequence of them (or any other valid object with a</span>
<span class="sd">        ``unit`` attribute), creates a new `Quantity` object, converting to</span>
<span class="sd">        `unit` units as needed.  If a string, it is converted to a number or</span>
<span class="sd">        `Quantity`, depending on whether a unit is present.</span>

<span class="sd">    unit : unit-like</span>
<span class="sd">        An object that represents the unit associated with the input value.</span>
<span class="sd">        Must be an `~astropy.units.UnitBase` object or a string parseable by</span>
<span class="sd">        the :mod:`~astropy.units` package.</span>

<span class="sd">    dtype : ~numpy.dtype, optional</span>
<span class="sd">        The dtype of the resulting Numpy array or scalar that will</span>
<span class="sd">        hold the value.  If not provided, it is determined from the input,</span>
<span class="sd">        except that any integer and (non-Quantity) object inputs are converted</span>
<span class="sd">        to float by default.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), then the value is copied.  Otherwise, a copy will</span>
<span class="sd">        only be made if ``__array__`` returns a copy, if value is a nested</span>
<span class="sd">        sequence, or if a copy is needed to satisfy an explicitly given</span>
<span class="sd">        ``dtype``.  (The `False` option is intended mostly for internal use,</span>
<span class="sd">        to speed up initialization where a copy is known to have been made.</span>
<span class="sd">        Use with care.)</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional</span>
<span class="sd">        Specify the order of the array.  As in `~numpy.array`.  This parameter</span>
<span class="sd">        is ignored if the input is a `Quantity` and ``copy=False``.</span>

<span class="sd">    subok : bool, optional</span>
<span class="sd">        If `False` (default), the returned array will be forced to be a</span>
<span class="sd">        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,</span>
<span class="sd">        or a subclass appropriate for the unit will be used (such as</span>
<span class="sd">        `~astropy.units.Dex` for ``u.dex(u.AA)``).</span>

<span class="sd">    ndmin : int, optional</span>
<span class="sd">        Specifies the minimum number of dimensions that the resulting array</span>
<span class="sd">        should have.  Ones will be pre-pended to the shape as needed to meet</span>
<span class="sd">        this requirement.  This parameter is ignored if the input is a</span>
<span class="sd">        `Quantity` and ``copy=False``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the value provided is not a Python numeric type.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the unit provided is not either a :class:`~astropy.units.Unit`</span>
<span class="sd">        object or a parseable string unit.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Quantities can also be created by multiplying a number or array with a</span>
<span class="sd">    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/</span>

<span class="sd">    Unless the ``dtype`` argument is explicitly specified, integer</span>
<span class="sd">    or (non-Quantity) object inputs are converted to `float` by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Need to set a class-level default for _equivalencies, or</span>
    <span class="c1"># Constants can not initialize properly</span>
    <span class="n">_equivalencies</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Default unit for initialization; can be overridden by subclasses,</span>
    <span class="c1"># possibly to `None` to indicate there is no default unit.</span>
    <span class="n">_default_unit</span> <span class="o">=</span> <span class="n">dimensionless_unscaled</span>

    <span class="c1"># Ensures views have an undefined unit.</span>
    <span class="n">_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="k">def</span> <span class="nf">__class_getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">unit_shape_dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quantity Type Hints.</span>

<span class="sd">        Unit-aware type hints are ``Annotated`` objects that encode the class,</span>
<span class="sd">        the unit, and possibly shape and dtype information, depending on the</span>
<span class="sd">        python and :mod:`numpy` versions.</span>

<span class="sd">        Schematically, ``Annotated[cls[shape, dtype], unit]``</span>

<span class="sd">        As a classmethod, the type is the class, ie ``Quantity``</span>
<span class="sd">        produces an ``Annotated[Quantity, ...]`` while a subclass</span>
<span class="sd">        like :class:`~astropy.coordinates.Angle` returns</span>
<span class="sd">        ``Annotated[Angle, ...]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple</span>
<span class="sd">            Unit specification, can be the physical type (ie str or class).</span>
<span class="sd">            If tuple, then the first element is the unit specification</span>
<span class="sd">            and all other elements are for `numpy.ndarray` type annotations.</span>
<span class="sd">            Whether they are included depends on the python and :mod:`numpy`</span>
<span class="sd">            versions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `typing.Annotated`, `typing_extensions.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`</span>
<span class="sd">            Return type in this preference order:</span>
<span class="sd">            * if python v3.9+ : `typing.Annotated`</span>
<span class="sd">            * if :mod:`typing_extensions` is installed : `typing_extensions.Annotated`</span>
<span class="sd">            * `astropy.units.Unit` or `astropy.units.PhysicalType`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the unit/physical_type annotation is not Unit-like or</span>
<span class="sd">            PhysicalType-like.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a unit-aware Quantity type annotation</span>

<span class="sd">            &gt;&gt;&gt; Quantity[Unit(&quot;s&quot;)]</span>
<span class="sd">            Annotated[Quantity, Unit(&quot;s&quot;)]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `~astropy.units.quantity_input`</span>
<span class="sd">            Use annotations for unit checks on function arguments and results.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        With Python 3.9+ or :mod:`typing_extensions`, |Quantity| types are also</span>
<span class="sd">        static-type compatible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># LOCAL</span>
        <span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">HAS_ANNOTATED</span><span class="p">,</span> <span class="n">Annotated</span>

        <span class="c1"># process whether [unit] or [unit, shape, ptype]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit_shape_dtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># unit, shape, dtype</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">unit_shape_dtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shape_dtype</span> <span class="o">=</span> <span class="n">unit_shape_dtype</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># just unit</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">unit_shape_dtype</span>
            <span class="n">shape_dtype</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Allowed unit/physical types. Errors if neither.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">astropy.units.physical</span> <span class="kn">import</span> <span class="n">get_physical_type</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">get_physical_type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>  <span class="c1"># KeyError for Enum</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unit annotation is not a Unit or PhysicalType&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="c1"># Allow to sort of work for python 3.8- / no typing_extensions</span>
        <span class="c1"># instead of bailing out, return the unit for `quantity_input`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_ANNOTATED</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Quantity annotations are valid static type annotations only&quot;</span>
                          <span class="s2">&quot; if Python is v3.9+ or `typing_extensions` is installed.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">unit</span>

        <span class="c1"># Quantity does not (yet) properly extend the NumPy generics types,</span>
        <span class="c1"># introduced in numpy v1.22+, instead just including the unit info as</span>
        <span class="c1"># metadata using Annotated.</span>
        <span class="c1"># TODO: ensure we do interact with NDArray.__class_getitem__.</span>
        <span class="k">return</span> <span class="n">Annotated</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">((</span><span class="bp">cls</span><span class="p">,</span> <span class="n">unit</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convert unit first, to avoid multiple string-&gt;unit conversions</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># optimize speed for Quantity with no dtype given, copy=False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                <span class="c1"># the above already makes a copy (with float dtype)</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">cls</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subok</span> <span class="ow">and</span>
                                               <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;iu&#39;</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                            <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>

        <span class="c1"># Maybe str, or list/tuple of Quantity? If so, this may set value_unit.</span>
        <span class="c1"># To ensure array remains fast, we short-circuit it.</span>
        <span class="n">value_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># The first part of the regex string matches any integer/float;</span>
                <span class="c1"># the second parts adds possible trailing .+-, which will break</span>
                <span class="c1"># the float function below and ensure things like 1.2.3deg</span>
                <span class="c1"># will not work.</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*[+-]?&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;((\d+\.?\d*)|(\.\d+)|([nN][aA][nN])|&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;([eE][+-]?\d+)?&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;[.+-]?&#39;</span><span class="p">)</span>

                <span class="n">v</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">unit_string</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>

                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot parse &quot;</span><span class="si">{}</span><span class="s1">&quot; as a </span><span class="si">{}</span><span class="s1">. It does not &#39;</span>
                                    <span class="s1">&#39;start with a number.&#39;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

                <span class="n">unit_string</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">unit_string</span><span class="p">:</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit_string</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="n">value_unit</span>  <span class="c1"># signal no conversion needed below.</span>

            <span class="k">elif</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Iterables like lists and tuples.</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">):</span>
                    <span class="c1"># If a list/tuple containing only quantities, convert all</span>
                    <span class="c1"># to the same unit.</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># signal below that conversion has been done</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span>
                      <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">)):</span>
                    <span class="c1"># Special case for list/tuple of values and a structured unit:</span>
                    <span class="c1"># ``np.array(value, dtype=None)`` would treat tuples as lower</span>
                    <span class="c1"># levels of the array, rather than as elements of a structured</span>
                    <span class="c1"># array, so we use the structure of the unit to help infer the</span>
                    <span class="c1"># structured dtype of the value.</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">_recursively_get_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the value has a `unit` attribute and if not None</span>
            <span class="c1"># (for Columns with uninitialized unit), treat it like a quantity.</span>
            <span class="n">value_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Default to dimensionless for no (initialized) unit attribute.</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_unit</span>
                <span class="n">value_unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># signal below that no conversion is needed</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">value_unit</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The unit attribute </span><span class="si">{!r}</span><span class="s2"> of the input could &quot;</span>
                                    <span class="s2">&quot;not be parsed as an astropy Unit, raising &quot;</span>
                                    <span class="s2">&quot;the following exception:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">value_unit</span>
                <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value_unit</span><span class="p">:</span>
                    <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># copy will be made in conversion at end</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                         <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>

        <span class="c1"># check that array contains numbers or long int objects</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;OSU&#39;</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span> <span class="ow">and</span>
                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The value must be a valid Python or &quot;</span>
                            <span class="s2">&quot;Numpy numeric type.&quot;</span><span class="p">)</span>

        <span class="c1"># by default, cast any integer, boolean, etc., to float</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;iuO&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># if we allow subclasses, allow a class from the unit.</span>
        <span class="k">if</span> <span class="n">subok</span><span class="p">:</span>
            <span class="n">qcls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;_quantity_class&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">qcls</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">qcls</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">value</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">value_unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="n">value_unit</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># here we had non-Quantity input that had a &quot;unit&quot; attribute</span>
            <span class="c1"># with a unit different from the desired one.  So, convert.</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># Check whether super().__array_finalize should be called</span>
        <span class="c1"># (sadly, ndarray.__array_finalize__ is None; we cannot be sure</span>
        <span class="c1"># what is above us).</span>
        <span class="n">super_array_finalize</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_finalize__</span>
        <span class="k">if</span> <span class="n">super_array_finalize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">super_array_finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="c1"># If we&#39;re a new object or viewing an ndarray, nothing has to be done.</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># If our unit is not set and obj has a valid one, use it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_unit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># Copy info if the original had `info` defined.  Because of the way the</span>
        <span class="c1"># DataInfo works, `&#39;info&#39; in obj.__dict__` is False until the</span>
        <span class="c1"># `info` attribute is accessed or set.</span>
        <span class="k">if</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">info</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Methods like .squeeze() created a new `ndarray` and then call</span>
            <span class="c1"># __array_wrap__ to turn the array into self&#39;s subclass.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;__array_wrap__ should not be used &#39;</span>
                                  <span class="s1">&#39;with a context any more since all use &#39;</span>
                                  <span class="s1">&#39;should go through array_function. &#39;</span>
                                  <span class="s1">&#39;Please raise an issue on &#39;</span>
                                  <span class="s1">&#39;https://github.com/astropy/astropy&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap numpy ufuncs, taking care of units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            ufunc to wrap.</span>
<span class="sd">        method : str</span>
<span class="sd">            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.</span>
<span class="sd">        inputs : tuple</span>
<span class="sd">            Input arrays.</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            As passed on, with ``out`` containing possible quantity output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : `~astropy.units.Quantity`</span>
<span class="sd">            Results of the ufunc, with the unit set properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine required conversion functions -- to bring the unit of the</span>
        <span class="c1"># input to that expected (e.g., radian for np.sin), or to get</span>
        <span class="c1"># consistent units between two inputs (e.g., in np.add) --</span>
        <span class="c1"># and the unit of the result (or tuple of units for nout &gt; 1).</span>
        <span class="n">converters</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">converters_and_unit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Avoid loop back by turning any Quantity output into array views.</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If pre-allocated output is used, check it is suitable.</span>
            <span class="c1"># This also returns array view, to ensure we don&#39;t loop back.</span>
            <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out_array</span> <span class="o">=</span> <span class="n">check_output</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
            <span class="c1"># Ensure output argument remains a tuple.</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_array</span><span class="p">,)</span> <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out_array</span>

        <span class="c1"># Same for inputs, but here also convert if necessary.</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">input_</span><span class="p">,</span> <span class="n">converter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">converters</span><span class="p">):</span>
            <span class="n">input_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">input_</span><span class="p">)</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converter</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span> <span class="k">if</span> <span class="n">converter</span> <span class="k">else</span> <span class="n">input_</span><span class="p">)</span>

        <span class="c1"># Call our superclass&#39;s __array_ufunc__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># If unit is None, a plain array is expected (e.g., comparisons), which</span>
        <span class="c1"># means we&#39;re done.</span>
        <span class="c1"># We&#39;re also done if the result was None (for method &#39;at&#39;) or</span>
        <span class="c1"># NotImplemented, which can happen if other inputs/outputs override</span>
        <span class="c1"># __array_ufunc__; hopefully, they can then deal with us.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_result_as_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn result into a quantity with the given unit.</span>

<span class="sd">        If no output is given, it will take a view of the array as a quantity,</span>
<span class="sd">        and set the unit.  If output is given, those should be quantity views</span>
<span class="sd">        of the result arrays, and the function will just set the unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : ndarray or tuple thereof</span>
<span class="sd">            Array(s) which need to be turned into quantity.</span>
<span class="sd">        unit : `~astropy.units.Unit`</span>
<span class="sd">            Unit for the quantities to be returned (or `None` if the result</span>
<span class="sd">            should not be a quantity).  Should be tuple if result is a tuple.</span>
<span class="sd">        out : `~astropy.units.Quantity` or None</span>
<span class="sd">            Possible output quantity. Should be `None` or a tuple if result</span>
<span class="sd">            is a tuple.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">           With units set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">unit_</span><span class="p">,</span> <span class="n">out_</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">unit_</span><span class="p">,</span> <span class="n">out_</span><span class="p">)</span> <span class="ow">in</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># View the result array as a Quantity with the proper unit.</span>
            <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

        <span class="c1"># For given output, just set the unit. We know the unit is not None and</span>
        <span class="c1"># the output is of the correct Quantity subclass, as it was passed</span>
        <span class="c1"># through check_output.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__quantity_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overridden by subclasses to change what kind of view is</span>
<span class="sd">        created based on the output unit of an operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : UnitBase</span>
<span class="sd">            The unit for which the appropriate class should be returned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple :</span>
<span class="sd">            - `~astropy.units.Quantity` subclass</span>
<span class="sd">            - bool: True if subclasses of the given class are ok</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Quantity</span><span class="p">,</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Quantity view of some array-like input, and set the unit</span>

<span class="sd">        By default, return a view of ``obj`` of the same class as ``self`` and</span>
<span class="sd">        with the same unit.  Subclasses can override the type of class for a</span>
<span class="sd">        given unit using ``__quantity_subclass__``, and can ensure properties</span>
<span class="sd">        other than the unit are copied using ``__array_finalize__``.</span>

<span class="sd">        If the given unit defines a ``_quantity_class`` of which ``self``</span>
<span class="sd">        is not an instance, a view using this class is taken.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : ndarray or scalar, optional</span>
<span class="sd">            The array to create a view of.  If obj is a numpy or python scalar,</span>
<span class="sd">            it will be converted to an array scalar.  By default, ``self``</span>
<span class="sd">            is converted.</span>

<span class="sd">        unit : unit-like, optional</span>
<span class="sd">            The unit of the resulting object.  It is used to select a</span>
<span class="sd">            subclass, and explicitly assigned to the view if given.</span>
<span class="sd">            If not given, the subclass and unit will be that of ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        view : `~astropy.units.Quantity` subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the unit and quantity subclass that we need for the view.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">Quantity</span><span class="p">:</span>
            <span class="c1"># The second part is because we should not presume what other</span>
            <span class="c1"># classes want to do for the same unit.  E.g., Constant will</span>
            <span class="c1"># always want to fall back to Quantity, and relies on going</span>
            <span class="c1"># through `__quantity_subclass__`.</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="n">Quantity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;_quantity_class&#39;</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity_subclass</span><span class="p">):</span>
                <span class="n">quantity_subclass</span><span class="p">,</span> <span class="n">subok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__quantity_subclass__</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subok</span><span class="p">:</span>
                    <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>

        <span class="c1"># We only want to propagate information from ``self`` to our new view,</span>
        <span class="c1"># so obj should be a regular array.  By using ``np.array``, we also</span>
        <span class="c1"># convert python and numpy scalars, which cannot be viewed as arrays</span>
        <span class="c1"># and thus not as Quantity either, to zero-dimensional arrays.</span>
        <span class="c1"># (These are turned back into scalar in `.value`)</span>
        <span class="c1"># Note that for an ndarray input, the np.array call takes only double</span>
        <span class="c1"># ``obj.__class is np.ndarray``. So, not worth special-casing.</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Take the view, set the unit, and update possible other properties</span>
        <span class="c1"># such as ``info``, ``wrap_angle`` in `Longitude`, etc.</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">quantity_subclass</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span> <span class="nf">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the unit.</span>

<span class="sd">        This is used anywhere the unit is set or modified, i.e., in the</span>
<span class="sd">        initilizer, in ``__imul__`` and ``__itruediv__`` for in-place</span>
<span class="sd">        multiplication and division by another unit, as well as in</span>
<span class="sd">        ``__array_finalize__`` for wrapping up views.  For Quantity, it just</span>
<span class="sd">        sets the unit, but subclasses can override it to check that, e.g.,</span>
<span class="sd">        a unit is consistent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">UnitBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">)):</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">StructuredUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Trying to go through a string ensures that, e.g., Magnitudes with</span>
                <span class="c1"># dimensionless physical unit become Quantity with units of mag.</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="n">parse_strict</span><span class="o">=</span><span class="s1">&#39;silent&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="n">UnitTypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> instances require normal units, not </span><span class="si">{}</span><span class="s2"> instances.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">unit</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">unit</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="c1"># If we don&#39;t define this, ``copy.deepcopy(quantity)`` will</span>
        <span class="c1"># return a bare Numpy array.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># patch to pickle Quantity objects (ndarray subclasses), see</span>
        <span class="c1"># http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html</span>

        <span class="n">object_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">())</span>
        <span class="n">object_state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_state</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">object_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># patch to unpickle Quantity objects (ndarray subclasses), see</span>
        <span class="c1"># http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html</span>

        <span class="n">nd_state</span><span class="p">,</span> <span class="n">own_state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">nd_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">own_state</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">QuantityInfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Helper method for to and to_value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">equivalencies</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">equivalencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalencies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">):</span>
            <span class="c1"># Standard path, let unit to do work.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
                                <span class="n">equivalencies</span><span class="o">=</span><span class="n">equivalencies</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The .to() method of a simple unit cannot convert a structured</span>
            <span class="c1"># dtype, so we work around it, by recursing.</span>
            <span class="c1"># TODO: deprecate this?</span>
            <span class="c1"># Convert simple to Structured on initialization?</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new `~astropy.units.Quantity` object with the specified unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : unit-like</span>
<span class="sd">            An object that represents the unit to convert to. Must be</span>
<span class="sd">            an `~astropy.units.UnitBase` object or a string parseable</span>
<span class="sd">            by the `~astropy.units` package.</span>

<span class="sd">        equivalencies : list of tuple</span>
<span class="sd">            A list of equivalence pairs to try if the units are not</span>
<span class="sd">            directly convertible.  See :ref:`astropy:unit_equivalencies`.</span>
<span class="sd">            If not provided or ``[]``, class default equivalencies will be used</span>
<span class="sd">            (none for `~astropy.units.Quantity`, but may be set for subclasses)</span>
<span class="sd">            If `None`, no equivalencies will be applied at all, not even any</span>
<span class="sd">            set globally or within a context.</span>

<span class="sd">        copy : bool, optional</span>
<span class="sd">            If `True` (default), then the value is copied.  Otherwise, a copy</span>
<span class="sd">            will only be made if necessary.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        to_value : get the numerical value in a given unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t use `to_value` below since we always want to make a copy</span>
        <span class="c1"># and don&#39;t want to slow down this method (esp. the scalar case).</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c1"># Avoid using to_value to ensure that we make a copy. We also</span>
            <span class="c1"># don&#39;t want to slow down this method (esp. the scalar case).</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># to_value only copies if necessary</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The numerical value, possibly in a different unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : unit-like, optional</span>
<span class="sd">            The unit in which the value should be given. If not given or `None`,</span>
<span class="sd">            use the current unit.</span>

<span class="sd">        equivalencies : list of tuple, optional</span>
<span class="sd">            A list of equivalence pairs to try if the units are not directly</span>
<span class="sd">            convertible (see :ref:`astropy:unit_equivalencies`). If not provided</span>
<span class="sd">            or ``[]``, class default equivalencies will be used (none for</span>
<span class="sd">            `~astropy.units.Quantity`, but may be set for subclasses).</span>
<span class="sd">            If `None`, no equivalencies will be applied at all, not even any</span>
<span class="sd">            set globally or within a context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : ndarray or scalar</span>
<span class="sd">            The value in the units specified. For arrays, this will be a view</span>
<span class="sd">            of the data if no unit conversion was necessary.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        to : Get a new instance in a different unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unit</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="c1"># For non-structured, we attempt a short-cut, where we just get</span>
            <span class="c1"># the scale.  If that is 1, we do not have to do anything.</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="c1"># We want a view if the unit does not change.  One could check</span>
            <span class="c1"># with &quot;==&quot;, but that calculates the scale that we need anyway.</span>
            <span class="c1"># TODO: would be better for `unit.to` to have an in-place flag.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Short-cut failed; try default (maybe equivalencies help).</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_effectively_unity</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
                    <span class="c1"># not in-place!</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For structured arrays, we go the default route.</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>

        <span class="c1"># Index with empty tuple to decay array scalars in to numpy scalars.</span>
        <span class="k">return</span> <span class="n">value</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="n">value</span><span class="p">[()]</span>

    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">to_value</span><span class="p">,</span>
                     <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The numerical value of this instance.</span>

<span class="s2">    See also</span>
<span class="s2">    --------</span>
<span class="s2">    to_value : Get the numerical value in a given unit.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `~astropy.units.UnitBase` object representing the unit of this</span>
<span class="sd">        quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of equivalencies that will be applied by default during</span>
<span class="sd">        unit conversions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalencies</span>

    <span class="k">def</span> <span class="nf">_recursively_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply function recursively to every field.</span>

<span class="sd">        Returns a copy with the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">result_unit</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">result_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">value</span>
            <span class="n">result_unit</span> <span class="o">+=</span> <span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">unit</span><span class="p">,)</span>

        <span class="n">result</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">result_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">si</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current `Quantity` instance with SI units. The</span>
<span class="sd">        value of the resulting object will be scaled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursively_apply</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;si&#39;</span><span class="p">))</span>
        <span class="n">si_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">si</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">si_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                              <span class="n">si_unit</span> <span class="o">/</span> <span class="n">si_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current `Quantity` instance with CGS units. The</span>
<span class="sd">        value of the resulting object will be scaled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursively_apply</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;cgs&#39;</span><span class="p">))</span>
        <span class="n">cgs_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">cgs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">cgs_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                              <span class="n">cgs_unit</span> <span class="o">/</span> <span class="n">cgs_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the `value` of this quantity is a scalar, or False if it</span>
<span class="sd">        is an array-like object.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is subtly different from `numpy.isscalar` in that</span>
<span class="sd">            `numpy.isscalar` returns False for a zero-dimensional array</span>
<span class="sd">            (e.g. ``np.array(1)``), while this is True for quantities,</span>
<span class="sd">            since quantities cannot represent true numpy scalars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># This flag controls whether convenience conversion members, such</span>
    <span class="c1"># as `q.m` equivalent to `q.to_value(u.m)` are available.  This is</span>
    <span class="c1"># not turned on on Quantity itself, but is on some subclasses of</span>
    <span class="c1"># Quantity, such as `astropy.coordinates.Angle`.</span>
    <span class="n">_include_easy_conversion_members</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@override__dir__</span>
    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantities are able to directly convert to other units that</span>
<span class="sd">        have the same physical type.  This function is implemented in</span>
<span class="sd">        order to make autocompletion still work correctly in IPython.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_easy_conversion_members</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">extra_members</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">.</span><span class="n">_normalize_equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">equivalent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_get_units_with_same_physical_type</span><span class="p">(</span>
                <span class="n">equivalencies</span><span class="p">):</span>
            <span class="n">extra_members</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">equivalent</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">extra_members</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantities are able to directly convert to other units that</span>
<span class="sd">        have the same physical type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_easy_conversion_members</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object has no &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39; member&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_virtual_unit_attribute</span><span class="p">():</span>
            <span class="n">registry</span> <span class="o">=</span> <span class="n">get_current_unit_registry</span><span class="p">()</span><span class="o">.</span><span class="n">registry</span>
            <span class="n">to_unit</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">to_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                    <span class="n">to_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalencies</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">get_virtual_unit_attribute</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> instance has no attribute &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="c1"># Equality needs to be handled explicitly as ndarray.__eq__ gives</span>
    <span class="c1"># DeprecationWarnings on any error, which is distracting, and does not</span>
    <span class="c1"># deal well with structured arrays (nor does the ufunc).</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other_value</span><span class="p">)</span>

    <span class="c1"># Unit conversion operator (&lt;&lt;).</span>
    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parse_strict</span><span class="o">=</span><span class="s1">&#39;silent&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitTypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parse_strict</span><span class="o">=</span><span class="s1">&#39;silent&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitTypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_to</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Maybe via equivalencies?  Now we do make a temporary copy.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitConversionError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">Unit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__rlshift__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># Give warning for other &gt;&gt; self, since probably other &lt;&lt; self was meant.</span>
    <span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&gt;&gt; is not implemented. Did you mean to convert &quot;</span>
                      <span class="s2">&quot;something to this quantity as a unit using &#39;&lt;&lt;&#39;?&quot;</span><span class="p">,</span>
                      <span class="n">AstropyWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Also define __rshift__ and __irshift__ so we override default ndarray</span>
    <span class="c1"># behaviour, but instead of emitting a warning here, let it be done by</span>
    <span class="c1"># other (which likely is a unit if this was a mistake).</span>
    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__irshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Arithmetic operations</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Multiplication between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># let other try to deal with it</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;In-place multiplication between `Quantity` objects and others.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__imul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Right Multiplication between `Quantity` objects and other</span>
<span class="sd">        objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># let other try to deal with it</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inplace division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__itruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Right Division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__itruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">):</span>
            <span class="c1"># Avoid getting object arrays by raising the value to a Fraction.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">**</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># other overrides of special functions</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;</span><span class="si">{cls}</span><span class="s2">&#39; object with a scalar value is not iterable&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="c1"># Otherwise return a generator</span>
        <span class="k">def</span> <span class="nf">quantity_iter</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">quantity_iter</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)[</span><span class="n">key</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># We want zero-dimensional Quantity objects to behave like scalars,</span>
            <span class="c1"># so they should raise a TypeError rather than an IndexError.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{cls}</span><span class="s2">&#39; object with a scalar value does not support &quot;</span>
                    <span class="s2">&quot;indexing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="c1"># For single elements, ndarray.__getitem__ returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Indexing will cause a different unit, so by doing this in</span>
            <span class="c1"># two steps we effectively try with the right unit.</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

        <span class="c1"># update indices in info if the info property has been accessed</span>
        <span class="c1"># (in which case &#39;info&#39; in self.__dict__ is True; this is guaranteed</span>
        <span class="c1"># to be the case if we&#39;re part of a table).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span> <span class="ow">and</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">adjust_indices</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="c1"># __contains__ is OK</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quantities should always be treated as non-False; there is too much</span>
<span class="sd">        potential for ambiguity otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The truth value of a Quantity is ambiguous. &#39;</span>
                      <span class="s1">&#39;In the future this will raise a ValueError.&#39;</span><span class="p">,</span>
                      <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{cls}</span><span class="s2">&#39; object with a scalar value has no &quot;</span>
                            <span class="s2">&quot;len()&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># Numerical types</span>
    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">UnitsError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only dimensionless scalar quantities can be &#39;</span>
                            <span class="s1">&#39;converted to Python scalars&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">UnitsError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only dimensionless scalar quantities can be &#39;</span>
                            <span class="s1">&#39;converted to Python scalars&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for indices, we do not want to mess around with scaling at all,</span>
        <span class="c1"># so unlike for float, int, we insist here on unscaled dimensionless</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_unity</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__index__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only integer dimensionless scalar quantities &#39;</span>
                            <span class="s1">&#39;can be converted to a Python index&#39;</span><span class="p">)</span>

    <span class="c1"># TODO: we may want to add a hook for dimensionless quantities?</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_unitstr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="n">_UNIT_NOT_INITIALISED</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unitstr</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">unitstr</span>

        <span class="k">return</span> <span class="n">unitstr</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subfmt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a string representation of the quantity and its unit.</span>

<span class="sd">        The behavior of this function can be altered via the</span>
<span class="sd">        `numpy.set_printoptions` function and its various keywords.  The</span>
<span class="sd">        exception to this is the ``threshold`` keyword, which is controlled via</span>
<span class="sd">        the ``[units.quantity]`` configuration item ``latex_array_threshold``.</span>
<span class="sd">        This is treated separately because the numpy default of 1000 is too big</span>
<span class="sd">        for most browsers to handle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : unit-like, optional</span>
<span class="sd">            Specifies the unit.  If not provided,</span>
<span class="sd">            the unit used to initialize the quantity will be used.</span>

<span class="sd">        precision : number, optional</span>
<span class="sd">            The level of decimal precision. If `None`, or not provided,</span>
<span class="sd">            it will be determined from NumPy print options.</span>

<span class="sd">        format : str, optional</span>
<span class="sd">            The format of the result. If not provided, an unadorned</span>
<span class="sd">            string is returned. Supported values are:</span>

<span class="sd">            - &#39;latex&#39;: Return a LaTeX-formatted string</span>

<span class="sd">        subfmt : str, optional</span>
<span class="sd">            Subformat of the result. For the moment,</span>
<span class="sd">            only used for format=&quot;latex&quot;. Supported values are:</span>

<span class="sd">            - &#39;inline&#39;: Use ``$ ... $`` as delimiters.</span>

<span class="sd">            - &#39;display&#39;: Use ``$\\displaystyle ... $`` as delimiters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A string with the contents of this Quantity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span>
                <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">subfmt</span><span class="o">=</span><span class="n">subfmt</span><span class="p">)</span>

        <span class="n">formats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;latex&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="kc">None</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span><span class="p">),</span>
                <span class="s2">&quot;inline&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span><span class="p">),</span>
                <span class="s2">&quot;display&quot;</span><span class="p">:</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\displaystyle &quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$&quot;</span><span class="p">),</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown format &#39;</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Use default formatting settings</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># np.array2string properly formats arrays as well as scalars</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">floatmode</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span>

        <span class="c1"># else, for the moment we assume format=&quot;latex&quot;</span>

        <span class="c1"># need to do try/finally because &quot;threshold&quot; cannot be overridden</span>
        <span class="c1"># with array2string</span>

        <span class="c1"># Set the precision if set, otherwise use numpy default</span>
        <span class="n">pops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
        <span class="n">format_spec</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">precision</span> <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pops</span><span class="p">[</span><span class="s1">&#39;precision&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">g&quot;</span>

        <span class="k">def</span> <span class="nf">float_formatter</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Latex</span><span class="o">.</span><span class="n">format_exponential_notation</span><span class="p">(</span><span class="n">value</span><span class="p">,</span>
                                                     <span class="n">format_spec</span><span class="o">=</span><span class="n">format_spec</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">complex_formatter</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{}{}</span><span class="s1">i)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">Latex</span><span class="o">.</span><span class="n">format_exponential_notation</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
                                                  <span class="n">format_spec</span><span class="o">=</span><span class="n">format_spec</span><span class="p">),</span>
                <span class="n">Latex</span><span class="o">.</span><span class="n">format_exponential_notation</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span>
                                                  <span class="n">format_spec</span><span class="o">=</span><span class="s1">&#39;+&#39;</span> <span class="o">+</span> <span class="n">format_spec</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;float_kind&#39;</span><span class="p">:</span> <span class="n">float_formatter</span><span class="p">,</span>
                         <span class="s1">&#39;complex_kind&#39;</span><span class="p">:</span> <span class="n">complex_formatter</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">latex_array_threshold</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">conf</span><span class="o">.</span><span class="n">latex_array_threshold</span><span class="p">)</span>

            <span class="c1"># the view is needed for the scalar case - value might be float</span>
            <span class="n">latex_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
                <span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,~&#39;</span><span class="p">)</span>

            <span class="n">latex_value</span> <span class="o">=</span> <span class="n">latex_value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\dots&#39;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">pops</span><span class="p">)</span>

        <span class="c1"># Format unit</span>
        <span class="c1"># [1:-1] strips the &#39;$&#39; on either side needed for math mode</span>
        <span class="n">latex_unit</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_repr_latex_</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># note this is unicode</span>
                      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                      <span class="k">else</span> <span class="n">_UNIT_NOT_INITIALISED</span><span class="p">)</span>

        <span class="n">delimiter_left</span><span class="p">,</span> <span class="n">delimiter_right</span> <span class="o">=</span> <span class="n">formats</span><span class="p">[</span><span class="nb">format</span><span class="p">][</span><span class="n">subfmt</span><span class="p">]</span>

        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">{left}{0}</span><span class="s1"> \; </span><span class="si">{1}{right}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">latex_value</span><span class="p">,</span> <span class="n">latex_unit</span><span class="p">,</span>
                                                 <span class="n">left</span><span class="o">=</span><span class="n">delimiter_left</span><span class="p">,</span>
                                                 <span class="n">right</span><span class="o">=</span><span class="n">delimiter_right</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefixstr</span> <span class="o">=</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
        <span class="n">arrstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">,</span>
                                 <span class="n">prefix</span><span class="o">=</span><span class="n">prefixstr</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefixstr</span><span class="si">}{</span><span class="n">arrstr</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">_repr_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a latex representation of the quantity and its unit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lstr</span>
<span class="sd">            A LaTeX string with the contents of this Quantity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: This should change to display format in a future release</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">subfmt</span><span class="o">=</span><span class="s1">&#39;inline&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Format quantities using the new-style python formatting codes</span>
<span class="sd">        as specifiers for the number.</span>

<span class="sd">        If the format specifier correctly applies itself to the value,</span>
<span class="sd">        then it is used to format only the value. If it cannot be</span>
<span class="sd">        applied to the value, then it is applied to the whole string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">)</span>
            <span class="n">full_format_spec</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
            <span class="n">full_format_spec</span> <span class="o">=</span> <span class="n">format_spec</span>

        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                      <span class="n">full_format_spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a new `Quantity` with the units</span>
<span class="sd">        decomposed. Decomposed units have only irreducible units in</span>
<span class="sd">        them (see `astropy.units.UnitBase.decompose`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bases : sequence of `~astropy.units.UnitBase`, optional</span>
<span class="sd">            The bases to decompose into.  When not provided,</span>
<span class="sd">            decomposes down to any irreducible units.  When provided,</span>
<span class="sd">            the decomposed result will only contain the given units.</span>
<span class="sd">            This will raises a `~astropy.units.UnitsError` if it&#39;s not possible</span>
<span class="sd">            to do so.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newq : `~astropy.units.Quantity`</span>
<span class="sd">            A new object equal to this quantity with units decomposed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decompose</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">bases</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allowscaledunits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a new `Quantity` with the units decomposed. Decomposed</span>
<span class="sd">        units have only irreducible units in them (see</span>
<span class="sd">        `astropy.units.UnitBase.decompose`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        allowscaledunits : bool</span>
<span class="sd">            If True, the resulting `Quantity` may have a scale factor</span>
<span class="sd">            associated with it.  If False, any scaling in the unit will</span>
<span class="sd">            be subsumed into the value of the resulting `Quantity`</span>

<span class="sd">        bases : sequence of UnitBase, optional</span>
<span class="sd">            The bases to decompose into.  When not provided,</span>
<span class="sd">            decomposes down to any irreducible units.  When provided,</span>
<span class="sd">            the decomposed result will only contain the given units.</span>
<span class="sd">            This will raises a `~astropy.units.UnitsError` if it&#39;s not possible</span>
<span class="sd">            to do so.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newq : `~astropy.units.Quantity`</span>
<span class="sd">            A new object equal to this quantity with units decomposed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">bases</span><span class="o">=</span><span class="n">bases</span><span class="p">)</span>

        <span class="c1"># Be careful here because self.value usually is a view of self;</span>
        <span class="c1"># be sure that the original value is not being modified.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allowscaledunits</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_unit</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">):</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">new_unit</span><span class="o">.</span><span class="n">scale</span>
            <span class="n">new_unit</span> <span class="o">=</span> <span class="n">new_unit</span> <span class="o">/</span> <span class="n">new_unit</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">new_unit</span><span class="p">)</span>

    <span class="c1"># These functions need to be overridden to take into account the units</span>
    <span class="c1"># Array conversion</span>
    <span class="c1"># https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion</span>

    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy an element of an array to a scalar Quantity and return it.</span>

<span class="sd">        Like :meth:`~numpy.ndarray.item` except that it always</span>
<span class="sd">        returns a `Quantity`, not a Python scalar.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot make a list of Quantities.  Get &quot;</span>
                                  <span class="s2">&quot;list of values with q.value.tolist()&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_own_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">check_precision</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># We&#39;re not a Quantity.</span>
            <span class="c1"># First remove two special cases (with a fast test):</span>
            <span class="c1"># 1) Maybe masked printing? MaskedArray with quantities does not</span>
            <span class="c1"># work very well, but no reason to break even repr and str.</span>
            <span class="c1"># 2) np.ma.masked? useful if we&#39;re a MaskedQuantity.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_print_option</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="c1"># Now, let&#39;s try a more general conversion.</span>
            <span class="c1"># Plain arrays will be converted to dimensionless in the process,</span>
            <span class="c1"># but anything with a unit attribute will use that.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">as_quantity</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="n">as_quantity</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
                <span class="c1"># last chance: if this was not something with a unit</span>
                <span class="c1"># and is all 0, inf, or nan, we treat it as arbitrary unit.</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">can_have_arbitrary_unit</span><span class="p">(</span><span class="n">as_quantity</span><span class="o">.</span><span class="n">value</span><span class="p">)):</span>
                    <span class="n">_value</span> <span class="o">=</span> <span class="n">as_quantity</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">and</span> <span class="n">check_precision</span><span class="p">:</span>
            <span class="c1"># If, e.g., we are casting float to int, we want to fail if</span>
            <span class="c1"># precision is lost, but let things pass if it works.</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">_value</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">self_dtype_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">self_dtype_array</span> <span class="o">==</span> <span class="n">_value</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">_value</span><span class="p">))):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot convert value type to array type &quot;</span>
                                    <span class="s2">&quot;without precision loss&quot;</span><span class="p">)</span>

        <span class="c1"># Setting names to ensure things like equality work (note that</span>
        <span class="c1"># above will have failed already if units did not match).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">_value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">return</span> <span class="n">_value</span>

    <span class="k">def</span> <span class="nf">itemset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;itemset must have at least one argument&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">itemset</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),)))</span>

    <span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot write Quantities to string.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.tostring(...).&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tobytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot write Quantities to string.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.tobytes(...).&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot write Quantities to file.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.tofile(...)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot dump Quantities to file.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.dump()&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot dump Quantities to string.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.dumps()&quot;</span><span class="p">)</span>

    <span class="c1"># astype, byteswap, copy, view, getfield, setflags OK as is</span>

    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="c1"># Shape manipulation: resize cannot be done (does not own data), but</span>
    <span class="c1"># shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only</span>
    <span class="c1"># the flat iterator needs to be overwritten, otherwise single items are</span>
    <span class="c1"># returned as numbers.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A 1-D iterator over the Quantity array.</span>

<span class="sd">        This returns a ``QuantityIterator`` instance, which behaves the same</span>
<span class="sd">        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,</span>
<span class="sd">        and is similar to, but not a subclass of, Python&#39;s built-in iterator</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuantityIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@flat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Item selection and manipulation</span>
    <span class="c1"># repeat, sort, compress, diagonal OK</span>
    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="c1"># For single elements, ndarray.take returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot choose based on quantity.  Choose &quot;</span>
                                  <span class="s2">&quot;using array with q.value.choose(...)&quot;</span><span class="p">)</span>

    <span class="c1"># ensure we do not return indices as quantities</span>
    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">check_precision</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                               <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># avoid numpy 1.6 problem</span>

    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap numpy functions, taking care of units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            Numpy function to wrap</span>
<span class="sd">        types : iterable of classes</span>
<span class="sd">            Classes that provide an ``__array_function__`` override. Can</span>
<span class="sd">            in principle be used to interact with other classes. Below,</span>
<span class="sd">            mostly passed on to `~numpy.ndarray`, which can only interact</span>
<span class="sd">            with subclasses.</span>
<span class="sd">        args : tuple</span>
<span class="sd">            Positional arguments provided in the function call.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Keyword arguments provided in the function call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `~astropy.units.Quantity`, `~numpy.ndarray`</span>
<span class="sd">            As appropriate for the function.  If the function is not</span>
<span class="sd">            supported, `NotImplemented` is returned, which will lead to</span>
<span class="sd">            a `TypeError` unless another argument overrode the function.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~astropy.units.UnitsError</span>
<span class="sd">            If operands have incompatible units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A function should be in one of the following sets or dicts:</span>
        <span class="c1"># 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation</span>
        <span class="c1">#    supports Quantity; we pass on to ndarray.__array_function__.</span>
        <span class="c1"># 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable</span>
        <span class="c1">#    after converting quantities to arrays with suitable units,</span>
        <span class="c1">#    and possibly setting units on the result.</span>
        <span class="c1"># 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but</span>
        <span class="c1">#    requires a Quantity-specific implementation.</span>
        <span class="c1"># 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.</span>
        <span class="c1"># For now, since we may not yet have complete coverage, if a</span>
        <span class="c1"># function is in none of the above, we simply call the numpy</span>
        <span class="c1"># implementation.</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">SUBCLASS_SAFE_FUNCTIONS</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_function__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">FUNCTION_HELPERS</span><span class="p">:</span>
            <span class="n">function_helper</span> <span class="o">=</span> <span class="n">FUNCTION_HELPERS</span><span class="p">[</span><span class="n">function</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">function_helper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_not_implemented_or_raise</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_function__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Fall through to return section</span>

        <span class="k">elif</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">DISPATCHED_FUNCTIONS</span><span class="p">:</span>
            <span class="n">dispatched_function</span> <span class="o">=</span> <span class="n">DISPATCHED_FUNCTIONS</span><span class="p">[</span><span class="n">function</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">dispatched_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_not_implemented_or_raise</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>

            <span class="c1"># Fall through to return section</span>

        <span class="k">elif</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">UNSUPPORTED_FUNCTIONS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;function &#39;</span><span class="si">{}</span><span class="s2">&#39; is not known to astropy&#39;s Quantity. &quot;</span>
                          <span class="s2">&quot;Will run it anyway, hoping it will treat ndarray &quot;</span>
                          <span class="s2">&quot;subclasses correctly. Please raise an issue at &quot;</span>
                          <span class="s2">&quot;https://github.com/astropy/astropy/issues. &quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span> <span class="n">AstropyWarning</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_function__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If unit is None, a plain array is expected (e.g., boolean), which</span>
        <span class="c1"># means we&#39;re done.</span>
        <span class="c1"># We&#39;re also done if the result was NotImplemented, which can happen</span>
        <span class="c1"># if other inputs/outputs override __array_function__;</span>
        <span class="c1"># hopefully, they can then deal with us.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_not_implemented_or_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="c1"># Our function helper or dispatcher found that the function does not</span>
        <span class="c1"># work with Quantity.  In principle, there may be another class that</span>
        <span class="c1"># knows what to do with us, for which we should return NotImplemented.</span>
        <span class="c1"># But if there is ndarray (or a non-Quantity subclass of it) around,</span>
        <span class="c1"># it quite likely coerces, so we should just break.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;the Quantity implementation cannot handle </span><span class="si">{}</span><span class="s2"> &quot;</span>
                            <span class="s2">&quot;with the given arguments.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function</span><span class="p">))</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Calculation -- override ndarray methods to take into account units.</span>
    <span class="c1"># We use the corresponding numpy functions to evaluate the results, since</span>
    <span class="c1"># the methods do not always allow calling with keyword arguments.</span>
    <span class="c1"># For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives</span>
    <span class="c1"># TypeError: &#39;a_max&#39; is an invalid keyword argument for this function.</span>
    <span class="k">def</span> <span class="nf">_wrap_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap a numpy function that processes self, returning a Quantity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            Numpy function to wrap.</span>
<span class="sd">        args : positional arguments</span>
<span class="sd">            Any positional arguments to the function beyond the first argument</span>
<span class="sd">            (which will be set to ``self``).</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            Keyword arguments to the function.</span>

<span class="sd">        If present, the following arguments are treated specially:</span>

<span class="sd">        unit : `~astropy.units.Unit`</span>
<span class="sd">            Unit of the output result.  If not given, the unit of ``self``.</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            A Quantity instance in which to store the output.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Output should always be assigned via a keyword argument, otherwise</span>
<span class="sd">        no proper account of the unit is taken.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            Result of the function call, with the unit set properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
        <span class="c1"># Ensure we don&#39;t loop back by turning any Quantity into array views.</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">arg</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
                                      <span class="k">else</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If pre-allocated output is used, check it is suitable.</span>
            <span class="c1"># This also returns array view, to ensure we don&#39;t loop back.</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_output</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
        <span class="c1"># Apply the function and turn it back into a Quantity.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                                   <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
                                   <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                                   <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">result_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">result_unit</span><span class="p">)</span>

    <span class="c1"># Calculation: override methods that do not make sense.</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate truth value of quantities. &quot;</span>
                        <span class="s2">&quot;Evaluate array with q.value.all(...)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate truth value of quantities. &quot;</span>
                        <span class="s2">&quot;Evaluate array with q.value.any(...)&quot;</span><span class="p">)</span>

    <span class="c1"># Calculation: numpy functions that can be overridden with methods.</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ediff1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">,</span> <span class="n">to_end</span><span class="p">,</span> <span class="n">to_begin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert values along the given axis before the given indices and return</span>
<span class="sd">        a new `~astropy.units.Quantity` object.</span>

<span class="sd">        This is a thin wrapper around the `numpy.insert` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : int, slice or sequence of int</span>
<span class="sd">            Object that defines the index or indices before which ``values`` is</span>
<span class="sd">            inserted.</span>
<span class="sd">        values : array-like</span>
<span class="sd">            Values to insert.  If the type of ``values`` is different</span>
<span class="sd">            from that of quantity, ``values`` is converted to the matching type.</span>
<span class="sd">            ``values`` should be shaped so that it can be broadcast appropriately</span>
<span class="sd">            The unit of ``values`` must be consistent with this quantity.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to insert ``values``.  If ``axis`` is None then</span>
<span class="sd">            the quantity array is flattened before insertion.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            A copy of quantity with ``values`` inserted.  Note that the</span>
<span class="sd">            insertion does not occur in-place: a new quantity array is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; q = [1, 2] * u.m</span>
<span class="sd">        &gt;&gt;&gt; q.insert(0, 50 * u.cm)</span>
<span class="sd">        &lt;Quantity [ 0.5,  1.,  2.] m&gt;</span>

<span class="sd">        &gt;&gt;&gt; q = [[1, 2], [3, 4]] * u.m</span>
<span class="sd">        &gt;&gt;&gt; q.insert(1, [10, 20] * u.m, axis=0)</span>
<span class="sd">        &lt;Quantity [[  1.,  2.],</span>
<span class="sd">                   [ 10., 20.],</span>
<span class="sd">                   [  3.,  4.]] m&gt;</span>

<span class="sd">        &gt;&gt;&gt; q.insert(1, 10 * u.m, axis=1)</span>
<span class="sd">        &lt;Quantity [[  1., 10.,  2.],</span>
<span class="sd">                   [  3., 10.,  4.]] m&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out_array</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SpecificTypeQuantity</span><span class="p">(</span><span class="n">Quantity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Superclass for Quantities of specific physical type.</span>

<span class="sd">    Subclasses of these work just like :class:`~astropy.units.Quantity`, except</span>
<span class="sd">    that they are for specific physical types (and may have methods that are</span>
<span class="sd">    only appropriate for that type).  Astropy examples are</span>
<span class="sd">    :class:`~astropy.coordinates.Angle` and</span>
<span class="sd">    :class:`~astropy.coordinates.Distance`</span>

<span class="sd">    At a minimum, subclasses should set ``_equivalent_unit`` to the unit</span>
<span class="sd">    associated with the physical type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The unit for the specific physical type.  Instances can only be created</span>
    <span class="c1"># with units that are equivalent to this.</span>
    <span class="n">_equivalent_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># The default unit used for views.  Even with `None`, views of arrays</span>
    <span class="c1"># without units are possible, but will have an uninitialized unit.</span>
    <span class="n">_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Default unit for initialization through the constructor.</span>
    <span class="n">_default_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ensure that we get precedence over our superclass.</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="n">Quantity</span><span class="o">.</span><span class="n">__array_priority__</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">def</span> <span class="nf">__quantity_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__quantity_subclass__</span><span class="p">(</span><span class="n">unit</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnitTypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> instances require units equivalent to &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="s2">&quot;, but no unit was given.&quot;</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
                 <span class="sa">f</span><span class="s2">&quot;, so cannot set it to &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a boolean array where two arrays are element-wise equal</span>
<span class="sd">    within a tolerance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        Input values or arrays to compare</span>
<span class="sd">    rtol : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        The relative tolerance for the comparison, which defaults to</span>
<span class="sd">        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,</span>
<span class="sd">        then it must be dimensionless.</span>
<span class="sd">    atol : number or `~astropy.units.Quantity`</span>
<span class="sd">        The absolute tolerance for the comparison.  The units (or lack</span>
<span class="sd">        thereof) of ``a``, ``b``, and ``atol`` must be consistent with</span>
<span class="sd">        each other.  If `None`, ``atol`` defaults to zero in the</span>
<span class="sd">        appropriate units.</span>
<span class="sd">    equal_nan : `bool`</span>
<span class="sd">        Whether to compare NaN’s as equal. If `True`, NaNs in ``a`` will</span>
<span class="sd">        be considered equal to NaN’s in ``b``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a :class:`~astropy.units.Quantity`-aware version of</span>
<span class="sd">    :func:`numpy.isclose`. However, this differs from the `numpy` function in</span>
<span class="sd">    that the default for the absolute tolerance here is zero instead of</span>
<span class="sd">    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default</span>
<span class="sd">    *absolute* tolerance given two inputs that may have differently scaled</span>
<span class="sd">    units.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    `~astropy.units.UnitsError`</span>
<span class="sd">        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,</span>
<span class="sd">        or if ``rtol`` is not dimensionless.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    allclose</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unquantified_args</span> <span class="o">=</span> <span class="n">_unquantify_allclose_arguments</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="o">*</span><span class="n">unquantified_args</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Whether two arrays are element-wise equal within a tolerance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        Input values or arrays to compare</span>
<span class="sd">    rtol : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        The relative tolerance for the comparison, which defaults to</span>
<span class="sd">        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,</span>
<span class="sd">        then it must be dimensionless.</span>
<span class="sd">    atol : number or `~astropy.units.Quantity`</span>
<span class="sd">        The absolute tolerance for the comparison.  The units (or lack</span>
<span class="sd">        thereof) of ``a``, ``b``, and ``atol`` must be consistent with</span>
<span class="sd">        each other.  If `None`, ``atol`` defaults to zero in the</span>
<span class="sd">        appropriate units.</span>
<span class="sd">    equal_nan : `bool`</span>
<span class="sd">        Whether to compare NaN’s as equal. If `True`, NaNs in ``a`` will</span>
<span class="sd">        be considered equal to NaN’s in ``b``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a :class:`~astropy.units.Quantity`-aware version of</span>
<span class="sd">    :func:`numpy.allclose`. However, this differs from the `numpy` function in</span>
<span class="sd">    that the default for the absolute tolerance here is zero instead of</span>
<span class="sd">    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default</span>
<span class="sd">    *absolute* tolerance given two inputs that may have differently scaled</span>
<span class="sd">    units.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    `~astropy.units.UnitsError`</span>
<span class="sd">        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,</span>
<span class="sd">        or if ``rtol`` is not dimensionless.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    isclose</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unquantified_args</span> <span class="o">=</span> <span class="n">_unquantify_allclose_arguments</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="o">*</span><span class="n">unquantified_args</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unquantify_allclose_arguments</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">desired</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">):</span>
    <span class="n">actual</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">desired</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">desired</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">desired</span> <span class="o">=</span> <span class="n">desired</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Units for &#39;desired&#39; (</span><span class="si">{</span><span class="n">desired</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) and &#39;actual&#39; &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) are not convertible&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">atol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># By default, we assume an absolute tolerance of zero in the</span>
        <span class="c1"># appropriate units.  The default value of None for atol is</span>
        <span class="c1"># needed because the units of atol must be consistent with the</span>
        <span class="c1"># units for a and b.</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Units for &#39;atol&#39; (</span><span class="si">{</span><span class="n">atol</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) and &#39;actual&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) are not convertible&quot;</span>
            <span class="p">)</span>

    <span class="n">rtol</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;&#39;rtol&#39; should be dimensionless&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">actual</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">desired</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">rtol</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">atol</span><span class="o">.</span><span class="n">value</span>
</pre></div>

              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, The Gammapy developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>