
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.table.table &#8212; gammapy v1.0rc2</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gammapy.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/gammapy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/gammapy_logo_nav.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../getting-started/index.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../user-guide/index.html">
  User guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../tutorials/index.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api-reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../development/index.html">
  Developer guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../release-notes/index.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-primary btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        1.0rc2  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables _modules/astropy/table/table and {'json_url': 'https://docs.gammapy.org/stable/switcher.json', 'version_match': '1.0rc2'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "_modules/astropy/table/table.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://docs.gammapy.org/stable/switcher.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "_modules/astropy/table/table.html";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 1.0rc2 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "1.0rc2") {
                node.classList.add("active");
                let btn = document.getElementById("version_switcher_button");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/gammapy/gammapy" rel="noopener" target="_blank" title="Github"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">Github</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/gammapyST" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://gammapy.slack.com/" rel="noopener" target="_blank" title="Slack"><span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for astropy.table.table</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="kn">from</span> <span class="nn">.index</span> <span class="kn">import</span> <span class="n">SlicedIndex</span><span class="p">,</span> <span class="n">TableIndices</span><span class="p">,</span> <span class="n">TableLoc</span><span class="p">,</span> <span class="n">TableILoc</span><span class="p">,</span> <span class="n">TableLocIndices</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">QuantityInfo</span>
<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="n">isiterable</span><span class="p">,</span> <span class="n">ShapedLikeNDArray</span>
<span class="kn">from</span> <span class="nn">astropy.utils.console</span> <span class="kn">import</span> <span class="n">color_print</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>
<span class="kn">from</span> <span class="nn">astropy.utils.masked</span> <span class="kn">import</span> <span class="n">Masked</span>
<span class="kn">from</span> <span class="nn">astropy.utils.metadata</span> <span class="kn">import</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">MetaAttribute</span>
<span class="kn">from</span> <span class="nn">astropy.utils.data_info</span> <span class="kn">import</span> <span class="n">BaseColumnInfo</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">,</span> <span class="n">DataInfo</span>
<span class="kn">from</span> <span class="nn">astropy.utils.decorators</span> <span class="kn">import</span> <span class="n">format_doc</span>
<span class="kn">from</span> <span class="nn">astropy.io.registry</span> <span class="kn">import</span> <span class="n">UnifiedReadWriteMethod</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">groups</span>
<span class="kn">from</span> <span class="nn">.pprint</span> <span class="kn">import</span> <span class="n">TableFormatter</span>
<span class="kn">from</span> <span class="nn">.column</span> <span class="kn">import</span> <span class="p">(</span><span class="n">BaseColumn</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">,</span> <span class="n">_auto_names</span><span class="p">,</span> <span class="n">FalseArray</span><span class="p">,</span>
                     <span class="n">col_copy</span><span class="p">,</span> <span class="n">_convert_sequence_data_to_array</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.row</span> <span class="kn">import</span> <span class="n">Row</span>
<span class="kn">from</span> <span class="nn">.info</span> <span class="kn">import</span> <span class="n">TableInfo</span>
<span class="kn">from</span> <span class="nn">.index</span> <span class="kn">import</span> <span class="n">Index</span><span class="p">,</span> <span class="n">_IndexModeContext</span><span class="p">,</span> <span class="n">get_index</span>
<span class="kn">from</span> <span class="nn">.connect</span> <span class="kn">import</span> <span class="n">TableRead</span><span class="p">,</span> <span class="n">TableWrite</span>
<span class="kn">from</span> <span class="nn">.ndarray_mixin</span> <span class="kn">import</span> <span class="n">NdarrayMixin</span>
<span class="kn">from</span> <span class="nn">.mixins.registry</span> <span class="kn">import</span> <span class="n">get_mixin_handler</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">conf</span>


<span class="n">_implementation_notes</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This string has informal notes concerning Table implementation for developers.</span>

<span class="s2">Things to remember:</span>

<span class="s2">- Table has customizable attributes ColumnClass, Column, MaskedColumn.</span>
<span class="s2">  Table.Column is normally just column.Column (same w/ MaskedColumn)</span>
<span class="s2">  but in theory they can be different.  Table.ColumnClass is the default</span>
<span class="s2">  class used to create new non-mixin columns, and this is a function of</span>
<span class="s2">  the Table.masked attribute.  Column creation / manipulation in a Table</span>
<span class="s2">  needs to respect these.</span>

<span class="s2">- Column objects that get inserted into the Table.columns attribute must</span>
<span class="s2">  have the info.parent_table attribute set correctly.  Beware just dropping</span>
<span class="s2">  an object into the columns dict since an existing column may</span>
<span class="s2">  be part of another Table and have parent_table set to point at that</span>
<span class="s2">  table.  Dropping that column into `columns` of this Table will cause</span>
<span class="s2">  a problem for the old one so the column object needs to be copied (but</span>
<span class="s2">  not necessarily the data).</span>

<span class="s2">  Currently replace_column is always making a copy of both object and</span>
<span class="s2">  data if parent_table is set.  This could be improved but requires a</span>
<span class="s2">  generic way to copy a mixin object but not the data.</span>

<span class="s2">- Be aware of column objects that have indices set.</span>

<span class="s2">- `cls.ColumnClass` is a property that effectively uses the `masked` attribute</span>
<span class="s2">  to choose either `cls.Column` or `cls.MaskedColumn`.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Table.read&#39;</span><span class="p">,</span> <span class="s1">&#39;Table.write&#39;</span><span class="p">,</span> <span class="s1">&#39;Table._read&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Table.convert_bytestring_to_unicode&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Table.convert_unicode_to_bytestring&#39;</span><span class="p">,</span>
                    <span class="p">]</span>

<span class="n">__doctest_requires__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;*pandas&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;pandas&gt;=1.1&#39;</span><span class="p">]}</span>

<span class="n">_pprint_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    </span><span class="si">{__doc__}</span><span class="s2"></span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    max_lines : int or None</span>
<span class="s2">        Maximum number of lines in table output.</span>

<span class="s2">    max_width : int or None</span>
<span class="s2">        Maximum character width of output.</span>

<span class="s2">    show_name : bool</span>
<span class="s2">        Include a header row for column names. Default is True.</span>

<span class="s2">    show_unit : bool</span>
<span class="s2">        Include a header row for unit.  Default is to show a row</span>
<span class="s2">        for units only if one or more columns has a defined value</span>
<span class="s2">        for the unit.</span>

<span class="s2">    show_dtype : bool</span>
<span class="s2">        Include a header row for column dtypes. Default is False.</span>

<span class="s2">    align : str or list or tuple or None</span>
<span class="s2">        Left/right alignment of columns. Default is right (None) for all</span>
<span class="s2">        columns. Other allowed values are &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;^&#39;, and &#39;0=&#39; for</span>
<span class="s2">        right, left, centered, and 0-padded, respectively. A list of</span>
<span class="s2">        strings can be provided for alignment of tables with multiple</span>
<span class="s2">        columns.</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="n">_pformat_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    </span><span class="si">{__doc__}</span><span class="s2"></span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    max_lines : int or None</span>
<span class="s2">        Maximum number of rows to output</span>

<span class="s2">    max_width : int or None</span>
<span class="s2">        Maximum character width of output</span>

<span class="s2">    show_name : bool</span>
<span class="s2">        Include a header row for column names. Default is True.</span>

<span class="s2">    show_unit : bool</span>
<span class="s2">        Include a header row for unit.  Default is to show a row</span>
<span class="s2">        for units only if one or more columns has a defined value</span>
<span class="s2">        for the unit.</span>

<span class="s2">    show_dtype : bool</span>
<span class="s2">        Include a header row for column dtypes. Default is True.</span>

<span class="s2">    html : bool</span>
<span class="s2">        Format the output as an HTML table. Default is False.</span>

<span class="s2">    tableid : str or None</span>
<span class="s2">        An ID tag for the table; only used if html is set.  Default is</span>
<span class="s2">        &quot;table</span><span class="si">{id}</span><span class="s2">&quot;, where id is the unique integer id of the table object,</span>
<span class="s2">        id(self)</span>

<span class="s2">    align : str or list or tuple or None</span>
<span class="s2">        Left/right alignment of columns. Default is right (None) for all</span>
<span class="s2">        columns. Other allowed values are &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;^&#39;, and &#39;0=&#39; for</span>
<span class="s2">        right, left, centered, and 0-padded, respectively. A list of</span>
<span class="s2">        strings can be provided for alignment of tables with multiple</span>
<span class="s2">        columns.</span>

<span class="s2">    tableclass : str or list of str or None</span>
<span class="s2">        CSS classes for the table; only used if html is set.  Default is</span>
<span class="s2">        None.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    lines : list</span>
<span class="s2">        Formatted table as a list of strings.</span>
<span class="s2">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">TableReplaceWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Warning class for cases when a table column is replaced via the</span>
<span class="sd">    Table.__setitem__ syntax e.g. t[&#39;a&#39;] = val.</span>

<span class="sd">    This does not inherit from AstropyWarning because we want to use</span>
<span class="sd">    stacklevel=3 to show the user where the issue occurred in their code.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">descr</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Array-interface compliant full description of a column.</span>

<span class="sd">    This returns a 3-tuple (name, type, shape) that can always be</span>
<span class="sd">    used in a structured array dtype definition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col_dtype</span> <span class="o">=</span> <span class="s1">&#39;O&#39;</span> <span class="k">if</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">col_shape</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">col_dtype</span><span class="p">,</span> <span class="n">col_shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">has_info_class</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if the object&#39;s info is an instance of cls.&quot;&quot;&quot;</span>
    <span class="c1"># We check info on the class of the instance, since on the instance</span>
    <span class="c1"># itself accessing &#39;info&#39; has side effects in that it sets</span>
    <span class="c1"># obj.__dict__[&#39;info&#39;] if it does not exist already.</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_names_from_list_of_dict</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return list of column names if ``rows`` is a list of dict that</span>
<span class="sd">    defines table data.</span>

<span class="sd">    If rows is not a list of dict then return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>


<span class="c1"># Note to future maintainers: when transitioning this to dict</span>
<span class="c1"># be sure to change the OrderedDict ref(s) in Row and in __len__().</span>

<span class="k">class</span> <span class="nc">TableColumns</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;OrderedDict subclass for a set of columns.</span>

<span class="sd">    This class enhances item access to provide convenient access to columns</span>
<span class="sd">    by name or index, including slice access.  It also handles renaming</span>
<span class="sd">    of columns.</span>

<span class="sd">    The initialization argument ``cols`` can be a list of ``Column`` objects</span>
<span class="sd">    or any structure that is valid for initializing a Python dict.  This</span>
<span class="sd">    includes a dict, list of (key, val) tuples or [key, val] lists, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cols : dict, list, tuple; optional</span>
<span class="sd">        Column objects as data structure that can init dict (see above)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># `cols` should be a list of two-tuples, but it is allowed to have</span>
            <span class="c1"># columns (BaseColumn or mixins) in the list.</span>
            <span class="n">newcols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">BaseColumnInfo</span><span class="p">):</span>
                    <span class="n">newcols</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">newcols</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get items from a TableColumns object.</span>
<span class="sd">        ::</span>

<span class="sd">          tc = TableColumns(cols=[Column(name=&#39;a&#39;), Column(name=&#39;b&#39;), Column(name=&#39;c&#39;)])</span>
<span class="sd">          tc[&#39;a&#39;]  # Column(&#39;a&#39;)</span>
<span class="sd">          tc[1] # Column(&#39;b&#39;)</span>
<span class="sd">          tc[&#39;a&#39;, &#39;b&#39;] # &lt;TableColumns names=(&#39;a&#39;, &#39;b&#39;)&gt;</span>
<span class="sd">          tc[1:3] # &lt;TableColumns names=(&#39;b&#39;, &#39;c&#39;)&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OrderedDict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="n">item</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="n">item</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Illegal key or index value for </span><span class="si">{}</span><span class="s1"> object&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">validated</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set item in this dict instance, but do not allow directly replacing an</span>
<span class="sd">        existing column unless it is already validated (and thus is certain to</span>
<span class="sd">        not corrupt the table).</span>

<span class="sd">        NOTE: it is easily possible to corrupt a table by directly *adding* a new</span>
<span class="sd">        key to the TableColumns attribute of a Table, e.g.</span>
<span class="sd">        ``t.columns[&#39;jane&#39;] = &#39;doe&#39;``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">validated</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot replace column &#39;</span><span class="si">{}</span><span class="s2">&#39;.  Use Table.replace_column() instead.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> names=(</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s2">)&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">_rename_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">new_name</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2"> already exists&quot;</span><span class="p">)</span>

        <span class="c1"># Rename column names in pprint include/exclude attributes as needed</span>
        <span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span>
        <span class="k">if</span> <span class="n">parent_table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_exclude_names</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_include_names</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">new_name</span><span class="p">}</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Remove column names from pprint include/exclude attributes as needed.</span>
        <span class="c1"># __delitem__ also gets called for pop() and popitem().</span>
        <span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span>
        <span class="k">if</span> <span class="n">parent_table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># _remove() method does not require that `name` is in the attribute</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_exclude_names</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_include_names</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of columns which are instances of the specified classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cls : class or tuple thereof</span>
<span class="sd">            Column class (including mixin) or tuple of Column classes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col_list : list of `Column`</span>
<span class="sd">            List of Column objects which are instances of given classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">cols</span>

    <span class="k">def</span> <span class="nf">not_isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of columns which are not instances of the specified classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cls : class or tuple thereof</span>
<span class="sd">            Column class (including mixin) or tuple of Column classes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col_list : list of `Column`</span>
<span class="sd">            List of Column objects which are not instances of given classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">cols</span>


<span class="k">class</span> <span class="nc">TableAttribute</span><span class="p">(</span><span class="n">MetaAttribute</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Descriptor to define a custom attribute for a Table subclass.</span>

<span class="sd">    The value of the ``TableAttribute`` will be stored in a dict named</span>
<span class="sd">    ``__attributes__`` that is stored in the table ``meta``.  The attribute</span>
<span class="sd">    can be accessed and set in the usual way, and it can be provided when</span>
<span class="sd">    creating the object.</span>

<span class="sd">    Defining an attribute by this mechanism ensures that it will persist if</span>
<span class="sd">    the table is sliced or serialized, for example as a pickle or ECSV file.</span>

<span class="sd">    See the `~astropy.utils.metadata.MetaAttribute` documentation for additional</span>
<span class="sd">    details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    default : object</span>
<span class="sd">        Default value for attribute</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">      &gt;&gt;&gt; from astropy.table import Table, TableAttribute</span>
<span class="sd">      &gt;&gt;&gt; class MyTable(Table):</span>
<span class="sd">      ...     identifier = TableAttribute(default=1)</span>
<span class="sd">      &gt;&gt;&gt; t = MyTable(identifier=10)</span>
<span class="sd">      &gt;&gt;&gt; t.identifier</span>
<span class="sd">      10</span>
<span class="sd">      &gt;&gt;&gt; t.meta</span>
<span class="sd">      OrderedDict([(&#39;__attributes__&#39;, {&#39;identifier&#39;: 10})])</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">PprintIncludeExclude</span><span class="p">(</span><span class="n">TableAttribute</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Maintain tuple that controls table column visibility for print output.</span>

<span class="sd">    This is a descriptor that inherits from MetaAttribute so that the attribute</span>
<span class="sd">    value is stored in the table meta[&#39;__attributes__&#39;].</span>

<span class="sd">    This gets used for the ``pprint_include_names`` and ``pprint_exclude_names`` Table</span>
<span class="sd">    attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner_cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the attribute.</span>

<span class="sd">        This normally returns an instance of this class which is stored on the</span>
<span class="sd">        owner object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For getting from class not an instance</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># If not already stored on `instance`, make a copy of the class</span>
        <span class="c1"># descriptor object and put it onto the instance.</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># We set _instance_ref on every call, since if one makes copies of</span>
        <span class="c1"># instances, this attribute will be copied as well, which will lose the</span>
        <span class="c1"># reference.</span>
        <span class="n">value</span><span class="o">.</span><span class="n">_instance_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set value of ``instance`` attribute to ``names``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        instance : object</span>
<span class="sd">            Instance that owns the attribute</span>
<span class="sd">        names : None, str, list, tuple</span>
<span class="sd">            Column name(s) to store, or None to clear</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove attribute value from the meta[&#39;__attributes__&#39;] dict.</span>
            <span class="c1"># Subsequent access will just return None.</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This stores names into instance.meta[&#39;__attributes__&#39;] as tuple</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the value of the attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        names : None, tuple</span>
<span class="sd">            Include/exclude names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the value from instance.meta[&#39;__attributes__&#39;]</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_instance_ref&#39;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> value=</span><span class="si">{</span><span class="bp">self</span><span class="p">()</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_add_remove_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Common setup for add and remove.</span>

<span class="sd">        - Coerce attribute value to a list</span>
<span class="sd">        - Coerce names into a list</span>
<span class="sd">        - Get the parent table instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="c1"># Get the value. This is the same as self() but we need `instance` here.</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add ``names`` to the include/exclude attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str, list, tuple</span>
<span class="sd">            Column name(s) to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_remove_setup</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">value</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove ``names`` from the include/exclude attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str, list, tuple</span>
<span class="sd">            Column name(s) to remove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">raise_exc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">raise_exc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove ``names`` with optional checking if they exist&quot;&quot;&quot;</span>
        <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_remove_setup</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># Return now if there are no attributes and thus no action to be taken.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raise_exc</span> <span class="ow">and</span> <span class="s1">&#39;__attributes__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Remove one by one, optionally raising an exception if name is missing.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">value</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># Using the list.remove method</span>
            <span class="k">elif</span> <span class="n">raise_exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> not in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Change to either None or a tuple for storing back to attribute</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="p">[]</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename ``name`` to ``new_name`` if ``name`` is in the list&quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="p">()</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="n">new_names</span><span class="p">[</span><span class="n">new_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">new_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set value of include/exclude attribute to ``names``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : None, str, list, tuple</span>
<span class="sd">            Column name(s) to store, or None to clear</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">class</span> <span class="nc">_Context</span><span class="p">:</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor_self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_self</span> <span class="o">=</span> <span class="n">descriptor_self</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">names_orig</span> <span class="o">=</span> <span class="n">descriptor_self</span><span class="p">()</span>

            <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">pass</span>

            <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
                <span class="n">descriptor_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_self</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="n">descriptor_self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
                <span class="n">descriptor_self</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_orig</span><span class="p">)</span>

            <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor_self</span><span class="p">)</span>

        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_Context</span><span class="p">(</span><span class="n">descriptor_self</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ctx</span>


<span class="k">class</span> <span class="nc">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class to represent tables of heterogeneous data.</span>

<span class="sd">    `~astropy.table.Table` provides a class for heterogeneous tabular data.</span>
<span class="sd">    A key enhancement provided by the `~astropy.table.Table` class over</span>
<span class="sd">    e.g. a `numpy` structured array is the ability to easily modify the</span>
<span class="sd">    structure of the table by adding or removing columns, or adding new</span>
<span class="sd">    rows of data.  In addition table and column metadata are fully supported.</span>

<span class="sd">    `~astropy.table.Table` differs from `~astropy.nddata.NDData` by the</span>
<span class="sd">    assumption that the input data consists of columns of homogeneous data,</span>
<span class="sd">    where each column has a unique identifier and may contain additional</span>
<span class="sd">    metadata such as the data unit, format, and description.</span>

<span class="sd">    See also: https://docs.astropy.org/en/stable/table/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy ndarray, dict, list, table-like object, optional</span>
<span class="sd">        Data to initialize table.</span>
<span class="sd">    masked : bool, optional</span>
<span class="sd">        Specify whether the table is masked.</span>
<span class="sd">    names : list, optional</span>
<span class="sd">        Specify column names.</span>
<span class="sd">    dtype : list, optional</span>
<span class="sd">        Specify column data types.</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata associated with the table.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Copy the input data. If the input is a Table the ``meta`` is always</span>
<span class="sd">        copied regardless of the ``copy`` parameter.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    rows : numpy ndarray, list of list, optional</span>
<span class="sd">        Row-oriented data for table instead of ``data`` argument.</span>
<span class="sd">    copy_indices : bool, optional</span>
<span class="sd">        Copy any indices in the input data. Default is True.</span>
<span class="sd">    units : list, dict, optional</span>
<span class="sd">        List or dict of units to apply to columns.</span>
<span class="sd">    descriptions : list, dict, optional</span>
<span class="sd">        List or dict of descriptions to apply to columns.</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Additional keyword args when converting table-like object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Define class attributes for core container objects to allow for subclass</span>
    <span class="c1"># customization.</span>
    <span class="n">Row</span> <span class="o">=</span> <span class="n">Row</span>
    <span class="n">Column</span> <span class="o">=</span> <span class="n">Column</span>
    <span class="n">MaskedColumn</span> <span class="o">=</span> <span class="n">MaskedColumn</span>
    <span class="n">TableColumns</span> <span class="o">=</span> <span class="n">TableColumns</span>
    <span class="n">TableFormatter</span> <span class="o">=</span> <span class="n">TableFormatter</span>

    <span class="c1"># Unified I/O read and write methods from .connect</span>
    <span class="n">read</span> <span class="o">=</span> <span class="n">UnifiedReadWriteMethod</span><span class="p">(</span><span class="n">TableRead</span><span class="p">)</span>
    <span class="n">write</span> <span class="o">=</span> <span class="n">UnifiedReadWriteMethod</span><span class="p">(</span><span class="n">TableWrite</span><span class="p">)</span>

    <span class="n">pprint_exclude_names</span> <span class="o">=</span> <span class="n">PprintIncludeExclude</span><span class="p">()</span>
    <span class="n">pprint_include_names</span> <span class="o">=</span> <span class="n">PprintIncludeExclude</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">as_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new copy of the table in the form of a structured np.ndarray or</span>
<span class="sd">        np.ma.MaskedArray object (as appropriate).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep_byteorder : bool, optional</span>
<span class="sd">            By default the returned array has all columns in native byte</span>
<span class="sd">            order.  However, if this option is `True` this preserves the</span>
<span class="sd">            byte order of all columns (if any are non-native).</span>

<span class="sd">        names : list, optional:</span>
<span class="sd">            List of column names to include for returned structured array.</span>
<span class="sd">            Default is to include all table columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        table_array : array or `~numpy.ma.MaskedArray`</span>
<span class="sd">            Copy of table as a numpy structured array.</span>
<span class="sd">            ndarray for unmasked or `~numpy.ma.MaskedArray` for masked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">masked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_values</span>
        <span class="n">empty_init</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">empty</span> <span class="k">if</span> <span class="n">masked</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">empty_init</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">col_descr</span> <span class="o">=</span> <span class="n">descr</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">isnative</span> <span class="ow">or</span> <span class="n">keep_byteorder</span><span class="p">):</span>
                <span class="n">new_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">col_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
                <span class="n">col_descr</span> <span class="o">=</span> <span class="p">(</span><span class="n">col_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_dt</span><span class="p">,</span> <span class="n">col_descr</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">dtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_descr</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">empty_init</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="c1"># When assigning from one array into a field of a structured array,</span>
            <span class="c1"># Numpy will automatically swap those columns to their destination</span>
            <span class="c1"># byte order where applicable</span>
            <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>

            <span class="c1"># For masked out, masked mixin columns need to set output mask attribute.</span>
            <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">mask</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">descriptions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Set up a placeholder empty table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_masked</span><span class="p">(</span><span class="n">masked</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableFormatter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copy_indices</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># copy indices from this Table by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span> <span class="o">=</span> <span class="n">copy_indices</span>  <span class="c1"># whether to copy indices in init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Must copy if dtype are changing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot specify dtype when copy=False&#39;</span><span class="p">)</span>

        <span class="c1"># Specifies list of names found for the case of initializing table with</span>
        <span class="c1"># a list of dict. If data are not list of dict then this is None.</span>
        <span class="n">names_from_list_of_dict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Row-oriented input, e.g. list of lists or list of tuples, list of</span>
        <span class="c1"># dict, Row instance.  Set data to something that the subsequent code</span>
        <span class="c1"># will parse correctly.</span>
        <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot supply both `data` and `rows` values&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
                <span class="c1"># Without this then the all(..) test below uses up the generator</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

            <span class="c1"># Get column names if `rows` is a list of dict, otherwise this is None</span>
            <span class="n">names_from_list_of_dict</span> <span class="o">=</span> <span class="n">_get_names_from_list_of_dict</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">names_from_list_of_dict</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">rows</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">rows</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">rows</span><span class="p">))</span>

        <span class="c1"># Infer the type of the input data and set up the initialization</span>
        <span class="c1"># function, number of columns, and potentially the default col names</span>

        <span class="n">default_names</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Handle custom (subclass) table attributes that are stored in meta.</span>
        <span class="c1"># These are defined as class attributes using the TableAttribute</span>
        <span class="c1"># descriptor.  Any such attributes get removed from kwargs here and</span>
        <span class="c1"># stored for use after the table is otherwise initialized. Any values</span>
        <span class="c1"># provided via kwargs will have precedence over existing values from</span>
        <span class="c1"># meta (e.g. from data as a Table or meta via kwargs).</span>
        <span class="n">meta_table_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">descr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="n">TableAttribute</span><span class="p">):</span>
                    <span class="n">meta_table_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;__astropy_table__&#39;</span><span class="p">):</span>
            <span class="c1"># Data object implements the __astropy_table__ interface method.</span>
            <span class="c1"># Calling that method returns an appropriate instance of</span>
            <span class="c1"># self.__class__ and respects the `copy` arg.  The returned</span>
            <span class="c1"># Table object should NOT then be copied.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">__astropy_table__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;__init__() got unexpected keyword argument </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span><span class="n">data</span><span class="o">.</span><span class="n">_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># Get column names from `data` if it is a list of dict, otherwise this is None.</span>
            <span class="c1"># This might be previously defined if `rows` was supplied as an init arg.</span>
            <span class="n">names_from_list_of_dict</span> <span class="o">=</span> <span class="p">(</span><span class="n">names_from_list_of_dict</span>
                                       <span class="ow">or</span> <span class="n">_get_names_from_list_of_dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">names_from_list_of_dict</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list_of_dicts</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_from_list_of_dict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_ndarray</span>  <span class="c1"># _struct</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">default_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_ndarray</span>  <span class="c1"># _homog</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can not initialize a Table with a scalar&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_dict</span>
            <span class="n">default_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="c1"># If user-input meta is None then use data.meta (if non-trivial)</span>
            <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                <span class="c1"># At this point do NOT deepcopy data.meta as this will happen after</span>
                <span class="c1"># table init_func() is called.  But for table input the table meta</span>
                <span class="c1"># gets a key copy here if copy=False because later a direct object ref</span>
                <span class="c1"># is used.</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Handle indices on input table. Copy primary key and don&#39;t copy indices</span>
            <span class="c1"># if the input Table is in non-copy mode.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">primary_key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">_copy_indices</span>

            <span class="c1"># Extract default names, n_cols, and then overwrite ``data`` to be the</span>
            <span class="c1"># table columns so we can use _init_from_list.</span>
            <span class="n">default_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">colnames</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span>

        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Table was initialized as `t = Table()`. Set up for empty</span>
                    <span class="c1"># table with names=[], data=[], and n_cols=0.</span>
                    <span class="c1"># self._init_from_list() will simply return, giving the</span>
                    <span class="c1"># expected empty table.</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># No data nor names but dtype is available.  This must be</span>
                        <span class="c1"># valid to initialize a structured array.</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="n">names</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dtype was specified but could not be &#39;</span>
                                         <span class="s1">&#39;parsed for column names&#39;</span><span class="p">)</span>
            <span class="c1"># names is guaranteed to be set at this point</span>
            <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="n">n_cols</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Data type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> not allowed to init Table&#39;</span><span class="p">)</span>

        <span class="c1"># Set up defaults if names and/or dtype are not specified.</span>
        <span class="c1"># A value of None means the actual value will be inferred</span>
        <span class="c1"># within the appropriate initialization routine, either from</span>
        <span class="c1"># existing specification or auto-generated.</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_cols</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">default_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">default_names</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
            <span class="c1"># Convert a numpy dtype input to a list of dtypes for later use.</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">default_names</span> <span class="ow">or</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_cols</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_names_dtype</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">)</span>

        <span class="c1"># Finally do the real initialization</span>
        <span class="n">init_func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="c1"># Set table meta.  If copy=True then deepcopy meta otherwise use the</span>
        <span class="c1"># user-supplied meta directly.</span>
        <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">meta</span>

        <span class="c1"># Update meta with TableAttributes supplied as kwargs in Table init.</span>
        <span class="c1"># This takes precedence over previously-defined meta.</span>
        <span class="k">if</span> <span class="n">meta_table_attrs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">meta_table_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Whatever happens above, the masked property should be set to a boolean</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;masked property must be None, True or False&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_column_attribute</span><span class="p">(</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_column_attribute</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_column_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set ``attr`` for columns to ``values``, which can be either a dict (keyed by column</span>
<span class="sd">        name) or a dict of name: value pairs.  This is used for handling the ``units`` and</span>
<span class="sd">        ``descriptions`` kwargs to ``__init__``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Row</span><span class="p">):</span>
            <span class="c1"># For a Row object transform to an equivalent dict.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">colnames</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="c1"># If not a dict map, assume iterable and map to dict if the right length</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sequence of </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1"> values must match number of columns&#39;</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;invalid column name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> for setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1"> attribute&#39;</span><span class="p">)</span>

            <span class="c1"># Special case: ignore unit if it is an empty or blank string</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;unit&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">col</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">BaseColumn</span><span class="p">)</span> <span class="k">else</span> <span class="n">col_copy</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
                              <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">columns</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Dynamic view of available masks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_values</span><span class="p">:</span>
            <span class="n">mask_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="n">FalseArray</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">()],</span>
                               <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Set hidden attribute to force inplace setitem so that code like</span>
            <span class="c1"># t.mask[&#39;a&#39;] = [1, 0, 1] will correctly set the underlying mask.</span>
            <span class="c1"># See #5556 for discussion.</span>
            <span class="n">mask_table</span><span class="o">.</span><span class="n">_setitem_inplace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask_table</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">mask_table</span>

    <span class="nd">@mask</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is needed so that comparison of a masked Table and a</span>
<span class="sd">        MaskedArray works.  The requirement comes from numpy.ma.core</span>
<span class="sd">        so don&#39;t remove this property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span><span class="o">.</span><span class="n">mask</span>

    <span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy of self, with masked values filled.</span>

<span class="sd">        If input ``fill_value`` supplied then that value is used for all</span>
<span class="sd">        masked entries in the table.  Otherwise the individual</span>
<span class="sd">        ``fill_value`` defined for each table column is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : str</span>
<span class="sd">            If supplied, this ``fill_value`` is used for all masked entries</span>
<span class="sd">            in the entire table.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled_table : `~astropy.table.Table`</span>
<span class="sd">            New table with masked values filled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_values</span><span class="p">:</span>
            <span class="c1"># Get new columns with masked values filled, then create Table with those</span>
            <span class="c1"># new cols (copy=False) but deepcopy the meta.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;filled&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span>
                    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">()]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return copy of the original object.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the indices associated with columns of the table</span>
<span class="sd">        as a TableIndices object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">column</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">index</span> <span class="ow">is</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure uniqueness</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TableIndices</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a TableLoc object that can be used for retrieving</span>
<span class="sd">        rows by index in a given data range. Note that both loc</span>
<span class="sd">        and iloc work only with single-column indices.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">TableLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a TableLocIndices object that can be used for retrieving</span>
<span class="sd">        the row indices corresponding to given table index key value or values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TableLocIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a TableILoc object that can be used for retrieving</span>
<span class="sd">        indexed rows in the order they appear in the index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">TableILoc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colnames</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Insert a new index among one or more columns.</span>
<span class="sd">        If there are no indices, make this index the</span>
<span class="sd">        primary table index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        colnames : str or list</span>
<span class="sd">            List of column names (or a single column name) to index</span>
<span class="sd">        engine : type or None</span>
<span class="sd">            Indexing engine class to use, from among SortedArray, BST,</span>
<span class="sd">            and SCEngine. If the supplied argument is None</span>
<span class="sd">            (by default), use SortedArray.</span>
<span class="sd">        unique : bool</span>
<span class="sd">            Whether the values of the index must be unique. Default is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">colnames</span> <span class="o">=</span> <span class="p">(</span><span class="n">colnames</span><span class="p">,)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">colnames</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="c1"># make sure all columns support indexing</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s1">&#39;_supports_indexing&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot create an index on column &quot;</span><span class="si">{}</span><span class="s1">&quot;, of &#39;</span>
                                 <span class="s1">&#39;type &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">col</span><span class="p">)))</span>

        <span class="n">is_primary</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">)</span>
        <span class="n">sliced_index</span> <span class="o">=</span> <span class="n">SlicedIndex</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">original</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_primary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="n">colnames</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Remove all indices involving the given column.</span>
<span class="sd">        If the primary index is removed, the new primary</span>
<span class="sd">        index will be the most recently added remaining</span>
<span class="sd">        index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        colname : str</span>
<span class="sd">            Name of column</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">col_position</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a context manager for an indexing mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : str</span>
<span class="sd">            Either &#39;freeze&#39;, &#39;copy_on_getitem&#39;, or &#39;discard_on_copy&#39;.</span>
<span class="sd">            In &#39;discard_on_copy&#39; mode,</span>
<span class="sd">            indices are not copied whenever columns or tables are copied.</span>
<span class="sd">            In &#39;freeze&#39; mode, indices are not modified whenever columns are</span>
<span class="sd">            modified; at the exit of the context, indices refresh themselves</span>
<span class="sd">            based on column values. This mode is intended for scenarios in</span>
<span class="sd">            which one intends to make many additions or modifications in an</span>
<span class="sd">            indexed column.</span>
<span class="sd">            In &#39;copy_on_getitem&#39; mode, indices are copied when taking column</span>
<span class="sd">            slices as well as table slices, so col[i0:i1] will preserve</span>
<span class="sd">            indices.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">_IndexModeContext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Support converting Table to np.array via np.array(table).</span>

<span class="sd">        Coercion to a different dtype via np.array(table, dtype) is not</span>
<span class="sd">        supported and will raise a ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Datatype coercion is not allowed&#39;</span><span class="p">)</span>

        <span class="c1"># This limitation is because of the following unexpected result that</span>
        <span class="c1"># should have made a table copy while changing the column names.</span>
        <span class="c1">#</span>
        <span class="c1"># &gt;&gt;&gt; d = astropy.table.Table([[1,2],[3,4]])</span>
        <span class="c1"># &gt;&gt;&gt; np.array(d, dtype=[(&#39;a&#39;, &#39;i8&#39;), (&#39;b&#39;, &#39;i8&#39;)])</span>
        <span class="c1"># array([(0, 0), (0, 0)],</span>
        <span class="c1">#       dtype=[(&#39;a&#39;, &#39;&lt;i8&#39;), (&#39;b&#39;, &#39;&lt;i8&#39;)])</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_check_names_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make sure that names and dtype are both iterable and have</span>
<span class="sd">        the same length as data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">inp_list</span><span class="p">,</span> <span class="n">inp_str</span> <span class="ow">in</span> <span class="p">((</span><span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="s1">&#39;names&#39;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">inp_list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">inp_str</span><span class="si">}</span><span class="s1"> must be a list or None&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_cols</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Arguments &quot;names&quot; and &quot;dtype&quot; must match number of columns&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_list_of_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize table from a list of dictionaries representing rows.&quot;&quot;&quot;</span>
        <span class="c1"># Define placeholder for missing values as a unique object that cannot</span>
        <span class="c1"># every occur in user data.</span>
        <span class="n">MISSING</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

        <span class="c1"># Gather column names that exist in the input `data`.</span>
        <span class="n">names_from_data</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">names_from_data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="n">names_from_data</span><span class="p">:</span>
            <span class="n">names_from_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names_from_data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">names_from_data</span><span class="p">)</span>

        <span class="c1"># Note: if set(data[0].keys()) != names_from_data, this will give an</span>
        <span class="c1"># exception later, so NO need to catch here.</span>

        <span class="c1"># Convert list of dict into dict of list (cols), keep track of missing</span>
        <span class="c1"># indexes and put in MISSING placeholders in the `cols` lists.</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">missing_indexes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names_from_data</span><span class="p">:</span>
            <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">missing_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">MISSING</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># Fill the missing entries with first values</span>
        <span class="k">if</span> <span class="n">missing_indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">missing_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">first_val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">col</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MISSING</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">col</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_val</span>

        <span class="c1"># prepare initialization</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names_from_data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_dict</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="c1"># Mask the missing values if necessary, converting columns to MaskedColumn</span>
        <span class="c1"># as needed.</span>
        <span class="k">if</span> <span class="n">missing_indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">missing_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># Ensure that any Column subclasses with MISSING values can support</span>
                <span class="c1"># setting masked values. As of astropy 4.0 the test condition below is</span>
                <span class="c1"># always True since _init_from_dict cannot result in mixin columns.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Finally do the masking in a mixin-safe way.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">indexes</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_init_from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize table from a list of column data.  A column can be a</span>
<span class="sd">        Column object, np.ndarray, mixin, or any other iterable object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Special case of initializing an empty table like `t = Table()`. No</span>
        <span class="c1"># action required at this point.</span>
        <span class="k">if</span> <span class="n">n_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">default_names</span> <span class="o">=</span> <span class="n">_auto_names</span><span class="p">(</span><span class="n">n_cols</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">default_names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_data_to_col</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_cols</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_data_to_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert any allowed sequence data ``col`` to a column object that can be used</span>
<span class="sd">        directly in the self.columns dict.  This could be a Column, MaskedColumn,</span>
<span class="sd">        or mixin column.</span>

<span class="sd">        The final column name is determined by::</span>

<span class="sd">            name or data.info.name or def_name</span>

<span class="sd">        If ``data`` has no ``info`` then ``name = name or def_name``.</span>

<span class="sd">        The behavior of ``copy`` for Column objects is:</span>
<span class="sd">        - copy=True: new class instance with a copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: new class instance with same data and a key-only copy of meta</span>

<span class="sd">        For mixin columns:</span>
<span class="sd">        - copy=True: new class instance with copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: original instance (no copy at all)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : object (column-like sequence)</span>
<span class="sd">            Input column data</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make a copy</span>
<span class="sd">        default_name : str</span>
<span class="sd">            Default name</span>
<span class="sd">        dtype : np.dtype or None</span>
<span class="sd">            Data dtype</span>
<span class="sd">        name : str or None</span>
<span class="sd">            Column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col : Column, MaskedColumn, mixin-column type</span>
<span class="sd">            Object that can be used as a column in self</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_is_mixin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixin_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">masked_col_cls</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>
                          <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">)</span>
                          <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data0_is_mixin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixin_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Need broad exception, cannot predict what data[0] raises for arbitrary data</span>
            <span class="n">data0_is_mixin</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># If the data is not an instance of Column or a mixin class, we can</span>
        <span class="c1"># check the registry of mixin &#39;handlers&#39; to see if the column can be</span>
        <span class="c1"># converted to a mixin class</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="o">:=</span> <span class="n">get_mixin_handler</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">original_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data_is_mixin</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixin_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
                <span class="n">fully_qualified_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
                                        <span class="o">+</span> <span class="n">original_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Mixin handler for object of type &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">fully_qualified_name</span><span class="si">}</span><span class="s1"> &#39;</span>
                                <span class="s1">&#39;did not return a valid mixin column&#39;</span><span class="p">)</span>

        <span class="c1"># Get the final column name using precedence.  Some objects may not</span>
        <span class="c1"># have an info attribute. Also avoid creating info as a side effect.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">default_name</span>
            <span class="k">elif</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">()):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">default_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">default_name</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
            <span class="c1"># If self.ColumnClass is a subclass of col, then &quot;upgrade&quot; to ColumnClass,</span>
            <span class="c1"># otherwise just use the original class.  The most common case is a</span>
            <span class="c1"># table with masked=True and ColumnClass=MaskedColumn.  Then a Column</span>
            <span class="c1"># gets upgraded to MaskedColumn, but the converse (pre-4.0) behavior</span>
            <span class="c1"># of downgrading from MaskedColumn to Column (for non-masked table)</span>
            <span class="c1"># does not happen.</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_col_cls_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_is_mixin</span><span class="p">:</span>
            <span class="c1"># Copy the mixin column attributes if they exist since the copy below</span>
            <span class="c1"># may not get this attribute.</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">data</span>
            <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">col</span>

        <span class="k">elif</span> <span class="n">data0_is_mixin</span><span class="p">:</span>
            <span class="c1"># Handle case of a sequence of a mixin, e.g. [1*u.m, 2*u.m].</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">return</span> <span class="n">col</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># If that didn&#39;t work for some reason, just turn it into np.array of object</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">Masked</span><span class="p">)):</span>
            <span class="c1"># Require that col_cls be a subclass of MaskedColumn, remembering</span>
            <span class="c1"># that ColumnClass could be a user-defined subclass (though more-likely</span>
            <span class="c1"># could be MaskedColumn).</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="n">masked_col_cls</span>

        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Special case for data passed as the None object (for broadcasting</span>
            <span class="c1"># to an object column). Need to turn data into numpy `None` scalar</span>
            <span class="c1"># object, otherwise `Column` interprets data=None as no data instead</span>
            <span class="c1"># of a object column of `None`.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
            <span class="c1"># `data` is none of the above, convert to numpy array or MaskedArray</span>
            <span class="c1"># assuming only that it is a scalar or sequence or N-d nested</span>
            <span class="c1"># sequence. This function is relatively intricate and tries to</span>
            <span class="c1"># maintain performance for common cases while handling things like</span>
            <span class="c1"># list input with embedded np.ma.masked entries. If `data` is a</span>
            <span class="c1"># scalar then it gets returned unchanged so the original object gets</span>
            <span class="c1"># passed to `Column` later.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_sequence_data_to_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Already made a copy above</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="n">masked_col_cls</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col_cls</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                          <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">copy_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Broad exception class since we don&#39;t know what might go wrong</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unable to convert data to Column for Table&#39;</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_col_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">col</span>

    <span class="k">def</span> <span class="nf">_init_from_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize table from an ndarray structured array&quot;&quot;&quot;</span>

        <span class="n">data_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="n">_auto_names</span><span class="p">(</span><span class="n">n_cols</span><span class="p">)</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="ow">or</span> <span class="n">data_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)]</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data_names</span><span class="p">]</span> <span class="k">if</span> <span class="n">struct</span> <span class="k">else</span>
                <span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cols</span><span class="p">)])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize table from a dictionary of columns&quot;&quot;&quot;</span>

        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_col_cls_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the correct column class to use for upgrading any Column-like object.</span>

<span class="sd">        For a masked table, ensure any Column-like object is a subclass</span>
<span class="sd">        of the table MaskedColumn.</span>

<span class="sd">        For unmasked table, ensure any MaskedColumn-like object is a subclass</span>
<span class="sd">        of the table MaskedColumn.  If not a MaskedColumn, then ensure that any</span>
<span class="sd">        Column-like object is a subclass of the table Column.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">col_cls</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">):</span>
                <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">):</span>
                    <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span><span class="p">):</span>
                <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span>

        <span class="k">return</span> <span class="n">col_cls</span>

    <span class="k">def</span> <span class="nf">_convert_col_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure that all Column objects have correct base class for this type of</span>
<span class="sd">        Table.  For a base Table this most commonly means setting to</span>
<span class="sd">        MaskedColumn if the table is masked.  Table subclasses like QTable</span>
<span class="sd">        override this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">):</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_col_cls_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">col_cls</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">col</span>

    <span class="k">def</span> <span class="nf">_init_from_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize table from a list of Column or mixin objects&quot;&quot;&quot;</span>

        <span class="n">lengths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Inconsistent data column lengths: </span><span class="si">{</span><span class="n">lengths</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Make sure that all Column-based objects have correct class.  For</span>
        <span class="c1"># plain Table this is self.ColumnClass, but for instance QTable will</span>
        <span class="c1"># convert columns with units to a Quantity mixin.</span>
        <span class="n">newcols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_col_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_table_from_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newcols</span><span class="p">)</span>

        <span class="c1"># Deduplicate indices.  It may happen that after pickling or when</span>
        <span class="c1"># initing from an existing table that column indices which had been</span>
        <span class="c1"># references to a single index object got *copied* into an independent</span>
        <span class="c1"># object.  This results in duplicates which will cause downstream problems.</span>
        <span class="n">index_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="ow">or</span> <span class="p">[]):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">ind_col</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">index_dict</span><span class="p">:</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_dict</span><span class="p">[</span><span class="n">names</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index_dict</span><span class="p">[</span><span class="n">names</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_new_from_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new table as a referenced slice from self.&quot;&quot;&quot;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">masked</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">masked</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
            <span class="n">table</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Shallow copy for slice</span>
        <span class="n">table</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span>

        <span class="n">newcols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">slice_</span><span class="p">]</span>

            <span class="c1"># Note in line below, use direct attribute access to col.indices for Column</span>
            <span class="c1"># instances instead of the generic col.info.indices.  This saves about 4 usec</span>
            <span class="c1"># per column.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="c1"># TODO : as far as I can tell the only purpose of setting _copy_indices</span>
                <span class="c1"># here is to communicate that to the initial test in `slice_indices`.</span>
                <span class="c1"># Why isn&#39;t that just sent as an arg to the function?</span>
                <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">_copy_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_indices</span>
                <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">slice_indices</span><span class="p">(</span><span class="n">newcol</span><span class="p">,</span> <span class="n">slice_</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>

                <span class="c1"># Don&#39;t understand why this is forcing a value on the original column.</span>
                <span class="c1"># Normally col.info does not even have a _copy_indices attribute.  Tests</span>
                <span class="c1"># still pass if this line is deleted.  (Each col.info attribute access</span>
                <span class="c1"># is expensive).</span>
                <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">_copy_indices</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">newcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newcol</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_make_table_from_cols</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">newcols</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">table</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_table_from_cols</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make ``table`` in-place so that it represents the given list of ``cols``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>

        <span class="c1"># Note: we do not test for len(names) == len(cols) if names is not None.  In that</span>
        <span class="c1"># case the function is being called by from &quot;trusted&quot; source (e.g. right above here)</span>
        <span class="c1"># that is assumed to provide valid inputs.  In that case verify=False.</span>

        <span class="k">if</span> <span class="n">verify</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot have None for column name&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Duplicate column names&#39;</span><span class="p">)</span>

        <span class="n">table</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">table</span><span class="o">.</span><span class="n">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set ``col.parent_table = self`` and force ``col`` to have ``mask``</span>
<span class="sd">        attribute if the table is masked and ``col.mask`` does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For Column instances it is much faster to do direct attribute access</span>
        <span class="c1"># instead of going through .info</span>
        <span class="n">col_info</span> <span class="o">=</span> <span class="n">col</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span>
        <span class="n">col_info</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># Legacy behavior for masked table</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
            <span class="n">col</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">FalseArray</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">itercols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the columns of this table.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        To iterate over the columns of a table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1], [2]])</span>
<span class="sd">            &gt;&gt;&gt; for col in t.itercols():</span>
<span class="sd">            ...     print(col)</span>
<span class="sd">            col0</span>
<span class="sd">            ----</span>
<span class="sd">               1</span>
<span class="sd">            col1</span>
<span class="sd">            ----</span>
<span class="sd">               2</span>

<span class="sd">        Using ``itercols()`` is similar to  ``for col in t.columns.values()``</span>
<span class="sd">        but is syntactically preferred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_base_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">descr_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">tableclass</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">descr_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">descr_vals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
                <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;masked=True&#39;</span><span class="p">)</span>
            <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;length=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">descr</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">descr_vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">html</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">astropy.utils.xml.writer</span> <span class="kn">import</span> <span class="n">xml_escape</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;i&gt;</span><span class="si">{</span><span class="n">xml_escape</span><span class="p">(</span><span class="n">descr</span><span class="p">)</span><span class="si">}</span><span class="s1">&lt;/i&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="n">descr</span><span class="si">}</span><span class="s1">&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">tableid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tableid</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;table</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">data_lines</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_pformat_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">tableid</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="n">max_width</span><span class="p">,</span>
            <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">,</span>
            <span class="n">max_lines</span><span class="o">=</span><span class="n">max_lines</span><span class="p">,</span> <span class="n">tableclass</span><span class="o">=</span><span class="n">tableclass</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">descr</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_lines</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_repr_</span><span class="p">(</span><span class="n">html</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">tableclass</span><span class="o">=</span><span class="n">conf</span><span class="o">.</span><span class="n">default_notebook_table_class</span><span class="p">)</span>
        <span class="c1"># Wrap &lt;table&gt; in &lt;div&gt;. This follows the pattern in pandas and allows</span>
        <span class="c1"># table to be scrollable horizontally in VS Code notebook display.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;div&gt;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">&lt;/div&gt;&#39;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_repr_</span><span class="p">(</span><span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pformat</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__bytes__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_mixin_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if table has any mixin columns (defined as columns that are not Column</span>
<span class="sd">        subclasses).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_masked_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if table has any ``MaskedColumn`` columns.</span>

<span class="sd">        This does not check for mixin columns that may have masked values, use the</span>
<span class="sd">        ``has_masked_values`` property in that case.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_masked_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if column in the table has values which are masked.</span>

<span class="sd">        This may be relatively slow for large tables as it requires checking the mask</span>
<span class="sd">        values of each column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">mask</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_is_mixin_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if ``col`` should be added to the table directly as</span>
<span class="sd">        a mixin column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">BaseColumn</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Is it a mixin but not [Masked]Quantity (which gets converted to</span>
        <span class="c1"># [Masked]Column with unit set).</span>
        <span class="k">return</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">QuantityInfo</span><span class="p">)</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pprint_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print a formatted string representation of the table.</span>

<span class="sd">        If no value of ``max_lines`` is supplied then the height of the</span>
<span class="sd">        screen terminal is used to set ``max_lines``.  If the terminal</span>
<span class="sd">        height cannot be determined then the default is taken from the</span>
<span class="sd">        configuration item ``astropy.conf.max_lines``.  If a negative</span>
<span class="sd">        value of ``max_lines`` is supplied then there is no line limit</span>
<span class="sd">        applied.</span>

<span class="sd">        The same applies for max_width except the configuration item is</span>
<span class="sd">        ``astropy.conf.max_width``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_pformat_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="p">,</span> <span class="n">max_width</span><span class="p">,</span>
                                                    <span class="n">show_name</span><span class="o">=</span><span class="n">show_name</span><span class="p">,</span> <span class="n">show_unit</span><span class="o">=</span><span class="n">show_unit</span><span class="p">,</span>
                                                    <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outs</span><span class="p">[</span><span class="s1">&#39;show_length&#39;</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Length = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1"> rows&#39;</span><span class="p">)</span>

        <span class="n">n_header</span> <span class="o">=</span> <span class="n">outs</span><span class="p">[</span><span class="s1">&#39;n_header&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_header</span><span class="p">:</span>
                <span class="n">color_print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pprint_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pprint_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print a formatted string representation of the entire table.</span>

<span class="sd">        This method is the same as `astropy.table.Table.pprint` except that</span>
<span class="sd">        the default ``max_lines`` and ``max_width`` are both -1 so that by</span>
<span class="sd">        default the entire table is printed instead of restricting to the size</span>
<span class="sd">        of the screen terminal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">max_lines</span><span class="p">,</span> <span class="n">max_width</span><span class="p">,</span> <span class="n">show_name</span><span class="p">,</span>
                           <span class="n">show_unit</span><span class="p">,</span> <span class="n">show_dtype</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_index_row_display_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_row_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index_row_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">idx_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">index_row_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">idx_col</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                                  <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">show_in_notebook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">css</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display_length</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                         <span class="n">table_class</span><span class="o">=</span><span class="s1">&#39;astropy-default&#39;</span><span class="p">,</span> <span class="n">show_row_index</span><span class="o">=</span><span class="s1">&#39;idx&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Render the table in HTML and show it in the IPython notebook.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tableid : str or None</span>
<span class="sd">            An html ID tag for the table.  Default is ``table{id}-XXX``, where</span>
<span class="sd">            id is the unique integer id of the table object, id(self), and XXX</span>
<span class="sd">            is a random number to avoid conflicts when printing the same table</span>
<span class="sd">            multiple times.</span>
<span class="sd">        table_class : str or None</span>
<span class="sd">            A string with a list of HTML classes used to style the table.</span>
<span class="sd">            The special default string (&#39;astropy-default&#39;) means that the string</span>
<span class="sd">            will be retrieved from the configuration item</span>
<span class="sd">            ``astropy.table.default_notebook_table_class``. Note that these</span>
<span class="sd">            table classes may make use of bootstrap, as this is loaded with the</span>
<span class="sd">            notebook.  See `this page &lt;https://getbootstrap.com/css/#tables&gt;`_</span>
<span class="sd">            for the list of classes.</span>
<span class="sd">        css : str</span>
<span class="sd">            A valid CSS string declaring the formatting for the table. Defaults</span>
<span class="sd">            to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.</span>
<span class="sd">        display_length : int, optional</span>
<span class="sd">            Number or rows to show. Defaults to 50.</span>
<span class="sd">        show_row_index : str or False</span>
<span class="sd">            If this does not evaluate to False, a column with the given name</span>
<span class="sd">            will be added to the version of the table that gets displayed.</span>
<span class="sd">            This new column shows the index of the row in the table itself,</span>
<span class="sd">            even when the displayed table is re-sorted by another column. Note</span>
<span class="sd">            that if a column with this name already exists, this option will be</span>
<span class="sd">            ignored. Defaults to &quot;idx&quot;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently, unlike `show_in_browser` (with ``jsviewer=True``), this</span>
<span class="sd">        method needs to access online javascript code repositories.  This is due</span>
<span class="sd">        to modern browsers&#39; limitations on accessing local files.  Hence, if you</span>
<span class="sd">        call this method while offline (and don&#39;t have a cached version of</span>
<span class="sd">        jquery and jquery.dataTables), you will not get the jsviewer features.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.jsviewer</span> <span class="kn">import</span> <span class="n">JSViewer</span>
        <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span>

        <span class="k">if</span> <span class="n">tableid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tableid</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;table</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">jsv</span> <span class="o">=</span> <span class="n">JSViewer</span><span class="p">(</span><span class="n">display_length</span><span class="o">=</span><span class="n">display_length</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_row_index</span><span class="p">:</span>
            <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_index_row_display_table</span><span class="p">(</span><span class="n">show_row_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">table_class</span> <span class="o">==</span> <span class="s1">&#39;astropy-default&#39;</span><span class="p">:</span>
            <span class="n">table_class</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">default_notebook_table_class</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">display_table</span><span class="o">.</span><span class="n">_base_repr_</span><span class="p">(</span><span class="n">html</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">tableid</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span>
                                         <span class="n">max_lines</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">tableclass</span><span class="o">=</span><span class="n">table_class</span><span class="p">)</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">display_table</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">sortable_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;iufc&#39;</span><span class="p">]</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="n">jsv</span><span class="o">.</span><span class="n">ipynb</span><span class="p">(</span><span class="n">tableid</span><span class="p">,</span> <span class="n">css</span><span class="o">=</span><span class="n">css</span><span class="p">,</span> <span class="n">sort_columns</span><span class="o">=</span><span class="n">sortable_columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">HTML</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">show_in_browser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">jsviewer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">browser</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">jskwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;use_local_files&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
                        <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">table_class</span><span class="o">=</span><span class="s2">&quot;display compact&quot;</span><span class="p">,</span>
                        <span class="n">css</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_row_index</span><span class="o">=</span><span class="s1">&#39;idx&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Render the table in HTML and show it in a web browser.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_lines : int</span>
<span class="sd">            Maximum number of rows to export to the table (set low by default</span>
<span class="sd">            to avoid memory issues, since the browser view requires duplicating</span>
<span class="sd">            the table in memory).  A negative value of ``max_lines`` indicates</span>
<span class="sd">            no row limit.</span>
<span class="sd">        jsviewer : bool</span>
<span class="sd">            If `True`, prepends some javascript headers so that the table is</span>
<span class="sd">            rendered as a `DataTables &lt;https://datatables.net&gt;`_ data table.</span>
<span class="sd">            This allows in-browser searching &amp; sorting.</span>
<span class="sd">        browser : str</span>
<span class="sd">            Any legal browser name, e.g. ``&#39;firefox&#39;``, ``&#39;chrome&#39;``,</span>
<span class="sd">            ``&#39;safari&#39;`` (for mac, you may need to use ``&#39;open -a</span>
<span class="sd">            &quot;/Applications/Google Chrome.app&quot; {}&#39;`` for Chrome).  If</span>
<span class="sd">            ``&#39;default&#39;``, will use the system default browser.</span>
<span class="sd">        jskwargs : dict</span>
<span class="sd">            Passed to the `astropy.table.JSViewer` init. Defaults to</span>
<span class="sd">            ``{&#39;use_local_files&#39;: True}`` which means that the JavaScript</span>
<span class="sd">            libraries will be served from local copies.</span>
<span class="sd">        tableid : str or None</span>
<span class="sd">            An html ID tag for the table.  Default is ``table{id}``, where id</span>
<span class="sd">            is the unique integer id of the table object, id(self).</span>
<span class="sd">        table_class : str or None</span>
<span class="sd">            A string with a list of HTML classes used to style the table.</span>
<span class="sd">            Default is &quot;display compact&quot;, and other possible values can be</span>
<span class="sd">            found in https://www.datatables.net/manual/styling/classes</span>
<span class="sd">        css : str</span>
<span class="sd">            A valid CSS string declaring the formatting for the table. Defaults</span>
<span class="sd">            to ``astropy.table.jsviewer.DEFAULT_CSS``.</span>
<span class="sd">        show_row_index : str or False</span>
<span class="sd">            If this does not evaluate to False, a column with the given name</span>
<span class="sd">            will be added to the version of the table that gets displayed.</span>
<span class="sd">            This new column shows the index of the row in the table itself,</span>
<span class="sd">            even when the displayed table is re-sorted by another column. Note</span>
<span class="sd">            that if a column with this name already exists, this option will be</span>
<span class="sd">            ignored. Defaults to &quot;idx&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">os</span>
        <span class="kn">import</span> <span class="nn">webbrowser</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="kn">from</span> <span class="nn">.jsviewer</span> <span class="kn">import</span> <span class="n">DEFAULT_CSS</span>
        <span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>
        <span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">pathname2url</span>

        <span class="k">if</span> <span class="n">css</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">css</span> <span class="o">=</span> <span class="n">DEFAULT_CSS</span>

        <span class="c1"># We can&#39;t use NamedTemporaryFile here because it gets deleted as</span>
        <span class="c1"># soon as it gets garbage collected.</span>
        <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span> <span class="s1">&#39;table.html&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">jsviewer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">show_row_index</span><span class="p">:</span>
                    <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_index_row_display_table</span><span class="p">(</span><span class="n">show_row_index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">display_table</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;jsviewer&#39;</span><span class="p">,</span> <span class="n">css</span><span class="o">=</span><span class="n">css</span><span class="p">,</span>
                                    <span class="n">max_lines</span><span class="o">=</span><span class="n">max_lines</span><span class="p">,</span> <span class="n">jskwargs</span><span class="o">=</span><span class="n">jskwargs</span><span class="p">,</span>
                                    <span class="n">table_id</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span> <span class="n">table_class</span><span class="o">=</span><span class="n">table_class</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">br</span> <span class="o">=</span> <span class="n">webbrowser</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">browser</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="k">else</span> <span class="n">browser</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">webbrowser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Browser &#39;</span><span class="si">{</span><span class="n">browser</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">br</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;file:&#39;</span><span class="p">,</span> <span class="n">pathname2url</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pformat_docs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{id}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pformat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tableclass</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of lines for the formatted string representation of</span>
<span class="sd">        the table.</span>

<span class="sd">        If no value of ``max_lines`` is supplied then the height of the</span>
<span class="sd">        screen terminal is used to set ``max_lines``.  If the terminal</span>
<span class="sd">        height cannot be determined then the default is taken from the</span>
<span class="sd">        configuration item ``astropy.conf.max_lines``.  If a negative</span>
<span class="sd">        value of ``max_lines`` is supplied then there is no line limit</span>
<span class="sd">        applied.</span>

<span class="sd">        The same applies for ``max_width`` except the configuration item  is</span>
<span class="sd">        ``astropy.conf.max_width``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lines</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_pformat_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="p">,</span> <span class="n">max_width</span><span class="p">,</span> <span class="n">show_name</span><span class="o">=</span><span class="n">show_name</span><span class="p">,</span>
            <span class="n">show_unit</span><span class="o">=</span><span class="n">show_unit</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">,</span>
            <span class="n">tableid</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span> <span class="n">tableclass</span><span class="o">=</span><span class="n">tableclass</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outs</span><span class="p">[</span><span class="s1">&#39;show_length&#39;</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Length = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1"> rows&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lines</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pformat_docs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{id}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pformat_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tableclass</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of lines for the formatted string representation of</span>
<span class="sd">        the entire table.</span>

<span class="sd">        If no value of ``max_lines`` is supplied then the height of the</span>
<span class="sd">        screen terminal is used to set ``max_lines``.  If the terminal</span>
<span class="sd">        height cannot be determined then the default is taken from the</span>
<span class="sd">        configuration item ``astropy.conf.max_lines``.  If a negative</span>
<span class="sd">        value of ``max_lines`` is supplied then there is no line limit</span>
<span class="sd">        applied.</span>

<span class="sd">        The same applies for ``max_width`` except the configuration item  is</span>
<span class="sd">        ``astropy.conf.max_width``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">max_lines</span><span class="p">,</span> <span class="n">max_width</span><span class="p">,</span> <span class="n">show_name</span><span class="p">,</span>
                            <span class="n">show_unit</span><span class="p">,</span> <span class="n">show_dtype</span><span class="p">,</span> <span class="n">html</span><span class="p">,</span> <span class="n">tableid</span><span class="p">,</span>
                            <span class="n">align</span><span class="p">,</span> <span class="n">tableclass</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">more</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interactively browse table with a paging interface.</span>

<span class="sd">        Supported keys::</span>

<span class="sd">          f, &lt;space&gt; : forward one page</span>
<span class="sd">          b : back one page</span>
<span class="sd">          r : refresh same page</span>
<span class="sd">          n : next row</span>
<span class="sd">          p : previous row</span>
<span class="sd">          &lt; : go to beginning</span>
<span class="sd">          &gt; : go to end</span>
<span class="sd">          q : quit browsing</span>
<span class="sd">          h : print this help</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_lines : int</span>
<span class="sd">            Maximum number of lines in table output</span>

<span class="sd">        max_width : int or None</span>
<span class="sd">            Maximum character width of output</span>

<span class="sd">        show_name : bool</span>
<span class="sd">            Include a header row for column names. Default is True.</span>

<span class="sd">        show_unit : bool</span>
<span class="sd">            Include a header row for unit.  Default is to show a row</span>
<span class="sd">            for units only if one or more columns has a defined value</span>
<span class="sd">            for the unit.</span>

<span class="sd">        show_dtype : bool</span>
<span class="sd">            Include a header row for column dtypes. Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_more_tabcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="p">,</span> <span class="n">max_width</span><span class="p">,</span> <span class="n">show_name</span><span class="o">=</span><span class="n">show_name</span><span class="p">,</span>
                                    <span class="n">show_unit</span><span class="o">=</span><span class="n">show_unit</span><span class="p">,</span> <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">],</span>
                                 <span class="n">copy_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_copy_indices</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">TableGroups</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span>
                                             <span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Shallow copy for meta</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">elif</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
              <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">item</span><span class="p">)):</span>
            <span class="c1"># If item is an empty array/list/tuple then return the table with no rows</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_from_slice</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                                                 <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">)):</span>
            <span class="c1"># here for the many ways to give a slice; a tuple of ndarray</span>
            <span class="c1"># is produced by np.where, as in t[np.where(t[&#39;a&#39;] &gt; 2)]</span>
            <span class="c1"># For all, a new table is constructed with slice of all columns</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_from_slice</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Illegal type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s1"> for table item access&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># If the item is a string then it must be the name of a column.</span>
        <span class="c1"># If that column doesn&#39;t already exist then create it now.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># Set an existing column by first trying to replace, and if</span>
                <span class="c1"># this fails do an in-place update.  See definition of mask</span>
                <span class="c1"># property for discussion of the _setitem_inplace attribute.</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_setitem_inplace&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="n">conf</span><span class="o">.</span><span class="n">replace_inplace</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_column_warnings</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">item</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_row</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">item</span><span class="p">,</span> <span class="n">colnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
                  <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                  <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                  <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>  <span class="c1"># output from np.where</span>
                      <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">))):</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Assume this is an iterable that will work</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_cols</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Right side value needs </span><span class="si">{}</span><span class="s1"> elements (one for each column)&#39;</span>
                                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cols</span><span class="p">))</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">value</span>

                <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="n">col</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Illegal type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s1"> for table item access&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_row</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
              <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_columns</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
              <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;illegal key or index value&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ipython_key_completions_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>

    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return column[item] for recarray compatibility.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">masked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_masked</span>

    <span class="nd">@masked</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">masked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masked</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Masked attribute is read-only (use t = Table(t, masked=True)&#39;</span>
                        <span class="s1">&#39; to convert to a masked table)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masked</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the table masked property.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        masked : bool</span>
<span class="sd">            State of table masking (`True` or `False`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">masked</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_masked</span> <span class="o">=</span> <span class="n">masked</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;masked should be one of True, False, None&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_column_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_masked</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ColumnClass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_class</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([</span><span class="n">descr</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">colnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that ``names`` is a tuple or list of strings&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">names</span>
                <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">names</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># For performance reasons (esp. in Row) cache the first column name</span>
        <span class="c1"># and use that subsequently for the table length.  If might not be</span>
        <span class="c1"># available yet or the column might be gone now, in which case</span>
        <span class="c1"># try again in the except block.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_colname</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="c1"># Get the first column name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_colname</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_colname</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">index_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the positional index of column ``name``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            Positional index of column ``name``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Get index of column &#39;b&#39; of the table::</span>

<span class="sd">            &gt;&gt;&gt; t.index_column(&#39;b&#39;)</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rename_duplicate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">default_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new column to the table using ``col`` as input.  If ``index``</span>
<span class="sd">        is supplied then insert column before ``index`` position</span>
<span class="sd">        in the list of columns, otherwise append column to the end</span>
<span class="sd">        of the list.</span>

<span class="sd">        The ``col`` input can be any data object which is acceptable as a</span>
<span class="sd">        `~astropy.table.Table` column object or can be converted.  This includes</span>
<span class="sd">        mixin columns and scalar or length=1 objects which get broadcast to match</span>
<span class="sd">        the table length.</span>

<span class="sd">        To add several columns at once use ``add_columns()`` or simply call</span>
<span class="sd">        ``add_column()`` for each one.  There is very little performance difference</span>
<span class="sd">        in the two approaches.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        col : object</span>
<span class="sd">            Data object for the new column</span>
<span class="sd">        index : int or None</span>
<span class="sd">            Insert column before this position or at end (default).</span>
<span class="sd">        name : str</span>
<span class="sd">            Column name</span>
<span class="sd">        rename_duplicate : bool</span>
<span class="sd">            Uniquify column name if it already exist. Default is False.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make a copy of the new column. Default is True.</span>
<span class="sd">        default_name : str or None</span>
<span class="sd">            Name to use if both ``name`` and ``col.info.name`` are not available.</span>
<span class="sd">            Defaults to ``col{number_of_columns}``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with two columns &#39;a&#39; and &#39;b&#39;, then create a third column &#39;c&#39;</span>
<span class="sd">        and append it to the end of the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; col_c = Column(name=&#39;c&#39;, data=[&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_column(col_c)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>

<span class="sd">        Add column &#39;d&#39; at position 1. Note that the column is inserted</span>
<span class="sd">        before the given index::</span>

<span class="sd">            &gt;&gt;&gt; t.add_column([&#39;a&#39;, &#39;b&#39;], name=&#39;d&#39;, index=1)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   d   b   c</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              1   a 0.1   x</span>
<span class="sd">              2   b 0.2   y</span>

<span class="sd">        Add second column named &#39;b&#39; with rename_duplicate::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_column(1.1, name=&#39;b&#39;, rename_duplicate=True)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b  b_1</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1 1.1</span>
<span class="sd">              2 0.2 1.1</span>

<span class="sd">        Add an unnamed column or mixin object in the table using a default name</span>
<span class="sd">        or by specifying an explicit name with ``name``. Name can also be overridden::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_column([&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_column(col_c, name=&#39;d&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b  col2  d</span>
<span class="sd">            --- --- ---- ---</span>
<span class="sd">              1 0.1    a   x</span>
<span class="sd">              2 0.2    b   y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">default_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;col</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="c1"># Convert col data to acceptable object for insertion into self.columns.</span>
        <span class="c1"># Note that along with the lines above and below, this allows broadcasting</span>
        <span class="c1"># of scalars to the correct shape for adding to table.</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_data_to_col</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                        <span class="n">default_name</span><span class="o">=</span><span class="n">default_name</span><span class="p">)</span>

        <span class="c1"># Assigning a scalar column to an empty table should result in an</span>
        <span class="c1"># exception (see #3811).</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Empty table cannot have column set to scalar value&#39;</span><span class="p">)</span>
        <span class="c1"># Make col data shape correct for scalars.  The second test is to allow</span>
        <span class="c1"># broadcasting an N-d element to a column, e.g. t[&#39;new&#39;] = [[1, 2]].</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">or</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                      <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ShapedLikeNDArray</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                 <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># broadcast_to() results in a read-only array.  Apparently it only changes</span>
            <span class="c1"># the view to look like the broadcasted array.  So copy.</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col_copy</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># Ensure that new column is the right length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent data column lengths&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rename_duplicate</span><span class="p">:</span>
            <span class="n">orig_name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># Iterate until a unique name is found</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">orig_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Set col parent_table weakref and ensure col has mask attribute if table.masked</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Add new column as last column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Move the other cols to the right of the new one</span>
            <span class="n">move_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">move_name</span> <span class="ow">in</span> <span class="n">move_names</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">move_name</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rename_duplicate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a list of new columns the table using ``cols`` data objects.  If a</span>
<span class="sd">        corresponding list of ``indexes`` is supplied then insert column</span>
<span class="sd">        before each ``index`` position in the *original* list of columns,</span>
<span class="sd">        otherwise append columns to the end of the list.</span>

<span class="sd">        The ``cols`` input can include any data objects which are acceptable as</span>
<span class="sd">        `~astropy.table.Table` column objects or can be converted.  This includes</span>
<span class="sd">        mixin columns and scalar or length=1 objects which get broadcast to match</span>
<span class="sd">        the table length.</span>

<span class="sd">        From a performance perspective there is little difference between calling</span>
<span class="sd">        this method once or looping over the new columns and calling ``add_column()``</span>
<span class="sd">        for each column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cols : list of object</span>
<span class="sd">            List of data objects for the new columns</span>
<span class="sd">        indexes : list of int or None</span>
<span class="sd">            Insert column before this position or at end (default).</span>
<span class="sd">        names : list of str</span>
<span class="sd">            Column names</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make a copy of the new columns. Default is True.</span>
<span class="sd">        rename_duplicate : bool</span>
<span class="sd">            Uniquify new column names if they duplicate the existing ones.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        astropy.table.hstack, update, replace_column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with two columns &#39;a&#39; and &#39;b&#39;, then create columns &#39;c&#39; and &#39;d&#39;</span>
<span class="sd">        and append them to the end of the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; col_c = Column(name=&#39;c&#39;, data=[&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt; col_d = Column(name=&#39;d&#39;, data=[&#39;u&#39;, &#39;v&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([col_c, col_d])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c   d</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              1 0.1   x   u</span>
<span class="sd">              2 0.2   y   v</span>

<span class="sd">        Add column &#39;c&#39; at position 0 and column &#39;d&#39; at position 1. Note that</span>
<span class="sd">        the columns are inserted before the given position::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[&#39;x&#39;, &#39;y&#39;], [&#39;u&#39;, &#39;v&#39;]], names=[&#39;c&#39;, &#39;d&#39;],</span>
<span class="sd">            ...               indexes=[0, 1])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             c   a   d   b</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              x   1   u 0.1</span>
<span class="sd">              y   2   v 0.2</span>

<span class="sd">        Add second column &#39;b&#39; and column &#39;c&#39; with ``rename_duplicate``::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[1.1, 1.2], [&#39;x&#39;, &#39;y&#39;]], names=(&#39;b&#39;, &#39;c&#39;),</span>
<span class="sd">            ...               rename_duplicate=True)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b  b_1  c</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              1 0.1 1.1  x</span>
<span class="sd">              2 0.2 1.2  y</span>

<span class="sd">        Add unnamed columns or mixin objects in the table using default names</span>
<span class="sd">        or by specifying explicit names with ``names``. Names can also be overridden::</span>

<span class="sd">            &gt;&gt;&gt; t = Table()</span>
<span class="sd">            &gt;&gt;&gt; col_b = Column(name=&#39;b&#39;, data=[&#39;u&#39;, &#39;v&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[1, 2], col_b])</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[3, 4], col_b], names=[&#39;c&#39;, &#39;d&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            col0  b   c   d</span>
<span class="sd">            ---- --- --- ---</span>
<span class="sd">               1   u   3   u</span>
<span class="sd">               2   v   4   v</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of indexes must match number of cols&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of names must match number of cols&#39;</span><span class="p">)</span>

        <span class="n">default_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;col</span><span class="si">{</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                         <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">))]</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">indexes</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">names</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                            <span class="n">default_name</span><span class="o">=</span><span class="n">default_names</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                            <span class="n">rename_duplicate</span><span class="o">=</span><span class="n">rename_duplicate</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replace_column_warnings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as replace_column but issues warnings under various circumstances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warns</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">replace_warnings</span>
        <span class="n">refcount</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">old_col</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="s1">&#39;refcount&#39;</span> <span class="ow">in</span> <span class="n">warns</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">refcount</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">old_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># This may raise an exception (e.g. t[&#39;a&#39;] = 1) in which case none of</span>
        <span class="c1"># the downstream code runs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replace_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;always&#39;</span> <span class="ow">in</span> <span class="n">warns</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                          <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;slice&#39;</span> <span class="ow">in</span> <span class="n">warns</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Check for ndarray-subclass slice.  An unsliced instance</span>
                <span class="c1"># has an ndarray for the base while sliced has the same class</span>
                <span class="c1"># as parent.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_col</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">old_col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{}</span><span class="s2">&#39; which looks like an array slice. &quot;</span>
                           <span class="s2">&quot;The new column no longer shares memory with the &quot;</span>
                           <span class="s2">&quot;original array.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="s1">&#39;refcount&#39;</span> <span class="ow">in</span> <span class="n">warns</span><span class="p">:</span>
            <span class="c1"># Did reference count change?</span>
            <span class="n">new_refcount</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">refcount</span> <span class="o">!=</span> <span class="n">new_refcount</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{}</span><span class="s2">&#39; and the number of references &quot;</span>
                       <span class="s2">&quot;to the column changed.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;attributes&#39;</span> <span class="ow">in</span> <span class="n">warns</span><span class="p">:</span>
            <span class="c1"># Any of the standard column attributes changed?</span>
            <span class="n">changed_attrs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="c1"># Check base DataInfo attributes that any column will have</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">DataInfo</span><span class="o">.</span><span class="n">attr_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">new_col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">changed_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">changed_attrs</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{}</span><span class="s2">&#39; and column attributes </span><span class="si">{}</span><span class="s2"> changed.&quot;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">changed_attrs</span><span class="p">))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace column ``name`` with the new ``col`` object.</span>

<span class="sd">        The behavior of ``copy`` for Column objects is:</span>
<span class="sd">        - copy=True: new class instance with a copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: new class instance with same data and a key-only copy of meta</span>

<span class="sd">        For mixin columns:</span>
<span class="sd">        - copy=True: new class instance with copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: original instance (no copy at all)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of column to replace</span>
<span class="sd">        col : `~astropy.table.Column` or `~numpy.ndarray` or sequence</span>
<span class="sd">            New column object to replace the existing column.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make copy of the input ``col``, default=True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_columns, astropy.table.hstack, update</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Replace column &#39;a&#39; with a float version of itself::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; float_a = t[&#39;a&#39;].astype(float)</span>
<span class="sd">            &gt;&gt;&gt; t.replace_column(&#39;a&#39;, float_a)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;column name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> is not in the table&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot replace a table index column&#39;</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_data_to_col</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Ensure that new column is the right length, unless it is the only column</span>
        <span class="c1"># in which case re-sizing is allowed.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;length of new column must match table length&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">validated</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a row from the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            Index of row to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove row 1 from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_row(1)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        To remove several rows at the same time use remove_rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the index against the types that work with np.delete</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Row index must be an integer&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_specifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove rows from the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row_specifier : slice or int or array of int</span>
<span class="sd">            Specification for rows to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove rows 0 and 2 from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_rows([0, 2])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              2 0.2   y</span>


<span class="sd">        Note that there are no warnings if the slice operator extends</span>
<span class="sd">        outside the data::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.remove_rows(slice(10, 20, 1))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update indices</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">row_specifier</span><span class="p">)</span>

        <span class="n">keep_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">keep_mask</span><span class="p">[</span><span class="n">row_specifier</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">keep_mask</span><span class="p">]</span>
            <span class="n">newcol</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">newcol</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_cols</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Revert groups to default (ungrouped) state</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_groups&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span>

    <span class="k">def</span> <span class="nf">iterrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over rows of table returning a tuple of values for each row.</span>

<span class="sd">        This method is especially useful when only a subset of columns are needed.</span>

<span class="sd">        The ``iterrows`` method can be substantially faster than using the standard</span>
<span class="sd">        Table row iteration (e.g. ``for row in tbl:``), since that returns a new</span>
<span class="sd">        ``~astropy.table.Row`` object for each row and accessing a column in that</span>
<span class="sd">        row (e.g. ``row[&#39;col0&#39;]``) is slower than tuple access.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : list</span>
<span class="sd">            List of column names (default to all columns if no names provided)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rows : iterable</span>
<span class="sd">            Iterator returns tuples of row values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table({&#39;a&#39;: [1, 2, 3],</span>
<span class="sd">            ...            &#39;b&#39;: [1.0, 2.5, 3.0],</span>
<span class="sd">            ...            &#39;c&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>

<span class="sd">        To iterate row-wise using column names::</span>

<span class="sd">            &gt;&gt;&gt; for a, c in t.iterrows(&#39;a&#39;, &#39;c&#39;):</span>
<span class="sd">            ...     print(a, c)</span>
<span class="sd">            1 x</span>
<span class="sd">            2 y</span>
<span class="sd">            3 z</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> is not a valid column name&#39;</span><span class="p">)</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_set_of_names_in_colnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``names`` as a set if valid, or raise a `KeyError`.</span>

<span class="sd">        ``names`` is valid if all elements in it are in ``self.colnames``.</span>
<span class="sd">        If ``names`` is a string then it is interpreted as a single column</span>
<span class="sd">        name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">names</span><span class="p">}</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">invalid_names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">invalid_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;column &quot;</span><span class="si">{</span><span class="n">invalid_names</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="si">}</span><span class="s1">&quot; does not exist&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">invalid_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;columns </span><span class="si">{</span><span class="n">invalid_names</span><span class="si">}</span><span class="s1"> do not exist&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="k">def</span> <span class="nf">remove_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a column from the table.</span>

<span class="sd">        This can also be done with::</span>

<span class="sd">          del table[name]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of column to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove column &#39;b&#39; from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_column(&#39;b&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   c</span>
<span class="sd">            --- ---</span>
<span class="sd">              1   x</span>
<span class="sd">              2   y</span>
<span class="sd">              3   z</span>

<span class="sd">        To remove several columns at the same time use remove_columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_columns</span><span class="p">([</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">remove_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Remove several columns from the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str or iterable of str</span>
<span class="sd">            Names of the columns to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...     names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove columns &#39;b&#39; and &#39;c&#39; from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_columns([&#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a</span>
<span class="sd">            ---</span>
<span class="sd">              1</span>
<span class="sd">              2</span>
<span class="sd">              3</span>

<span class="sd">        Specifying only a single column also works. Remove column &#39;b&#39; from the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...     names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.remove_columns(&#39;b&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   c</span>
<span class="sd">            --- ---</span>
<span class="sd">              1   x</span>
<span class="sd">              2   y</span>
<span class="sd">              3   z</span>

<span class="sd">        This gives the same as using remove_column.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_of_names_in_colnames</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_string_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_kind</span><span class="p">,</span> <span class="n">out_kind</span><span class="p">,</span> <span class="n">encode_decode_func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert string-like columns to/from bytestring and unicode (internal only).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_kind : str</span>
<span class="sd">            Input dtype.kind</span>
<span class="sd">        out_kind : str</span>
<span class="sd">            Output dtype.kind</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">in_kind</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># This requires ASCII and is faster by a factor of up to ~8, so</span>
                    <span class="c1"># try that first.</span>
                    <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_kind</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeEncodeError</span><span class="p">,</span> <span class="ne">UnicodeDecodeError</span><span class="p">):</span>
                    <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">encode_decode_func</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>

                    <span class="c1"># Quasi-manually copy info attributes.  Unfortunately</span>
                    <span class="c1"># DataInfo.__set__ does not do the right thing in this case</span>
                    <span class="c1"># so newcol.info = col.info does not get the old info attributes.</span>
                    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">attr_names</span> <span class="o">-</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">_attrs_no_copy</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;dtype&#39;</span><span class="p">]):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">newcol</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">newcol</span>

    <span class="k">def</span> <span class="nf">convert_bytestring_to_unicode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert bytestring columns (dtype.kind=&#39;S&#39;) to unicode (dtype.kind=&#39;U&#39;)</span>
<span class="sd">        using UTF-8 encoding.</span>

<span class="sd">        Internally this changes string columns to represent each character</span>
<span class="sd">        in the string with a 4-byte UCS-4 equivalent, so it is inefficient</span>
<span class="sd">        for memory but allows scripts to manipulate string arrays with</span>
<span class="sd">        natural syntax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_string_dtype</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">decode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_unicode_to_bytestring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert unicode columns (dtype.kind=&#39;U&#39;) to bytestring (dtype.kind=&#39;S&#39;)</span>
<span class="sd">        using UTF-8 encoding.</span>

<span class="sd">        When exporting a unicode string array to a file, it may be desirable</span>
<span class="sd">        to encode unicode columns as bytestrings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_string_dtype</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">encode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keep_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Keep only the columns specified (remove the others).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str or iterable of str</span>
<span class="sd">            The columns to keep. All other columns will be removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3],[0.1, 0.2, 0.3],[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Keep only column &#39;a&#39; of the table::</span>

<span class="sd">            &gt;&gt;&gt; t.keep_columns(&#39;a&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a</span>
<span class="sd">            ---</span>
<span class="sd">              1</span>
<span class="sd">              2</span>
<span class="sd">              3</span>

<span class="sd">        Keep columns &#39;a&#39; and &#39;c&#39; of the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3],[0.1, 0.2, 0.3],[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.keep_columns([&#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   c</span>
<span class="sd">            --- ---</span>
<span class="sd">              1   x</span>
<span class="sd">              2   y</span>
<span class="sd">              3   z</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_of_names_in_colnames</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">colname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Rename a column.</span>

<span class="sd">        This can also be done directly with by setting the ``name`` attribute</span>
<span class="sd">        for a column::</span>

<span class="sd">          table[name].name = new_name</span>

<span class="sd">        TODO: this won&#39;t work for mixins</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The current name of the column.</span>
<span class="sd">        new_name : str</span>
<span class="sd">            The new name for the column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1,2],[3,4],[5,6]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>

<span class="sd">        Renaming column &#39;a&#39; to &#39;aa&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t.rename_column(&#39;a&#39; , &#39;aa&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             aa  b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>

    <span class="k">def</span> <span class="nf">rename_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">new_names</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Rename multiple columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : list, tuple</span>
<span class="sd">            A list or tuple of existing column names.</span>
<span class="sd">        new_names : list, tuple</span>
<span class="sd">            A list or tuple of new column names.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39;, &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1,2],[3,4],[5,6]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">              a   b   c</span>
<span class="sd">             --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>

<span class="sd">        Renaming columns &#39;a&#39; to &#39;aa&#39; and &#39;b&#39; to &#39;bb&#39;::</span>

<span class="sd">            &gt;&gt;&gt; names = (&#39;a&#39;,&#39;b&#39;)</span>
<span class="sd">            &gt;&gt;&gt; new_names = (&#39;aa&#39;,&#39;bb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; t.rename_columns(names, new_names)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             aa  bb   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input &#39;names&#39; must be a tuple or a list of column names&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">new_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input &#39;new_names&#39; must be a tuple or a list of column names&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input &#39;names&#39; and &#39;new_names&#39; list arguments must be the same length&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">new_names</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rename_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">colnames</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">colnames</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;right hand side must be a sequence of values with &#39;</span>
                             <span class="s1">&#39;the same length as the number of selected columns&#39;</span><span class="p">)</span>

        <span class="c1"># Keep track of original values before setting each column so that</span>
        <span class="c1"># setting row can be transactional.</span>
        <span class="n">orig_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
                <span class="n">orig_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If anything went wrong first revert the row update then raise</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="n">orig_vals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new row to the end of the table.</span>

<span class="sd">        The ``vals`` argument can be:</span>

<span class="sd">        sequence (e.g. tuple or list)</span>
<span class="sd">            Column values in the same order as table columns.</span>
<span class="sd">        mapping (e.g. dict)</span>
<span class="sd">            Keys corresponding to column names.  Missing values will be</span>
<span class="sd">            filled with np.zeros for the column dtype.</span>
<span class="sd">        `None`</span>
<span class="sd">            All values filled with np.zeros for the column dtype.</span>

<span class="sd">        This method requires that the Table object &quot;owns&quot; the underlying array</span>
<span class="sd">        data.  In particular one cannot add a row to a Table that was</span>
<span class="sd">        initialized with copy=False from an existing array.</span>

<span class="sd">        The ``mask`` attribute should give (if desired) the mask for the</span>
<span class="sd">        values. The type of the mask should match that of the values, i.e. if</span>
<span class="sd">        ``vals`` is an iterable, then ``mask`` should also be an iterable</span>
<span class="sd">        with the same length, and if ``vals`` is a mapping, then ``mask``</span>
<span class="sd">        should be a dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vals : tuple, list, dict or None</span>
<span class="sd">            Use the specified values in the new row</span>
<span class="sd">        mask : tuple, list, dict or None</span>
<span class="sd">            Use the specified mask values in the new row</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">           &gt;&gt;&gt; t = Table([[1,2],[4,5],[7,8]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">           &gt;&gt;&gt; print(t)</span>
<span class="sd">            a   b   c</span>
<span class="sd">           --- --- ---</span>
<span class="sd">             1   4   7</span>
<span class="sd">             2   5   8</span>

<span class="sd">        Adding a new row with entries &#39;3&#39; in &#39;a&#39;, &#39;6&#39; in &#39;b&#39; and &#39;9&#39; in &#39;c&#39;::</span>

<span class="sd">           &gt;&gt;&gt; t.add_row([3,6,9])</span>
<span class="sd">           &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">             --- --- ---</span>
<span class="sd">             1   4   7</span>
<span class="sd">             2   5   8</span>
<span class="sd">             3   6   9</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_row</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">vals</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new row before the given ``index`` position in the table.</span>

<span class="sd">        The ``vals`` argument can be:</span>

<span class="sd">        sequence (e.g. tuple or list)</span>
<span class="sd">            Column values in the same order as table columns.</span>
<span class="sd">        mapping (e.g. dict)</span>
<span class="sd">            Keys corresponding to column names.  Missing values will be</span>
<span class="sd">            filled with np.zeros for the column dtype.</span>
<span class="sd">        `None`</span>
<span class="sd">            All values filled with np.zeros for the column dtype.</span>

<span class="sd">        The ``mask`` attribute should give (if desired) the mask for the</span>
<span class="sd">        values. The type of the mask should match that of the values, i.e. if</span>
<span class="sd">        ``vals`` is an iterable, then ``mask`` should also be an iterable</span>
<span class="sd">        with the same length, and if ``vals`` is a mapping, then ``mask``</span>
<span class="sd">        should be a dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vals : tuple, list, dict or None</span>
<span class="sd">            Use the specified values in the new row</span>
<span class="sd">        mask : tuple, list, dict or None</span>
<span class="sd">            Use the specified mask values in the new row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">colnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index </span><span class="si">{}</span><span class="s2"> is out of bounds for table with length </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">N</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span> <span class="ow">or</span> <span class="n">vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># From the vals and/or mask mappings create the corresponding lists</span>
            <span class="c1"># that have entries for each table column.</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mismatch between type of vals and mask&quot;</span><span class="p">)</span>

            <span class="c1"># Now check that the mask is specified for the same keys as the</span>
            <span class="c1"># values, otherwise things get really confusing.</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;keys in mask should match keys in vals&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">vals</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">colnames</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Keys in vals must all be valid column names&#39;</span><span class="p">)</span>

            <span class="n">vals_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mask_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vals</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
                    <span class="n">vals_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="n">mask_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
                        <span class="c1"># Make a placeholder zero element of the right type which is masked.</span>
                        <span class="c1"># This assumes the appropriate insert() method will broadcast a</span>
                        <span class="c1"># numpy scalar to the right shape.</span>
                        <span class="n">vals_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

                        <span class="c1"># For masked table any unsupplied values are masked by default.</span>
                        <span class="n">mask_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value must be supplied for column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals_list</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_list</span>

        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mismatch between type of vals and mask&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatch between number of vals and columns&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatch between number of masks and columns&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Vals must be an iterable or mapping or None&#39;</span><span class="p">)</span>

        <span class="c1"># Insert val at index for each column</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">mask_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">vals</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If new val is masked and the existing column does not support masking</span>
                <span class="c1"># then upgrade the column to a mask-enabled type: either the table-level</span>
                <span class="c1"># default ColumnClass or else MaskedColumn.</span>
                <span class="k">if</span> <span class="n">mask_</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">):</span>
                    <span class="n">col_cls</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>
                               <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">)</span>
                               <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">)</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">col_cls</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newcol</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect length for column </span><span class="si">{}</span><span class="s1"> after inserting </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39; (expected </span><span class="si">{}</span><span class="s1">, got </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newcol</span><span class="p">),</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">newcol</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>

                <span class="c1"># Set mask if needed and possible</span>
                <span class="k">if</span> <span class="n">mask_</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">newcol</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
                        <span class="n">newcol</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mask was supplied for column &#39;</span><span class="si">{}</span><span class="s2">&#39; but it does not &quot;</span>
                                        <span class="s2">&quot;support masked values&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">newcol</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to insert row because of exception in column &#39;</span><span class="si">{}</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">for</span> <span class="n">table_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="n">table_index</span><span class="o">.</span><span class="n">insert_row</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_cols</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Revert groups to default (ungrouped) state</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_groups&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span>

    <span class="k">def</span> <span class="nf">_replace_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">new_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">new_col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">col_position</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_col</span>
                <span class="n">new_col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a dictionary-style update and merge metadata.</span>

<span class="sd">        The argument ``other`` must be a |Table|, or something that can be used</span>
<span class="sd">        to initialize a table. Columns from (possibly converted) ``other`` are</span>
<span class="sd">        added to this table. In case of matching column names the column from</span>
<span class="sd">        this table is replaced with the one from ``other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : table-like</span>
<span class="sd">            Data to update this table with.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Whether the updated columns should be copies of or references to</span>
<span class="sd">            the originals.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_columns, astropy.table.hstack, replace_column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Update a table with another table::</span>

<span class="sd">            &gt;&gt;&gt; t1 = Table({&#39;a&#39;: [&#39;foo&#39;, &#39;bar&#39;], &#39;b&#39;: [0., 0.]}, meta={&#39;i&#39;: 0})</span>
<span class="sd">            &gt;&gt;&gt; t2 = Table({&#39;b&#39;: [1., 2.], &#39;c&#39;: [7., 11.]}, meta={&#39;n&#39;: 2})</span>
<span class="sd">            &gt;&gt;&gt; t1.update(t2)</span>
<span class="sd">            &gt;&gt;&gt; t1</span>
<span class="sd">            &lt;Table length=2&gt;</span>
<span class="sd">             a      b       c</span>
<span class="sd">            str3 float64 float64</span>
<span class="sd">            ---- ------- -------</span>
<span class="sd">             foo     1.0     7.0</span>
<span class="sd">             bar     2.0    11.0</span>
<span class="sd">            &gt;&gt;&gt; t1.meta</span>
<span class="sd">            {&#39;i&#39;: 0, &#39;n&#39;: 2}</span>

<span class="sd">        Update a table with a dictionary::</span>

<span class="sd">            &gt;&gt;&gt; t = Table({&#39;a&#39;: [&#39;foo&#39;, &#39;bar&#39;], &#39;b&#39;: [0., 0.]})</span>
<span class="sd">            &gt;&gt;&gt; t.update({&#39;b&#39;: [1., 2.]})</span>
<span class="sd">            &gt;&gt;&gt; t</span>
<span class="sd">            &lt;Table length=2&gt;</span>
<span class="sd">             a      b</span>
<span class="sd">            str3 float64</span>
<span class="sd">            ---- -------</span>
<span class="sd">             foo     1.0</span>
<span class="sd">             bar     2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.operations</span> <span class="kn">import</span> <span class="n">_merge_table_meta</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">common_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">common_cols</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replace_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">_merge_table_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">metadata_conflicts</span><span class="o">=</span><span class="s1">&#39;silent&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices which would sort the table according to one or</span>
<span class="sd">        more key columns.  This simply calls the `numpy.argsort` function on</span>
<span class="sd">        the table with the ``order`` parameter set to ``keys``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : str or list of str</span>
<span class="sd">            The column name(s) to order the table by</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span>
<span class="sd">            Sorting algorithm used by ``numpy.argsort``.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Sort in reverse order (default=False)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index_array : ndarray, int</span>
<span class="sd">            Array of indices that sorts the table by the specified key</span>
<span class="sd">            column(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span>

        <span class="c1"># use index sorted order if possible</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">sorted_data</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">idx</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">keys</span><span class="p">:</span>
            <span class="c1"># For multiple keys return a structured array which gets sorted,</span>
            <span class="c1"># while for a single key return a single ndarray.  Sorting a</span>
            <span class="c1"># one-column structured array is slower than ndarray (e.g. a</span>
            <span class="c1"># factor of ~6 for a 10 million long random array), and much slower</span>
            <span class="c1"># for in principle sortable columns like Time, which get stored as</span>
            <span class="c1"># object arrays.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No keys provided so sort on all columns.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kind</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>

        <span class="c1"># np.argsort will look for a possible .argsort method (e.g., for Time),</span>
        <span class="c1"># and if that fails cast to an array and try sorting that way.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sort the table according to one or more keys. This operates</span>
<span class="sd">        on the existing table and does not return a new table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : str or list of str</span>
<span class="sd">            The key(s) to order the table by. If None, use the</span>
<span class="sd">            primary index of the Table.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span>
<span class="sd">            Sorting algorithm used by ``numpy.argsort``.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Sort in reverse order (default=False)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with 3 columns::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[&#39;Max&#39;, &#39;Jo&#39;, &#39;John&#39;], [&#39;Miller&#39;, &#39;Miller&#39;, &#39;Jackson&#39;],</span>
<span class="sd">            ...            [12, 15, 18]], names=(&#39;firstname&#39;, &#39;name&#39;, &#39;tel&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                 John Jackson  18</span>

<span class="sd">        Sorting according to standard sorting rules, first &#39;name&#39; then &#39;firstname&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t.sort([&#39;name&#39;, &#39;firstname&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                 John Jackson  18</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                  Max  Miller  12</span>

<span class="sd">        Sorting according to standard sorting rules, first &#39;firstname&#39; then &#39;tel&#39;,</span>
<span class="sd">        in reverse order::</span>

<span class="sd">            &gt;&gt;&gt; t.sort([&#39;firstname&#39;, &#39;tel&#39;], reverse=True)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">                 John Jackson  18</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Table sort requires input keys or a table index&quot;</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_mode</span><span class="p">(</span><span class="s1">&#39;freeze&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Make a new sorted column.  This requires that take() also copies</span>
                <span class="c1"># relevant info attributes for mixin columns.</span>
                <span class="n">new_col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># First statement in try: will succeed if the column supports an in-place</span>
                <span class="c1"># update, and matches the legacy behavior of astropy Table.  However,</span>
                <span class="c1"># some mixin classes may not support this, so in that case just drop</span>
                <span class="c1"># in the entire new column. See #9553 and #9536 for discussion.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">col</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_col</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># In-place update failed for some reason, exception class not</span>
                    <span class="c1"># predictable for arbitrary mixin.</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col</span>

    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reverse the row order of table rows.  The table is reversed</span>
<span class="sd">        in place and there are no function arguments.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[&#39;Max&#39;, &#39;Jo&#39;, &#39;John&#39;], [&#39;Miller&#39;,&#39;Miller&#39;,&#39;Jackson&#39;],</span>
<span class="sd">            ...         [12,15,18]], names=(&#39;firstname&#39;,&#39;name&#39;,&#39;tel&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                 John Jackson  18</span>

<span class="sd">        Reversing order::</span>

<span class="sd">            &gt;&gt;&gt; t.reverse()</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                 John Jackson  18</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># First statement in try: will succeed if the column supports an in-place</span>
            <span class="c1"># update, and matches the legacy behavior of astropy Table.  However,</span>
            <span class="c1"># some mixin classes may not support this, so in that case just drop</span>
            <span class="c1"># in the entire new column. See #9836, #9553, and #9536 for discussion.</span>
            <span class="n">new_col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">col</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_col</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># In-place update failed for some reason, exception class not</span>
                <span class="c1"># predictable for arbitrary mixin.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Round numeric columns in-place to the specified number of decimals.</span>
<span class="sd">        Non-numeric columns will be ignored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create three columns with different types:</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 4, 5], [-25.55, 12.123, 85],</span>
<span class="sd">            ...     [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]], names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a    b     c</span>
<span class="sd">            --- ------ ---</span>
<span class="sd">              1 -25.55   a</span>
<span class="sd">              4 12.123   b</span>
<span class="sd">              5   85.0   c</span>

<span class="sd">        Round them all to 0:</span>

<span class="sd">            &gt;&gt;&gt; t.round(0)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a    b    c</span>
<span class="sd">            --- ----- ---</span>
<span class="sd">              1 -26.0   a</span>
<span class="sd">              4  12.0   b</span>
<span class="sd">              5  85.0   c</span>

<span class="sd">        Round column &#39;a&#39; to -1 decimal:</span>

<span class="sd">            &gt;&gt;&gt; t.round({&#39;a&#39;:-1})</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a    b    c</span>
<span class="sd">            --- ----- ---</span>
<span class="sd">              0 -26.0   a</span>
<span class="sd">              0  12.0   b</span>
<span class="sd">              0  85.0   c</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decimals: int, dict</span>
<span class="sd">            Number of decimals to round the columns to. If a dict is given,</span>
<span class="sd">            the columns will be rounded to the number specified as the value.</span>
<span class="sd">            If a certain column is not in the dict given, it will remain the</span>
<span class="sd">            same.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">decimal_values</span> <span class="o">=</span> <span class="n">decimals</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="n">decimals</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">decimal_values</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;decimals&#39; argument must be an int or a dict&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">colname</span><span class="p">,</span> <span class="n">decimal</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">decimal_values</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># Bug in numpy see https://github.com/numpy/numpy/issues/15438</span>
                    <span class="n">col</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a copy of the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy_data : bool</span>
<span class="sd">            If `True` (the default), copy the underlying data array.</span>
<span class="sd">            Otherwise, use the same data array. The ``meta`` is always</span>
<span class="sd">            deepcopied regardless of the value for ``copy_data``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy_data</span><span class="p">)</span>

        <span class="c1"># If the current table is grouped then do the same in the copy</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_groups&#39;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">TableGroups</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span>
                                             <span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__le__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__ge__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rows_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rows_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Row-wise comparison of table with any other object.</span>

<span class="sd">        This is actual implementation for __eq__.</span>

<span class="sd">        Returns a 1-D boolean numpy array showing result of row-wise comparison.</span>
<span class="sd">        This is the same as the ``==`` comparison for tables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Table or DataFrame or ndarray</span>
<span class="sd">             An object to compare with table</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Comparing one Table with other::</span>

<span class="sd">            &gt;&gt;&gt; t1 = Table([[1,2],[4,5],[7,8]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t2 = Table([[1,2],[4,5],[7,8]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t1._rows_equal(t2)</span>
<span class="sd">            array([ True,  True])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If mask is True, then by definition the row doesn&#39;t match</span>
                <span class="c1"># because the other array is not masked.</span>
                <span class="n">false_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="n">false_mask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="c1"># If mask is True, then by definition the row doesn&#39;t match</span>
                <span class="c1"># because the other array is not masked.</span>
                <span class="n">false_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="n">false_mask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">values_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise comparison of table with another table, list, or scalar.</span>

<span class="sd">        Returns a ``Table`` with the same columns containing boolean values</span>
<span class="sd">        showing result of comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : table-like object or list or scalar</span>
<span class="sd">             Object to compare with table</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compare one Table with other::</span>

<span class="sd">          &gt;&gt;&gt; t1 = Table([[1, 2], [4, 5], [-7, 8]], names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">          &gt;&gt;&gt; t2 = Table([[1, 2], [-4, 5], [7, 8]], names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">          &gt;&gt;&gt; t1.values_equal(t2)</span>
<span class="sd">          &lt;Table length=2&gt;</span>
<span class="sd">           a     b     c</span>
<span class="sd">          bool  bool  bool</span>
<span class="sd">          ---- ----- -----</span>
<span class="sd">          True False False</span>
<span class="sd">          True  True  True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">colnames</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Broadcast other into a dict, so e.g. other = 2 will turn into</span>
                <span class="c1"># other = {&#39;a&#39;: 2, &#39;b&#39;: 2} and then equality does a</span>
                <span class="c1"># column-by-column broadcasting.</span>
                <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">other</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>

        <span class="c1"># Require column names match but do not require same column order</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot compare tables with different column names&#39;</span><span class="p">)</span>

        <span class="n">eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>  <span class="c1"># Check if broadcast-able</span>
                <span class="c1"># Catch the numpy FutureWarning related to equality checking,</span>
                <span class="c1"># &quot;elementwise comparison failed; returning scalar instead, but</span>
                <span class="c1">#  in the future will perform elementwise comparison&quot;.  Turn this</span>
                <span class="c1"># into an exception since the scalar answer is not what we want.</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">warns</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;always&#39;</span><span class="p">)</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">warns</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">warns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="s1">&#39;elementwise comparison failed&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">warns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)):</span>
                        <span class="k">raise</span> <span class="ne">FutureWarning</span><span class="p">(</span><span class="n">warns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unable to compare column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># Be strict about the result from the comparison. E.g. SkyCoord __eq__ is just</span>
            <span class="c1"># broken and completely ignores that it should return an array.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">eq</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;comparison for column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> returned </span><span class="si">{</span><span class="n">eq</span><span class="si">}</span><span class="s1"> &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;instead of the expected boolean ndarray&#39;</span><span class="p">)</span>

            <span class="n">eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_groups&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">TableGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span>

    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group this table by the specified ``keys``</span>

<span class="sd">        This effectively splits the table into groups which correspond to unique</span>
<span class="sd">        values of the ``keys`` grouping object.  The output is a new</span>
<span class="sd">        `~astropy.table.TableGroups` which contains a copy of this table but</span>
<span class="sd">        sorted by row according to ``keys``.</span>

<span class="sd">        The ``keys`` input to `group_by` can be specified in different ways:</span>

<span class="sd">          - String or list of strings corresponding to table column name(s)</span>
<span class="sd">          - Numpy array (homogeneous or structured) with same length as this table</span>
<span class="sd">          - `~astropy.table.Table` with same length as this table</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : str, list of str, numpy array, or `~astropy.table.Table`</span>
<span class="sd">            Key grouping object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.table.Table`</span>
<span class="sd">            New table with groups set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">groups</span><span class="o">.</span><span class="n">table_group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_nullable_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :class:`pandas.DataFrame` instance</span>

<span class="sd">        The index of the created DataFrame is controlled by the ``index``</span>
<span class="sd">        argument.  For ``index=True`` or the default ``None``, an index will be</span>
<span class="sd">        specified for the DataFrame if there is a primary key index on the</span>
<span class="sd">        Table *and* if it corresponds to a single column.  If ``index=False``</span>
<span class="sd">        then no DataFrame index will be specified.  If ``index`` is the name of</span>
<span class="sd">        a column in the table then that will be the DataFrame index.</span>

<span class="sd">        In addition to vanilla columns or masked columns, this supports Table</span>
<span class="sd">        mixin columns like Quantity, Time, or SkyCoord.  In many cases these</span>
<span class="sd">        objects have no analog in pandas and will be converted to a &quot;encoded&quot;</span>
<span class="sd">        representation using only Column or MaskedColumn.  The exception is</span>
<span class="sd">        Time or TimeDelta columns, which will be converted to the corresponding</span>
<span class="sd">        representation in pandas using ``np.datetime64`` or ``np.timedelta64``.</span>
<span class="sd">        See the example below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : None, bool, str</span>
<span class="sd">            Specify DataFrame index mode</span>
<span class="sd">        use_nullable_int : bool, default=True</span>
<span class="sd">            Convert integer MaskedColumn to pandas nullable integer type.</span>
<span class="sd">            If ``use_nullable_int=False`` or the pandas version does not support</span>
<span class="sd">            nullable integer types (version &lt; 0.24), then the column is converted</span>
<span class="sd">            to float with NaN for missing elements and a warning is issued.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dataframe : :class:`pandas.DataFrame`</span>
<span class="sd">            A pandas :class:`pandas.DataFrame` instance</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If pandas is not installed</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the Table has multi-dimensional columns</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here we convert a table with a few mixins to a</span>
<span class="sd">        :class:`pandas.DataFrame` instance.</span>

<span class="sd">          &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">          &gt;&gt;&gt; from astropy.table import QTable</span>
<span class="sd">          &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">          &gt;&gt;&gt; from astropy.time import Time, TimeDelta</span>
<span class="sd">          &gt;&gt;&gt; from astropy.coordinates import SkyCoord</span>

<span class="sd">          &gt;&gt;&gt; q = [1, 2] * u.m</span>
<span class="sd">          &gt;&gt;&gt; tm = Time([1998, 2002], format=&#39;jyear&#39;)</span>
<span class="sd">          &gt;&gt;&gt; sc = SkyCoord([5, 6], [7, 8], unit=&#39;deg&#39;)</span>
<span class="sd">          &gt;&gt;&gt; dt = TimeDelta([3, 200] * u.s)</span>

<span class="sd">          &gt;&gt;&gt; t = QTable([q, tm, sc, dt], names=[&#39;q&#39;, &#39;tm&#39;, &#39;sc&#39;, &#39;dt&#39;])</span>

<span class="sd">          &gt;&gt;&gt; df = t.to_pandas(index=&#39;tm&#39;)</span>
<span class="sd">          &gt;&gt;&gt; with pd.option_context(&#39;display.max_columns&#39;, 20):</span>
<span class="sd">          ...     print(df)</span>
<span class="sd">                        q  sc.ra  sc.dec              dt</span>
<span class="sd">          tm</span>
<span class="sd">          1998-01-01  1.0    5.0     7.0 0 days 00:00:03</span>
<span class="sd">          2002-01-01  2.0    6.0     8.0 0 days 00:03:20</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="c1"># Default is to use the table primary key if available and a single column</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;index must be None, False, True or a table &#39;</span>
                                     <span class="s1">&#39;column name&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_encode_mixins</span><span class="p">(</span><span class="n">tbl</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Encode a Table ``tbl`` that may have mixin columns to a Table with only</span>
<span class="sd">            astropy Columns + appropriate meta-data to allow subsequent decoding.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">serialize</span>
            <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeBase</span><span class="p">,</span> <span class="n">TimeDelta</span>

            <span class="c1"># Convert any Time or TimeDelta columns and pay attention to masking</span>
            <span class="n">time_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">itercols</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">TimeBase</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">time_cols</span><span class="p">:</span>

                <span class="c1"># Make a light copy of table and clear any indices</span>
                <span class="n">new_cols</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
                    <span class="n">new_col</span> <span class="o">=</span> <span class="n">col_copy</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="k">else</span> <span class="n">col</span>
                    <span class="n">new_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_col</span><span class="p">)</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_cols</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Certain subclasses (e.g. TimeSeries) may generate new indices on</span>
                <span class="c1"># table creation, so make sure there are no indices on the table.</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">time_cols</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">):</span>
                        <span class="c1"># Convert to nanoseconds (matches astropy datetime64 support)</span>
                        <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">sec</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">)</span>
                        <span class="n">nat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="s1">&#39;NaT&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">datetime64</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">nat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;NaT&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
                        <span class="n">new_col</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">nat</span>
                    <span class="n">tbl</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col</span>

            <span class="c1"># Convert the table to one with no mixins, only Column objects.</span>
            <span class="n">encode_tbl</span> <span class="o">=</span> <span class="n">serialize</span><span class="o">.</span><span class="n">represent_mixins_as_columns</span><span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">encode_tbl</span>

        <span class="n">tbl</span> <span class="o">=</span> <span class="n">_encode_mixins</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">badcols</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">badcols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Cannot convert a table with multidimensional columns to a &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;pandas DataFrame. Offending columns are: </span><span class="si">{</span><span class="n">badcols</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;One can filter out such columns using:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;names = [name for name in tbl.colnames if len(tbl[name].shape) &lt;= 1]</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;tbl[names].to_pandas(...)&#39;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;isnative&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">mask</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">]:</span>
                    <span class="n">pd_dtype</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">if</span> <span class="n">use_nullable_int</span><span class="p">:</span>
                        <span class="c1"># Convert int64 to Int64, uint32 to UInt32, etc for nullable types</span>
                        <span class="n">pd_dtype</span> <span class="o">=</span> <span class="n">pd_dtype</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pd_dtype</span><span class="p">)</span>

                    <span class="c1"># If pandas is older than 0.24 the type may have turned to float</span>
                    <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;converted column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; from </span><span class="si">{</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

            <span class="c1"># We add the table index to Series inputs (MaskedColumn with int values) to override</span>
            <span class="c1"># its default RangeIndex, see #11432</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="c1"># Explicitly set the pandas DataFrame index to the original table</span>
            <span class="c1"># index name.</span>
            <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pandas</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a `~astropy.table.Table` from a :class:`pandas.DataFrame` instance</span>

<span class="sd">        In addition to converting generic numeric or string columns, this supports</span>
<span class="sd">        conversion of pandas Date and Time delta columns to `~astropy.time.Time`</span>
<span class="sd">        and `~astropy.time.TimeDelta` columns, respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : :class:`pandas.DataFrame`</span>
<span class="sd">            A pandas :class:`pandas.DataFrame` instance</span>
<span class="sd">        index : bool</span>
<span class="sd">            Include the index column in the returned table (default=False)</span>
<span class="sd">        units: dict</span>
<span class="sd">            A dict mapping column names to to a `~astropy.units.Unit`.</span>
<span class="sd">            The columns will have the specified unit in the Table.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        table : `~astropy.table.Table`</span>
<span class="sd">            A `~astropy.table.Table` (or subclass) instance</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If pandas is not installed</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here we convert a :class:`pandas.DataFrame` instance</span>
<span class="sd">        to a `~astropy.table.QTable`.</span>

<span class="sd">          &gt;&gt;&gt; import numpy as np</span>
<span class="sd">          &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">          &gt;&gt;&gt; from astropy.table import QTable</span>

<span class="sd">          &gt;&gt;&gt; time = pd.Series([&#39;1998-01-01&#39;, &#39;2002-01-01&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
<span class="sd">          &gt;&gt;&gt; dt = pd.Series(np.array([1, 300], dtype=&#39;timedelta64[s]&#39;))</span>
<span class="sd">          &gt;&gt;&gt; df = pd.DataFrame({&#39;time&#39;: time})</span>
<span class="sd">          &gt;&gt;&gt; df[&#39;dt&#39;] = dt</span>
<span class="sd">          &gt;&gt;&gt; df[&#39;x&#39;] = [3., 4.]</span>
<span class="sd">          &gt;&gt;&gt; with pd.option_context(&#39;display.max_columns&#39;, 20):</span>
<span class="sd">          ...     print(df)</span>
<span class="sd">                  time              dt    x</span>
<span class="sd">          0 1998-01-01 0 days 00:00:01  3.0</span>
<span class="sd">          1 2002-01-01 0 days 00:05:00  4.0</span>

<span class="sd">          &gt;&gt;&gt; QTable.from_pandas(df)</span>
<span class="sd">          &lt;QTable length=2&gt;</span>
<span class="sd">                    time              dt       x</span>
<span class="sd">                    Time          TimeDelta float64</span>
<span class="sd">          ----------------------- --------- -------</span>
<span class="sd">          1998-01-01T00:00:00.000       1.0     3.0</span>
<span class="sd">          2002-01-01T00:00:00.000     300.0     4.0</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataframe</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="n">datas</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">index_name</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;index&#39;</span>
            <span class="k">while</span> <span class="n">index_name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">index_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">index_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span>
            <span class="n">names</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_name</span><span class="p">)</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">datas</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
            <span class="n">masks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataframe</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a Mapping &quot;column-name&quot; -&gt; &quot;unit&quot;&#39;</span><span class="p">)</span>

            <span class="n">not_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">not_found</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`units` contains additional columns: </span><span class="si">{</span><span class="n">not_found</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">datas</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="c1"># Special-case support for pandas nullable int</span>
                <span class="n">np_dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">column</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np_dtype</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">MaskedColumn</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="c1"># If all elements of an object array are string-like or np.nan</span>
                <span class="c1"># then coerce back to a native numpy str/unicode array.</span>
                <span class="n">string_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
                <span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">nan</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">):</span>
                    <span class="c1"># Force any missing (null) values to b&#39;&#39;.  Numpy will</span>
                    <span class="c1"># upcast to str/unicode as needed.</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

                    <span class="c1"># When the numpy object array is represented as a list then</span>
                    <span class="c1"># numpy initializes to the correct string or unicode type.</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>

            <span class="c1"># Numpy datetime64</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">Time</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;isot&#39;</span>

            <span class="c1"># Numpy timedelta64</span>
            <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeDelta</span>
                <span class="n">data_sec</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e9</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeDelta</span><span class="p">(</span><span class="n">data_sec</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;sec&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">MaskedColumn</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">TableInfo</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">QTable</span><span class="p">(</span><span class="n">Table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to represent tables of heterogeneous data.</span>

<span class="sd">    `~astropy.table.QTable` provides a class for heterogeneous tabular data</span>
<span class="sd">    which can be easily modified, for instance adding columns or new rows.</span>

<span class="sd">    The `~astropy.table.QTable` class is identical to `~astropy.table.Table`</span>
<span class="sd">    except that columns with an associated ``unit`` attribute are converted to</span>
<span class="sd">    `~astropy.units.Quantity` objects.</span>

<span class="sd">    See also:</span>

<span class="sd">    - https://docs.astropy.org/en/stable/table/</span>
<span class="sd">    - https://docs.astropy.org/en/stable/table/mixin_columns.html</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy ndarray, dict, list, table-like object, optional</span>
<span class="sd">        Data to initialize table.</span>
<span class="sd">    masked : bool, optional</span>
<span class="sd">        Specify whether the table is masked.</span>
<span class="sd">    names : list, optional</span>
<span class="sd">        Specify column names.</span>
<span class="sd">    dtype : list, optional</span>
<span class="sd">        Specify column data types.</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata associated with the table.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Copy the input data. Default is True.</span>
<span class="sd">    rows : numpy ndarray, list of list, optional</span>
<span class="sd">        Row-oriented data for table instead of ``data`` argument.</span>
<span class="sd">    copy_indices : bool, optional</span>
<span class="sd">        Copy any indices in the input data. Default is True.</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Additional keyword args when converting table-like object.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_is_mixin_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if ``col`` should be added to the table directly as</span>
<span class="sd">        a mixin column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_col_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We need to turn the column into a quantity; use subok=True to allow</span>
            <span class="c1"># Quantity subclasses identified in the unit (such as u.mag()).</span>
            <span class="n">q_cls</span> <span class="o">=</span> <span class="n">Masked</span><span class="p">(</span><span class="n">Quantity</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">)</span> <span class="k">else</span> <span class="n">Quantity</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">qcol</span> <span class="o">=</span> <span class="n">q_cls</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;column </span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has a unit but is kept as &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;a </span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> as an attempt to &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;convert it to Quantity failed with:</span><span class="se">\n</span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qcol</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span>
                <span class="n">qcol</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">qcol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_convert_col_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">col</span>
</pre></div>

              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, The Gammapy developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>