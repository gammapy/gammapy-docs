
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.modeling.core &#8212; gammapy vX.Y.Z</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gammapy.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/gammapy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/gammapy_logo_nav.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../getting-started/index.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../user-guide/index.html">
  User guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../tutorials/index.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api-reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../development/index.html">
  Developer guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../release-notes/index.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-primary btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        dev  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables _modules/astropy/modeling/core and {'json_url': 'https://docs.gammapy.org/stable/switcher.json', 'version_match': 'dev'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "_modules/astropy/modeling/core.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://docs.gammapy.org/stable/switcher.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "_modules/astropy/modeling/core.html";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 0.20.2.dev572+g20d1a3c65 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "dev") {
                node.classList.add("active");
                let btn = document.getElementById("version_switcher_button");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/gammapy/gammapy" rel="noopener" target="_blank" title="Github"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">Github</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/gammapyST" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://gammapy.slack.com/" rel="noopener" target="_blank" title="Slack"><span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for astropy.modeling.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines base classes for all models.  The base class of all</span>
<span class="sd">models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is</span>
<span class="sd">the base class for all fittable models. Fittable models can be linear or</span>
<span class="sd">nonlinear in a regression analysis sense.</span>

<span class="sd">All models provide a `__call__` method which performs the transformation in</span>
<span class="sd">a purely mathematical way, i.e. the models are unitless.  Model instances can</span>
<span class="sd">represent either a single model, or a &quot;model set&quot; representing multiple copies</span>
<span class="sd">of the same type of model, but with potentially different values of the</span>
<span class="sd">parameters in each model making up the set.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=invalid-name, protected-access, redefined-outer-name</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">astropy.nddata.utils</span> <span class="kn">import</span> <span class="n">add_array</span><span class="p">,</span> <span class="n">extract_array</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">UnitsError</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span>
<span class="kn">from</span> <span class="nn">astropy.units.utils</span> <span class="kn">import</span> <span class="n">quantity_asanyarray</span>
<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IncompatibleShapeError</span><span class="p">,</span> <span class="n">check_broadcast</span><span class="p">,</span> <span class="n">find_current_module</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="n">isiterable</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">sharedmethod</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">astropy.utils.codegen</span> <span class="kn">import</span> <span class="n">make_function_with_signature</span>

<span class="kn">from</span> <span class="nn">.bounding_box</span> <span class="kn">import</span> <span class="n">CompoundBoundingBox</span><span class="p">,</span> <span class="n">ModelBoundingBox</span>
<span class="kn">from</span> <span class="nn">.parameters</span> <span class="kn">import</span> <span class="n">InputParameterError</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">_tofloat</span><span class="p">,</span> <span class="n">param_repr_oneline</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_combine_equivalency_dict</span><span class="p">,</span> <span class="n">_ConstraintsDict</span><span class="p">,</span> <span class="n">_SpecialOperatorsDict</span><span class="p">,</span> <span class="n">combine_labels</span><span class="p">,</span>
    <span class="n">get_inputs_and_params</span><span class="p">,</span> <span class="n">make_binary_operator_eval</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="s1">&#39;FittableModel&#39;</span><span class="p">,</span> <span class="s1">&#39;Fittable1DModel&#39;</span><span class="p">,</span> <span class="s1">&#39;Fittable2DModel&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CompoundModel&#39;</span><span class="p">,</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">,</span> <span class="s1">&#39;custom_model&#39;</span><span class="p">,</span> <span class="s1">&#39;ModelDefinitionError&#39;</span><span class="p">,</span>
           <span class="s1">&#39;bind_bounding_box&#39;</span><span class="p">,</span> <span class="s1">&#39;bind_compound_bounding_box&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_model_oper</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a function that evaluates a given Python arithmetic operator</span>
<span class="sd">    between two models.  The operator should be given as a string, like ``&#39;+&#39;``</span>
<span class="sd">    or ``&#39;**&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ModelDefinitionError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for incorrect models definitions.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_ModelMeta</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metaclass for Model.</span>

<span class="sd">    Currently just handles auto-generating the param_names list based on</span>
<span class="sd">    Parameter descriptors declared at the class-level of Model subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_is_dynamic</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This flag signifies whether this class was created in the &quot;normal&quot; way,</span>
<span class="sd">    with a class statement in the body of a module, as opposed to a call to</span>
<span class="sd">    `type` or some other metaclass constructor, such that the resulting class</span>
<span class="sd">    does not belong to a specific module.  This is important for pickling of</span>
<span class="sd">    dynamic classes.</span>

<span class="sd">    This flag is always forced to False for new classes, so code that creates</span>
<span class="sd">    dynamic classes should manually set it to True on those classes when</span>
<span class="sd">    creating them.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default empty dict for _parameters_, which will be empty on model</span>
    <span class="c1"># classes that don&#39;t have any Parameters</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># See the docstring for _is_dynamic above</span>
        <span class="k">if</span> <span class="s1">&#39;_is_dynamic&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="n">members</span><span class="p">[</span><span class="s1">&#39;_is_dynamic&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcls</span><span class="o">.</span><span class="n">_is_dynamic</span>
        <span class="n">opermethods</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__or__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;__and__&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;_fix_inputs&#39;</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">members</span><span class="p">[</span><span class="s1">&#39;_parameters_&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">members</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)}</span>

        <span class="k">for</span> <span class="n">opermethod</span><span class="p">,</span> <span class="n">opercall</span> <span class="ow">in</span> <span class="n">opermethods</span><span class="p">:</span>
            <span class="n">members</span><span class="p">[</span><span class="n">opermethod</span><span class="p">]</span> <span class="o">=</span> <span class="n">opercall</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s1">&#39;_parameters_&#39;</span><span class="p">])</span>

        <span class="c1"># Need to walk each base MRO to collect all parameter names</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tbase</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">tbase</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="c1"># Preserve order of definitions</span>
                    <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tbase</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">)</span> <span class="o">+</span> <span class="n">param_names</span>
        <span class="c1"># Remove duplicates (arising from redefinition in subclass).</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">param_names</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_param_names&#39;</span><span class="p">):</span>
                <span class="c1"># Slight kludge to support compound models, where</span>
                <span class="c1"># cls.param_names is a property; could be improved with a</span>
                <span class="c1"># little refactoring but fine for now</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_inverse_property</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_bounding_box_property</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="n">pdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tbase</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">tbase</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">parname</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">pdict</span><span class="p">[</span><span class="n">parname</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handle_special_methods</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="n">pdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom repr for Model subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repr for IPython&#39;s pretty printer.</span>

<span class="sd">        By default IPython &quot;pretty prints&quot; classes, so we need to implement</span>
<span class="sd">        this so that IPython displays the custom repr for Models.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_dynamic</span><span class="p">:</span>
            <span class="c1"># Just return a string specifying where the class can be imported</span>
            <span class="c1"># from</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">members</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="c1"># Delete any ABC-related attributes--these will be restored when</span>
        <span class="c1"># the class is reconstructed:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">members</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_abc_&#39;</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">members</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Delete custom __init__ and __call__ if they exist:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">members</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">),</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="n">members</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of this model class--equivalent to ``cls.__name__``.</span>

<span class="sd">        This attribute is provided for symmetry with the `Model.name` attribute</span>
<span class="sd">        of model instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_concrete</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class-level property that determines whether the class is a concrete</span>
<span class="sd">        implementation of a Model--i.e. it is not some abstract base class or</span>
<span class="sd">        internal implementation detail (i.e. begins with &#39;_&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of this model class with a new name, inputs or outputs.</span>

<span class="sd">        The new class is technically a subclass of the original class, so that</span>
<span class="sd">        instance and type checks will still work.  For example::</span>

<span class="sd">            &gt;&gt;&gt; from astropy.modeling.models import Rotation2D</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation = Rotation2D.rename(&#39;SkyRotation&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation</span>
<span class="sd">            &lt;class &#39;astropy.modeling.core.SkyRotation&#39;&gt;</span>
<span class="sd">            Name: SkyRotation (Rotation2D)</span>
<span class="sd">            N_inputs: 2</span>
<span class="sd">            N_outputs: 2</span>
<span class="sd">            Fittable parameters: (&#39;angle&#39;,)</span>
<span class="sd">            &gt;&gt;&gt; issubclass(SkyRotation, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; r = SkyRotation(90)</span>
<span class="sd">            &gt;&gt;&gt; isinstance(r, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected &#39;inputs&#39; to be a tuple of strings.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> expects </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s1"> inputs&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected &#39;outputs&#39; to be a tuple of strings.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> expects </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s1"> outputs&#39;</span><span class="p">)</span>
        <span class="n">new_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">:</span> <span class="n">outputs</span><span class="p">})</span>
        <span class="n">new_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">modname</span>
        <span class="n">new_cls</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">return</span> <span class="n">new_cls</span>

    <span class="k">def</span> <span class="nf">_create_inverse_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inverse&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="c1"># The latter clause is the prevent the below code from running on</span>
            <span class="c1"># the Model base class, which implements the default getter and</span>
            <span class="c1"># setter for .inverse</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="c1"># We allow the @property decorator to be omitted entirely from</span>
            <span class="c1"># the class definition, though its use should be encouraged for</span>
            <span class="c1"># clarity</span>
            <span class="n">inverse</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">fget</span>

        <span class="c1"># Store the inverse getter internally, then delete the given .inverse</span>
        <span class="c1"># attribute so that cls.inverse resolves to Model.inverse instead</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_inverse</span> <span class="o">=</span> <span class="n">inverse</span>
        <span class="k">del</span> <span class="bp">cls</span><span class="o">.</span><span class="n">inverse</span>

    <span class="k">def</span> <span class="nf">_create_bounding_box_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes any bounding_box defined on a concrete Model subclass (either</span>
<span class="sd">        as a fixed tuple or a property or method) and wraps it in the generic</span>
<span class="sd">        getter/setter interface for the bounding_box attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Much of this is verbatim from _create_inverse_property--I feel</span>
        <span class="c1"># like there could be a way to generify properties that work this way,</span>
        <span class="c1"># but for the time being that would probably only confuse things more.</span>
        <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bounding_box&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span><span class="o">.</span><span class="n">fget</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">):</span>
            <span class="c1"># See if it&#39;s a hard-coded bounding_box (as a sequence) and</span>
            <span class="c1"># normalize it</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">ModelBoundingBox</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">_preserve_ignore</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">)</span>
            <span class="c1"># May be a method that only takes &#39;self&#39; as an argument (like a</span>
            <span class="c1"># property, but the @property decorator was forgotten)</span>
            <span class="c1">#</span>
            <span class="c1"># However, if the method takes additional arguments then this is a</span>
            <span class="c1"># parameterized bounding box and should be callable</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_bounding_box_subclass</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

        <span class="c1"># See the Model.bounding_box getter definition for how this attribute</span>
        <span class="c1"># is used</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="k">del</span> <span class="bp">cls</span><span class="o">.</span><span class="n">bounding_box</span>

    <span class="k">def</span> <span class="nf">_create_bounding_box_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For Models that take optional arguments for defining their bounding</span>
<span class="sd">        box, we create a subclass of ModelBoundingBox with a ``__call__`` method</span>
<span class="sd">        that supports those additional arguments.</span>

<span class="sd">        Takes the function&#39;s Signature as an argument since that is already</span>
<span class="sd">        computed in _create_bounding_box_property, so no need to duplicate that</span>
<span class="sd">        effort.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Might be convenient if calling the bounding box also</span>
        <span class="c1"># automatically sets the _user_bounding_box.  So that</span>
        <span class="c1">#</span>
        <span class="c1">#    &gt;&gt;&gt; model.bounding_box(arg=1)</span>
        <span class="c1">#</span>
        <span class="c1"># in addition to returning the computed bbox, also sets it, so that</span>
        <span class="c1"># it&#39;s a shortcut for</span>
        <span class="c1">#</span>
        <span class="c1">#    &gt;&gt;&gt; model.bounding_box = model.bounding_box(arg=1)</span>
        <span class="c1">#</span>
        <span class="c1"># Not sure if that would be non-obvious / confusing though...</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Presumed to be a &#39;self&#39; argument</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The bounding_box method for </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not correctly &quot;</span>
                    <span class="s2">&quot;defined: If defined as a method all arguments to that &quot;</span>
                    <span class="s2">&quot;method (besides self) must be keyword arguments with &quot;</span>
                    <span class="s2">&quot;default values that can be used to compute a default &quot;</span>
                    <span class="s2">&quot;bounding box.&quot;</span><span class="p">)</span>

            <span class="n">kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">))</span>

        <span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">ModelBoundingBox&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ModelBoundingBox</span><span class="p">,),</span>
                    <span class="p">{</span><span class="s1">&#39;__call__&#39;</span><span class="p">:</span> <span class="fm">__call__</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_handle_special_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">pdict</span><span class="p">):</span>

        <span class="c1"># Handle init creation from inputs</span>
        <span class="k">def</span> <span class="nf">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="c1"># Set up the new __call__&#39;s metadata attributes as though it were</span>
            <span class="c1"># manually defined in the class definition</span>
            <span class="c1"># A bit like functools.update_wrapper but uses the class instead of</span>
            <span class="c1"># the wrapped function</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="vm">__doc__</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">):</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;__call__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="s1">&#39;n_inputs&#39;</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s1">&#39;n_inputs&#39;</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">members</span><span class="p">[</span><span class="s1">&#39;n_inputs&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="c1"># Don&#39;t create a custom __call__ for classes that already have one</span>
            <span class="c1"># explicitly defined (this includes the Model base class, and any</span>
            <span class="c1"># other classes that manually override __call__</span>

            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Evaluate this model on the supplied inputs.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># When called, models can take two optional keyword arguments:</span>
            <span class="c1">#</span>
            <span class="c1"># * model_set_axis, which indicates (for multi-dimensional input)</span>
            <span class="c1">#   which axis is used to indicate different models</span>
            <span class="c1">#</span>
            <span class="c1"># * equivalencies, a dictionary of equivalencies to be applied to</span>
            <span class="c1">#   the input values, where each key should correspond to one of</span>
            <span class="c1">#   the inputs.</span>
            <span class="c1">#</span>
            <span class="c1"># The following code creates the __call__ function with these</span>
            <span class="c1"># two keyword arguments.</span>

            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;equivalencies&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;inputs_map&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>

            <span class="n">new_call</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                <span class="fm">__call__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">varargs</span><span class="o">=</span><span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="n">varkwargs</span><span class="o">=</span><span class="s1">&#39;new_inputs&#39;</span><span class="p">)</span>

            <span class="c1"># The following makes it look like __call__</span>
            <span class="c1"># was defined in the class</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_call</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span> <span class="o">=</span> <span class="n">new_call</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;__init__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">):</span>
            <span class="c1"># Build list of all parameters including inherited ones</span>

            <span class="c1"># If *all* the parameters have default values we can make them</span>
            <span class="c1"># keyword arguments; otherwise they must all be positional</span>
            <span class="c1"># arguments</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pdict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_val</span> <span class="ow">in</span> <span class="n">pdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">default</span> <span class="o">=</span> <span class="n">param_val</span><span class="o">.</span><span class="n">default</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">param_val</span><span class="o">.</span><span class="n">unit</span>
                    <span class="c1"># If the unit was specified in the parameter but the</span>
                    <span class="c1"># default is not a Quantity, attach the unit to the</span>
                    <span class="c1"># default.</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">default</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param_name</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">new_init</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                <span class="fm">__init__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">varkwargs</span><span class="o">=</span><span class="s1">&#39;kwargs&#39;</span><span class="p">)</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_init</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">new_init</span>

    <span class="c1"># *** Arithmetic operators for creating compound models ***</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
    <span class="n">_fix_inputs</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">)</span>

    <span class="c1"># *** Other utilities ***</span>

    <span class="k">def</span> <span class="nf">_format_cls_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For the sake of familiarity start the output with the standard class</span>
        <span class="c1"># __repr__</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">format_inheritance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">or</span>
                      <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)):</span>
                    <span class="k">break</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bases</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="n">format_inheritance</span><span class="p">(</span><span class="bp">cls</span><span class="p">)),</span>
                <span class="p">(</span><span class="s1">&#39;N_inputs&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;N_outputs&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">),</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">default_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Fittable parameters&#39;</span><span class="p">,</span>
                                         <span class="bp">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span> <span class="o">+</span> <span class="n">keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If any of the above formatting fails fall back on the basic repr</span>
            <span class="c1"># (this is particularly useful in debugging)</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_ModelMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all models.</span>

<span class="sd">    This is an abstract class and should not be instantiated directly.</span>

<span class="sd">    The following initialization arguments apply to the majority of Model</span>
<span class="sd">    subclasses by default (exceptions include specialized utility models</span>
<span class="sd">    like `~astropy.modeling.mappings.Mapping`).  Parametric models take all</span>
<span class="sd">    their parameters as arguments, followed by any of the following optional</span>
<span class="sd">    keyword arguments:</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A human-friendly name associated with this model instance</span>
<span class="sd">        (particularly useful for identifying the individual components of a</span>
<span class="sd">        compound model).</span>

<span class="sd">    meta : dict, optional</span>
<span class="sd">        An optional dict of user-defined metadata to attach to this model.</span>
<span class="sd">        How this is used and interpreted is up to the user or individual use</span>
<span class="sd">        case.</span>

<span class="sd">    n_models : int, optional</span>
<span class="sd">        If given an integer greater than 1, a *model set* is instantiated</span>
<span class="sd">        instead of a single model.  This affects how the parameter arguments</span>
<span class="sd">        are interpreted.  In this case each parameter must be given as a list</span>
<span class="sd">        or array--elements of this array are taken along the first axis (or</span>
<span class="sd">        ``model_set_axis`` if specified), such that the Nth element is the</span>
<span class="sd">        value of that parameter for the Nth model in the set.</span>

<span class="sd">        See the section on model sets in the documentation for more details.</span>

<span class="sd">    model_set_axis : int, optional</span>
<span class="sd">        This argument only applies when creating a model set (i.e. ``n_models &gt;</span>
<span class="sd">        1``).  It changes how parameter values are interpreted.  Normally the</span>
<span class="sd">        first axis of each input parameter array (properly the 0th axis) is</span>
<span class="sd">        taken as the axis corresponding to the model sets.  However, any axis</span>
<span class="sd">        of an input array may be taken as this &quot;model set axis&quot;.  This accepts</span>
<span class="sd">        negative integers as well--for example use ``model_set_axis=-1`` if the</span>
<span class="sd">        last (most rapidly changing) axis should be associated with the model</span>
<span class="sd">        sets. Also, ``model_set_axis=False`` can be used to tell that a given</span>
<span class="sd">        input should be used to evaluate all the models in the model set.</span>

<span class="sd">    fixed : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: bool}`` setting the fixed constraint</span>
<span class="sd">        for one or more parameters.  `True` means the parameter is held fixed</span>
<span class="sd">        during fitting and is prevented from updates once an instance of the</span>
<span class="sd">        model has been created.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.fixed` property of a</span>
<span class="sd">        parameter may be used to lock or unlock individual parameters.</span>

<span class="sd">    tied : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: callable}`` of parameters which are</span>
<span class="sd">        linked to some other parameter. The dictionary values are callables</span>
<span class="sd">        providing the linking relationship.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.tied` property of a</span>
<span class="sd">        parameter may be used to set the ``tied`` constraint on individual</span>
<span class="sd">        parameters.</span>

<span class="sd">    bounds : dict, optional</span>
<span class="sd">        A dictionary ``{parameter_name: value}`` of lower and upper bounds of</span>
<span class="sd">        parameters. Keys are parameter names. Values are a list or a tuple</span>
<span class="sd">        of length 2 giving the desired range for the parameter.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.min` and</span>
<span class="sd">        `~astropy.modeling.Parameter.max` or</span>
<span class="sd">        ~astropy.modeling.Parameter.bounds` properties of a parameter may be</span>
<span class="sd">        used to set bounds on individual parameters.</span>

<span class="sd">    eqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``eqcons[j](x0, *args) == 0.0``</span>
<span class="sd">        in a successfully optimized problem.</span>

<span class="sd">    ineqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``ieqcons[j](x0, *args) &gt;=</span>
<span class="sd">        0.0`` is a successfully optimized problem.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.modeling import models</span>
<span class="sd">    &gt;&gt;&gt; def tie_center(model):</span>
<span class="sd">    ...         mean = 50 * model.stddev</span>
<span class="sd">    ...         return mean</span>
<span class="sd">    &gt;&gt;&gt; tied_parameters = {&#39;mean&#39;: tie_center}</span>

<span class="sd">    Specify that ``&#39;mean&#39;`` is a tied parameter in one of two ways:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        tied=tied_parameters)</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied = tie_center</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    &lt;function tie_center at 0x...&gt;</span>

<span class="sd">    Fixed parameters:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        fixed={&#39;stddev&#39;: True})</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed = True</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameter_constraints</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">constraints</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that can be set on a model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">model_constraints</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;eqcons&#39;</span><span class="p">,</span> <span class="s1">&#39;ineqcons&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that constrain model evaluation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">param_names</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Names of the parameters that describe models of this type.</span>

<span class="sd">    The parameters in this tuple are in the same order they should be passed in</span>
<span class="sd">    when initializing a model of a specific type.  Some types of models, such</span>
<span class="sd">    as polynomial models, have a different number of parameters depending on</span>
<span class="sd">    some other property of the model, such as the degree.</span>

<span class="sd">    When defining a custom model class the value of this attribute is</span>
<span class="sd">    automatically set by the `~astropy.modeling.Parameter` attributes defined</span>
<span class="sd">    in the class body.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_inputs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;The number of inputs.&quot;&quot;&quot;</span>
    <span class="n">n_outputs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot; The number of outputs.&quot;&quot;&quot;</span>

    <span class="n">standard_broadcasting</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_separable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot; A boolean flag to indicate whether a model is separable.&quot;&quot;&quot;</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">MetaData</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;A dict-like object to store optional information.&quot;&quot;&quot;</span>

    <span class="c1"># By default models either use their own inverse property or have no</span>
    <span class="c1"># inverse at all, but users may also assign a custom inverse to a model,</span>
    <span class="c1"># optionally; in that case it is of course up to the user to determine</span>
    <span class="c1"># whether their inverse is *actually* an inverse to the model they assign</span>
    <span class="c1"># it to.</span>
    <span class="n">_inverse</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_user_inverse</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_has_inverse_bounding_box</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Default n_models attribute, so that __len__ is still defined even when a</span>
    <span class="c1"># model hasn&#39;t completed initialization yet</span>
    <span class="n">_n_models</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># New classes can set this as a boolean value.</span>
    <span class="c1"># It is converted to a dictionary mapping input name to a boolean value.</span>
    <span class="n">_input_units_strict</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Allow dimensionless input (and corresponding output). If this is True,</span>
    <span class="c1"># input values to evaluate will gain the units specified in input_units. If</span>
    <span class="c1"># this is a dictionary then it should map input name to a bool to allow</span>
    <span class="c1"># dimensionless numbers for that input.</span>
    <span class="c1"># Only has an effect if input_units is defined.</span>
    <span class="n">_input_units_allow_dimensionless</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Default equivalencies to apply to input values. If set, this should be a</span>
    <span class="c1"># dictionary where each key is a string that corresponds to one of the</span>
    <span class="c1"># model inputs. Only has an effect if input_units is defined.</span>
    <span class="n">input_units_equivalencies</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Covariance matrix can be set by fitter if available.</span>
    <span class="c1"># If cov_matrix is available, then std will set as well</span>
    <span class="n">_cov_matrix</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_stds</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_inputs_outputs</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># add parameters to instance level by walking MRO list</span>
        <span class="n">mro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__mro__</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">parname</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameters_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">newpar</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">newpar</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="n">parname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">parname</span><span class="p">]</span> <span class="o">=</span> <span class="n">newpar</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_constraints</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_setters</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Remaining keyword args are either parameter values or invalid</span>
        <span class="c1"># Parameter values must be passed in as keyword arguments in order to</span>
        <span class="c1"># distinguish them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_slices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_unit_support</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_default_inputs_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># self.n_inputs and self.n_outputs are properties</span>
                <span class="c1"># This is the case when subclasses of Model do not define</span>
                <span class="c1"># ``n_inputs``, ``n_outputs``, ``inputs`` or ``outputs``.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize_setters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This exists to inject defaults for settable properties for models</span>
<span class="sd">        originating from `custom_model`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_settable_properties&#39;</span><span class="p">):</span>
            <span class="n">setters</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settable_properties</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">setters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span>

    <span class="nd">@inputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2"> number of inputs, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_unit_support</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span>

    <span class="nd">@outputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="si">}</span><span class="s2"> number of outputs, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: remove the code in the ``if`` block when support</span>
        <span class="c1"># for models with ``inputs`` as class variables is removed.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;n_inputs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_inputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: remove the code in the ``if`` block when support</span>
        <span class="c1"># for models with ``outputs`` as class variables is removed.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;n_outputs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">n_outputs</span>

    <span class="k">def</span> <span class="nf">_calculate_separability_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a hook which customises the behavior of modeling.separable.</span>

<span class="sd">        This allows complex subclasses to customise the separability matrix.</span>
<span class="sd">        If it returns `NotImplemented` the default behavior is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_initialize_unit_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert self._input_units_strict and</span>
<span class="sd">        self.input_units_allow_dimensionless to dictionaries</span>
<span class="sd">        mapping input name to a boolean value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span> <span class="k">for</span>
                                        <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span>
                                                     <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_strict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enforce strict units on inputs to evaluate. If this is set to True,</span>
<span class="sd">        input values to evaluate will be in the exact units specified by</span>
<span class="sd">        input_units. If the input quantities are convertible to input_units,</span>
<span class="sd">        they are converted. If this is a dictionary then it should map input</span>
<span class="sd">        name to a bool to set strict input units for that parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_strict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_allow_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow dimensionless input (and corresponding output). If this is True,</span>
<span class="sd">        input values to evaluate will gain the units specified in input_units. If</span>
<span class="sd">        this is a dictionary then it should map input name to a bool to allow</span>
<span class="sd">        dimensionless numbers for that input.</span>
<span class="sd">        Only has an effect if input_units is defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units_allow_dimensionless</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uses_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if this model has been created with `~astropy.units.Quantity`</span>
<span class="sd">        objects or if there are no parameters.</span>

<span class="sd">        This can be used to determine if this model should be evaluated with</span>
<span class="sd">        `~astropy.units.Quantity` or regular floats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pisq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pisq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">pisq</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_str</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_strip_ones</span><span class="p">(</span><span class="n">intup</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">intup</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">param_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_tofloat</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># check consistency with previous shape and size</span>
            <span class="n">eshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">eshape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">eshape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="n">vshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">vshape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">vshape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">esize</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_strip_ones</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strip_ones</span><span class="p">(</span><span class="n">eshape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Value for parameter </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> does not match shape or size</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;expected by model (</span><span class="si">{</span><span class="n">vshape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">) vs (</span><span class="si">{</span><span class="n">eshape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">esize</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The &#39;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; parameter should be given as a&quot;</span>
                                     <span class="s2">&quot; Quantity because it was originally &quot;</span>
                                     <span class="s2">&quot;initialized as a Quantity&quot;</span><span class="p">)</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span>
                <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fittable&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pre_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model specific input setup that needs to occur prior to model evaluation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Broadcast inputs into common size</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inputs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Setup actual model evaluation method</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">(</span><span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">_inputs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">_inputs</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">get_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_bbox</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ``bounding_box`` of a model if it exists or ``None``</span>
<span class="sd">        otherwise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_bbox :</span>
<span class="sd">            The value of the ``with_bounding_box`` keyword argument</span>
<span class="sd">            when calling the model. Default is `True` for usage when</span>
<span class="sd">            looking up the model&#39;s ``bounding_box`` without risk of error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">with_bbox</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">with_bbox</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">CompoundBoundingBox</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">with_bbox</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">with_bbox</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">bbox</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_argnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The inputs used to determine input_shape for bounding_box evaluation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

    <span class="k">def</span> <span class="nf">_validate_input_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_input</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">argnames</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">check_model_set_axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform basic validation of a single model input&#39;s shape</span>
<span class="sd">            -- it has the minimum dimensions for the given model_set_axis</span>

<span class="sd">        Returns the shape of the input if validation succeeds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">_input</span><span class="p">)</span>
        <span class="c1"># Ensure that the input&#39;s model_set_axis matches the model&#39;s</span>
        <span class="c1"># n_models</span>
        <span class="k">if</span> <span class="n">input_shape</span> <span class="ow">and</span> <span class="n">check_model_set_axis</span><span class="p">:</span>
            <span class="c1"># Note: Scalar inputs *only* get a pass on this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;For model_set_axis=</span><span class="si">{</span><span class="n">model_set_axis</span><span class="si">}</span><span class="s2">, all inputs must be at &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;least </span><span class="si">{</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">-dimensional.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">input_shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">argname</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># the case of model.inputs = ()</span>
                    <span class="n">argname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Input argument &#39;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2">&#39; does not have the correct &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimensions in model_set_axis=</span><span class="si">{</span><span class="n">model_set_axis</span><span class="si">}</span><span class="s2"> for a model set with &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;n_models=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">input_shape</span>

    <span class="k">def</span> <span class="nf">_validate_input_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">argnames</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform basic validation of model inputs</span>
<span class="sd">            --that they are mutually broadcastable and that they have</span>
<span class="sd">            the minimum dimensions for the given model_set_axis.</span>

<span class="sd">        If validation succeeds, returns the total shape that will result from</span>
<span class="sd">        broadcasting the input arrays with each other.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>

        <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
            <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_shape</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">argnames</span><span class="p">,</span>
                                                         <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">check_model_set_axis</span><span class="p">))</span>

        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;All inputs must have identical shapes or must be scalars.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">input_shape</span>

    <span class="k">def</span> <span class="nf">input_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get input shape for bounding_box evaluation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generic_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">_inputs</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">with_bbox</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic model evaluation routine</span>
<span class="sd">            Selects and evaluates model with or without bounding_box enforcement</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Evaluate the model using the prepared evaluation method either</span>
        <span class="c1">#   enforcing the bounding_box or not.</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_box</span><span class="p">(</span><span class="n">with_bbox</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">with_bbox</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">with_bbox</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">evaluate</span><span class="p">,</span> <span class="n">_inputs</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">_inputs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="k">def</span> <span class="nf">_post_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="n">with_bbox</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model specific post evaluation processing of outputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_box</span><span class="p">(</span><span class="n">with_bbox</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_outputs</span><span class="p">(</span><span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bbox_with_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate this model using the given input(s) and the parameter values</span>
<span class="sd">        that were specified when the model was instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Turn any keyword arguments into positional arguments.</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_renamed_inputs_as_positional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Read model evaluation related parameters</span>
        <span class="n">with_bbox</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># prepare for model evaluation (overridden in CompoundModel)</span>
        <span class="n">evaluate</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generic_evaluate</span><span class="p">(</span><span class="n">evaluate</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="p">,</span> <span class="n">with_bbox</span><span class="p">)</span>

        <span class="c1"># post-process evaluation results (overridden in CompoundModel)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_evaluate</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="n">with_bbox</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_renamed_inputs_as_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_keyword2positional</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Inputs were passed as keyword (not positional) arguments.</span>
            <span class="c1"># Because the signature of the ``__call__`` is defined at</span>
            <span class="c1"># the class level, the name of the inputs cannot be changed at</span>
            <span class="c1"># the instance level and the old names are always present in the</span>
            <span class="c1"># signature of the method. In order to use the new names of the</span>
            <span class="c1"># inputs, the old names are taken out of ``kwargs``, the input</span>
            <span class="c1"># values are sorted in the order of self.inputs and passed as</span>
            <span class="c1"># positional arguments to ``__call__``.</span>

            <span class="c1"># These are the keys that are always present as keyword arguments.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="s1">&#39;with_bounding_box&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;equivalencies&#39;</span><span class="p">,</span> <span class="s1">&#39;inputs_map&#39;</span><span class="p">]</span>

            <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># kwargs contain the names of the new inputs + ``keys``</span>
            <span class="n">allkeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="c1"># Remove the names of the new inputs from kwargs and save them</span>
            <span class="c1"># to a dict ``new_inputs``.</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">allkeys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">new_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">new_inputs</span><span class="p">,</span> <span class="n">kwargs</span>
        <span class="n">n_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="n">new_inputs</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_keyword2positional</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">n_all_args</span> <span class="o">=</span> <span class="n">n_args</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_all_args</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing input arguments - expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">,&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; got </span><span class="si">{</span><span class="n">n_all_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_all_args</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too many input arguments - expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">,&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; got </span><span class="si">{</span><span class="n">n_all_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_args</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Create positional arguments from the keyword arguments in ``new_inputs``.</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">n_args</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="c1"># Some inputs are passed as positional, others as keyword arguments.</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># Create positional arguments from the keyword arguments in ``new_inputs``.</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_inputs</span><span class="p">:</span>
                    <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">return</span> <span class="n">new_args</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="c1"># *** Properties ***</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;User-provided name for this model instance.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign a (new) name to this model.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of the model set axis--that is the axis of a parameter array</span>
<span class="sd">        that pertains to which model a parameter value pertains to--as</span>
<span class="sd">        specified when the model was initialized.</span>

<span class="sd">        See the documentation on :ref:`astropy:modeling-model-sets`</span>
<span class="sd">        for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return parameters as a pset.</span>

<span class="sd">        This is a list with one item per parameter set, which is an array of</span>
<span class="sd">        that parameter&#39;s values across all parameter sets, with the last axis</span>
<span class="sd">        associated with the parameter set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flattened array of all parameter values in all parameter sets.</span>

<span class="sd">        Fittable parameters maintain this list and fitters modify it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Currently the sequence of a model&#39;s parameters must be contiguous</span>
        <span class="c1"># within the _parameters array (which may be a view of a larger array,</span>
        <span class="c1"># for example when taking a sub-expression of a compound model), so</span>
        <span class="c1"># the assumption here is reliable:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="c1"># Trivial, but not unheard of</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_to_array</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>

    <span class="nd">@parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigning to this attribute updates the parameters array rather than</span>
<span class="sd">        replacing it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s2">&quot;Input parameter values not compatible with the model &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;parameters array: </span><span class="si">{</span><span class="n">e</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array_to_parameters</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sync_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is a boolean property that indicates whether or not accessing constraints</span>
<span class="sd">        automatically check the constituent models current values. It defaults to True</span>
<span class="sd">        on creation of a model, but for fitting purposes it should be set to False</span>
<span class="sd">        for performance reasons.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_sync_constraints&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sync_constraints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sync_constraints</span>

    <span class="nd">@sync_constraints</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sync_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sync_constraints only accepts True or False as values&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_constraints</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fixed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A ``dict`` mapping parameter names to their fixed constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_fixed&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_constraints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed</span> <span class="o">=</span> <span class="n">_ConstraintsDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A ``dict`` mapping parameter names to their upper and lower bounds as</span>
<span class="sd">        ``(min, max)`` tuples or ``[min, max]`` lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bounds&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_constraints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">_ConstraintsDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tied</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A ``dict`` mapping parameter names to their tied constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_tied&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_constraints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tied</span> <span class="o">=</span> <span class="n">_ConstraintsDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;tied&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tied</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter equality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span><span class="p">[</span><span class="s1">&#39;eqcons&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter inequality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span><span class="p">[</span><span class="s1">&#39;ineqcons&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the model has an analytic or user</span>
<span class="sd">        inverse defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `~astropy.modeling.Model` instance which performs the</span>
<span class="sd">        inverse transform, if an analytic inverse is defined for this model.</span>

<span class="sd">        Even on models that don&#39;t have an inverse defined, this property can be</span>
<span class="sd">        set with a manually-defined inverse, such a pre-computed or</span>
<span class="sd">        experimentally determined inverse (often given as a</span>
<span class="sd">        `~astropy.modeling.polynomial.PolynomialModel`, but not by</span>
<span class="sd">        requirement).</span>

<span class="sd">        A custom inverse can be deleted with ``del model.inverse``.  In this</span>
<span class="sd">        case the model&#39;s inverse is reset to its default, if a default exists</span>
<span class="sd">        (otherwise the default is to raise `NotImplementedError`).</span>

<span class="sd">        Note to authors of `~astropy.modeling.Model` subclasses:  To define an</span>
<span class="sd">        inverse for a model simply override this property to return the</span>
<span class="sd">        appropriate model representing the inverse.  The machinery that will</span>
<span class="sd">        make the inverse manually-overridable is added automatically by the</span>
<span class="sd">        base class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_inverse_bounding_box</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No analytical or user-supplied inverse transform &quot;</span>
                                  <span class="s2">&quot;has been implemented for this model.&quot;</span><span class="p">)</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ``inverse`` attribute may be assigned a `Model` &quot;</span>
                <span class="s2">&quot;instance or `None` (where `None` explicitly forces the &quot;</span>
                <span class="s2">&quot;model to have no inverse.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@inverse</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the model&#39;s inverse to its default (if one exists, otherwise</span>
<span class="sd">        the model will have no inverse).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom inverse model has been</span>
<span class="sd">        assigned to this model by a user, via assignment to ``model.inverse``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `tuple` of length `n_inputs` defining the bounding box limits, or</span>
<span class="sd">        raise `NotImplementedError` for no bounding_box.</span>

<span class="sd">        The default limits are given by a ``bounding_box`` property or method</span>
<span class="sd">        defined in the class body of a specific model.  If not defined then</span>
<span class="sd">        this property just raises `NotImplementedError` by default (but may be</span>
<span class="sd">        assigned a custom value by a user).  ``bounding_box`` can be set</span>
<span class="sd">        manually to an array-like object of shape ``(model.n_inputs, 2)``. For</span>
<span class="sd">        further usage, see :ref:`astropy:bounding-boxes`</span>

<span class="sd">        The limits are ordered according to the `numpy` ``&#39;C&#39;`` indexing</span>
<span class="sd">        convention, and are the reverse of the model input order,</span>
<span class="sd">        e.g. for inputs ``(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;)``, ``bounding_box`` is defined:</span>

<span class="sd">        * for 1D: ``(x_low, x_high)``</span>
<span class="sd">        * for 2D: ``((y_low, y_high), (x_low, x_high))``</span>
<span class="sd">        * for 3D: ``((z_low, z_high), (y_low, y_high), (x_low, x_high))``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Setting the ``bounding_box`` limits for a 1D and 2D model:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import Gaussian1D, Gaussian2D</span>
<span class="sd">        &gt;&gt;&gt; model_1d = Gaussian1D()</span>
<span class="sd">        &gt;&gt;&gt; model_2d = Gaussian2D(x_stddev=1, y_stddev=1)</span>
<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box = (-5, 5)</span>
<span class="sd">        &gt;&gt;&gt; model_2d.bounding_box = ((-6, 6), (-5, 5))</span>

<span class="sd">        Setting the bounding_box limits for a user-defined 3D `custom_model`:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import custom_model</span>
<span class="sd">        &gt;&gt;&gt; def const3d(x, y, z, amp=1):</span>
<span class="sd">        ...    return amp</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Const3D = custom_model(const3d)</span>
<span class="sd">        &gt;&gt;&gt; model_3d = Const3D()</span>
<span class="sd">        &gt;&gt;&gt; model_3d.bounding_box = ((-6, 6), (-5, 5), (-4, 4))</span>

<span class="sd">        To reset ``bounding_box`` to its default limits just delete the</span>
<span class="sd">        user-defined value--this will reset it back to the default defined</span>
<span class="sd">        on the class:</span>

<span class="sd">        &gt;&gt;&gt; del model_1d.bounding_box</span>

<span class="sd">        To disable the bounding box entirely (including the default),</span>
<span class="sd">        set ``bounding_box`` to `None`:</span>

<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box = None</span>
<span class="sd">        &gt;&gt;&gt; model_1d.bounding_box  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        NotImplementedError: No bounding box is defined for this model</span>
<span class="sd">        (note: the bounding box was explicitly disabled for this model;</span>
<span class="sd">        use `del model.bounding_box` to restore the default bounding box,</span>
<span class="sd">        if one is defined for this model).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;No bounding box is defined for this model (note: the &quot;</span>
                    <span class="s2">&quot;bounding box was explicitly disabled for this model; &quot;</span>
                    <span class="s2">&quot;use `del model.bounding_box` to restore the default &quot;</span>
                    <span class="s2">&quot;bounding box, if one is defined for this model).&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;No bounding box is defined for this model.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">ModelBoundingBox</span><span class="p">):</span>
            <span class="c1"># This typically implies a hard-coded bounding box.  This will</span>
            <span class="c1"># probably be rare, but it is an option</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ModelBoundingBox</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The only other allowed possibility is that it&#39;s a ModelBoundingBox</span>
            <span class="c1"># subclass, so we call it with its default arguments and return an</span>
            <span class="c1"># instance of it (that can be called to recompute the bounding box</span>
            <span class="c1"># with any optional parameters)</span>
            <span class="c1"># (In other words, in this case self._bounding_box is a *class*)</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">((),</span> <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="p">)()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@bounding_box</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns the bounding box limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># We use this to explicitly set an unimplemented bounding box (as</span>
            <span class="c1"># opposed to no user bounding box defined)</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">CompoundBoundingBox</span><span class="p">)</span> <span class="ow">or</span>
              <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">CompoundBoundingBox</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span>
              <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">,</span> <span class="n">ModelBoundingBox</span><span class="p">)):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">ModelBoundingBox</span>

        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">_preserve_ignore</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>

    <span class="k">def</span> <span class="nf">set_slice_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span><span class="p">,</span> <span class="n">CompoundBoundingBox</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span><span class="o">.</span><span class="n">slice_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The bounding_box for this model is not compound&#39;</span><span class="p">)</span>

    <span class="nd">@bounding_box</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom bounding_box has been</span>
<span class="sd">        assigned to this model by a user, via assignment to</span>
<span class="sd">        ``model.bounding_box``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cov_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fitter should set covariance matrix, if available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_matrix</span>

    <span class="nd">@cov_matrix</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cov_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_matrix</span> <span class="o">=</span> <span class="n">cov</span>

        <span class="n">unfix_untied_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
                               <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>  <span class="c1"># model set</span>
            <span class="n">param_stds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cov</span><span class="p">:</span>
                <span class="n">param_stds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">cov_matrix</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unfix_untied_params</span><span class="p">):</span>
                <span class="n">par</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                <span class="n">par</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">param_stds</span><span class="p">]</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_stds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="o">.</span><span class="n">cov_matrix</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">unfix_untied_params</span><span class="p">:</span>
                <span class="n">par</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                <span class="n">par</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">param_stds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard deviation of parameters, if covariance matrix is available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stds</span>

    <span class="nd">@stds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stds</span> <span class="o">=</span> <span class="n">stds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A flag indicating whether a model is separable.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separable</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;The &quot;separable&quot; property is not defined for &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># *** Public methods ***</span>

    <span class="k">def</span> <span class="nf">without_units_for_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of the model for which the parameter values have</span>
<span class="sd">        been converted to the right units for the data, then the units have</span>
<span class="sd">        been stripped away.</span>

<span class="sd">        The input and output Quantity objects should be given as keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is needed in order to be able to fit models with units in</span>
<span class="sd">        the parameters, since we need to temporarily strip away the units from</span>
<span class="sd">        the model during the fitting (which might be done by e.g. scipy</span>
<span class="sd">        functions).</span>

<span class="sd">        The units that the parameters should be converted to are not</span>
<span class="sd">        necessarily the units of the input data, but are derived from them.</span>
<span class="sd">        Model subclasses that want fitting to work in the presence of</span>
<span class="sd">        quantities need to define a ``_parameter_units_for_data_units`` method</span>
<span class="sd">        that takes the input and output units (as two dictionaries) and</span>
<span class="sd">        returns a dictionary giving the target units for each parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">inputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">outputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="n">parameter_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">inputs_unit</span><span class="p">,</span>
                                                               <span class="n">outputs_unit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">parameter_units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parameter</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parameter</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">quantity</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">parameter</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">model</span><span class="o">.</span><span class="n">strip_units_from_tree</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">output_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of output units for this model given a dictionary</span>
<span class="sd">        of fitting inputs and outputs</span>

<span class="sd">        The input and output Quantity objects should be given as keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is needed in order to be able to fit models with units in</span>
<span class="sd">        the parameters, since we need to temporarily strip away the units from</span>
<span class="sd">        the model during the fitting (which might be done by e.g. scipy</span>
<span class="sd">        functions).</span>

<span class="sd">        This method will force extra model evaluations, which maybe computationally</span>
<span class="sd">        expensive. To avoid this, one can add a return_units property to the model,</span>
<span class="sd">        see :ref:`astropy:models_return_units`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span>

        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">units</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">**</span><span class="n">inputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span><span class="p">,)</span>

            <span class="n">units</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)}</span>

        <span class="k">return</span> <span class="n">units</span>

    <span class="k">def</span> <span class="nf">strip_units_from_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parname</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">par</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">parname</span><span class="p">)</span>
                <span class="n">par</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_units_from_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of the model which has units for which the parameter</span>
<span class="sd">        values are compatible with the data units specified.</span>

<span class="sd">        The input and output Quantity objects should be given as keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is needed in order to be able to fit models with units in</span>
<span class="sd">        the parameters, since we need to temporarily strip away the units from</span>
<span class="sd">        the model during the fitting (which might be done by e.g. scipy</span>
<span class="sd">        functions).</span>

<span class="sd">        The units that the parameters will gain are not necessarily the units</span>
<span class="sd">        of the input data, but are derived from them. Model subclasses that</span>
<span class="sd">        want fitting to work in the presence of quantities need to define a</span>
<span class="sd">        ``_parameter_units_for_data_units`` method that takes the input and output</span>
<span class="sd">        units (as two dictionaries) and returns a dictionary giving the target</span>
<span class="sd">        units for each parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">inputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">outputs_unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">parameter_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">inputs_unit</span><span class="p">,</span>
                                                               <span class="n">outputs_unit</span><span class="p">)</span>

        <span class="c1"># We are adding units to parameters that already have a value, but we</span>
        <span class="c1"># don&#39;t want to convert the parameter, just add the unit directly,</span>
        <span class="c1"># hence the call to ``_set_unit``.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">parameter_units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">parameter</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_has_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Returns True if any of the parameters have units</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_supports_unit_fitting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If the model has a ``_parameter_units_for_data_units`` method, this</span>
        <span class="c1"># indicates that we have enough information to strip the units away</span>
        <span class="c1"># and add them back after fitting, when fitting quantities</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_parameter_units_for_data_units&#39;</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the model on some input variables.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sum_of_implicit_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the sum of any implicit model terms on some input variables.</span>
<span class="sd">        This includes any fixed terms used in evaluating a linear model that</span>
<span class="sd">        do not have corresponding parameters exposed to the user. The</span>
<span class="sd">        prototypical case is `astropy.modeling.functional_models.Shift`, which</span>
<span class="sd">        corresponds to a function y = a + bx, where b=1 is intrinsically fixed</span>
<span class="sd">        by the type of model, such that sum_of_implicit_terms(x) == x. This</span>
<span class="sd">        method is needed by linear fitters to correct the dependent variable</span>
<span class="sd">        for the implicit term(s) when solving for the remaining terms</span>
<span class="sd">        (ie. a = y - bx).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a model at fixed positions, respecting the ``bounding_box``.</span>

<span class="sd">        The key difference relative to evaluating the model directly is that</span>
<span class="sd">        this method is limited to a bounding box if the `Model.bounding_box`</span>
<span class="sd">        attribute is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            An array that the evaluated model will be added to.  If this is not</span>
<span class="sd">            given (or given as ``None``), a new array will be created.</span>
<span class="sd">        coords : array-like, optional</span>
<span class="sd">            An array to be used to translate from the model&#39;s input coordinates</span>
<span class="sd">            to the ``out`` array. It should have the property that</span>
<span class="sd">            ``self(coords)`` yields the same shape as ``out``.  If ``out`` is</span>
<span class="sd">            not specified, ``coords`` will be used to determine the shape of</span>
<span class="sd">            the returned array. If this is not provided (or None), the model</span>
<span class="sd">            will be evaluated on a grid determined by `Model.bounding_box`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            The model added to ``out`` if  ``out`` is not ``None``, or else a</span>
<span class="sd">            new array from evaluating the model over ``coords``.</span>
<span class="sd">            If ``out`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">            limited to the `Model.bounding_box` limits. If</span>
<span class="sd">            `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be</span>
<span class="sd">            passed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``coords`` are not given and the the `Model.bounding_box` of</span>
<span class="sd">            this model is not set.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`astropy:bounding-boxes`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">ModelBoundingBox</span><span class="p">):</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set, &#39;</span>
                             <span class="s1">&#39;coords or out must be input.&#39;</span><span class="p">)</span>

        <span class="c1"># for consistent indexing</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Check dimensions match out and model</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndim</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;inconsistent shape of the output.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the array and model must have the same &#39;</span>
                                 <span class="s1">&#39;number of dimensions.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assures position is at center pixel,</span>
            <span class="c1"># important when using add_array.</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">pd</span>

            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;The `bounding_box` is larger than the input out in &#39;</span>
                        <span class="s1">&#39;one or more dimensions. Set &#39;</span>
                        <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_shape</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property is used to indicate what units or sets of units the</span>
<span class="sd">        evaluate method expects, and returns a dictionary mapping inputs to</span>
<span class="sd">        units (or `None` if any units are accepted).</span>

<span class="sd">        Model sub-classes can also use function annotations in evaluate to</span>
<span class="sd">        indicate valid input units, in which case this property should</span>
<span class="sd">        not be overridden since it will return the input units based on the</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_input_units&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_units</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">):</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="o">.</span><span class="vm">__annotations__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">annotations</span><span class="p">:</span>
                <span class="c1"># If there are not annotations for all inputs this will error.</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">annotations</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># None means any unit is accepted</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">return_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property is used to indicate what units or sets of units the</span>
<span class="sd">        output of evaluate should be in, and returns a dictionary mapping</span>
<span class="sd">        outputs to units (or `None` if any units are accepted).</span>

<span class="sd">        Model sub-classes can also use function annotations in evaluate to</span>
<span class="sd">        indicate valid output units, in which case this property should not be</span>
<span class="sd">        overridden since it will return the return units based on the</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_return_units&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_units</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="o">.</span><span class="vm">__annotations__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># None means any unit is accepted</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_prepare_inputs_single_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">broadcasts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># Ensure that array scalars are always upgrade to 1-D arrays for the</span>
            <span class="c1"># sake of consistency with how parameters work.  They will be cast back</span>
            <span class="c1"># to scalars at the end</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">input_shape</span><span class="p">:</span>
                <span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="p">()</span>

            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">:</span>
                        <span class="n">broadcast</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
                <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;self input argument </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="si">!r}</span><span class="s2"> of shape </span><span class="si">{</span><span class="n">input_shape</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;cannot be broadcast with parameter </span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> of shape &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                    <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">broadcast</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                    <span class="n">max_broadcast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">,</span> <span class="n">broadcast</span><span class="p">)</span>

            <span class="n">broadcasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="n">extra_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcasts</span><span class="p">:</span>
                <span class="c1"># If there were no inputs then the broadcasts list is empty</span>
                <span class="c1"># just add a None since there is no broadcasting of outputs and</span>
                <span class="c1"># inputs necessary (see _prepare_outputs_single_self)</span>
                <span class="n">broadcasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">broadcasts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">broadcasts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">extra_outputs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="n">broadcasts</span><span class="p">,)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_remove_axes_from_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a shape tuple as the first input, construct a new one by  removing</span>
<span class="sd">        that particular axis from the shape and all preceeding axes. Negative axis</span>
<span class="sd">        numbers are permittted, where the axis is relative to the last axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shape</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis</span>
            <span class="k">return</span> <span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">shape</span>

    <span class="k">def</span> <span class="nf">_prepare_inputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">model_set_axis_input</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">reshaped</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pivots</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">model_set_axis_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span>  <span class="c1"># needed to reshape param</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
            <span class="n">max_param_shape</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis_input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Use the shape of the input *excluding* the model axis</span>
                <span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">model_set_axis_input</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis_input</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_remove_axes_from_shape</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                                 <span class="n">model_set_axis_param</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Model input argument </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="si">!r}</span><span class="s2"> of shape </span><span class="si">{</span><span class="n">input_shape</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;cannot be broadcast with parameter </span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> of shape &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_remove_axes_from_shape</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">model_set_axis_param</span><span class="p">)</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">):</span>
                    <span class="n">max_param_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_axes_from_shape</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                                   <span class="n">model_set_axis_param</span><span class="p">)</span>

            <span class="c1"># We&#39;ve now determined that, excluding the model_set_axis, the</span>
            <span class="c1"># input can broadcast with all the parameters</span>
            <span class="n">input_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">model_set_axis_input</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">input_ndim</span><span class="p">:</span>
                    <span class="c1"># Just needs to prepend new axes to the input</span>
                    <span class="n">n_new_axes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                    <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">model_set_axis_param</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">input_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span>
                                 <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span><span class="p">:])</span>
                <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">input_ndim</span><span class="p">:</span>
                    <span class="n">n_new_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span>
                    <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_axes</span> <span class="o">+</span>
                                 <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                    <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">new_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">model_set_axis_input</span><span class="p">,</span>
                                            <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">pivots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span>
            <span class="n">reshaped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_input</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">:</span>
            <span class="n">pivots</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">model_set_axis_input</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">reshaped</span><span class="p">,</span> <span class="p">(</span><span class="n">pivots</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">prepare_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used in `~astropy.modeling.Model.__call__` to ensure</span>
<span class="sd">        that all the inputs to the model can be broadcast into compatible</span>
<span class="sd">        shapes (if one or both of them are input as arrays), particularly if</span>
<span class="sd">        there are more than one parameter sets. This also makes sure that (if</span>
<span class="sd">        applicable) the units of the input will be compatible with the evaluate</span>
<span class="sd">        method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When we instantiate the model class, we make sure that __call__ can</span>
        <span class="c1"># take the following two keyword arguments: model_set_axis and</span>
        <span class="c1"># equivalencies.</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># By default the model_set_axis for the input is assumed to be the</span>
            <span class="c1"># same as that for the parameters the model was defined with</span>
            <span class="c1"># TODO: Ensure that negative model_set_axis arguments are respected</span>
            <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">_input</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">)</span>

        <span class="n">inputs_map</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inputs_map&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_units</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">,</span> <span class="n">inputs_map</span><span class="p">)</span>

        <span class="c1"># The input formatting required for single models versus a multiple</span>
        <span class="c1"># model set are different enough that they&#39;ve been split into separate</span>
        <span class="c1"># subroutines</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_inputs_single_model</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_inputs_model_set</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span>
                                                  <span class="n">model_set_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inputs_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="c1"># Check that the units are correct, if applicable</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If a leaflist is provided that means this is in the context of</span>
            <span class="c1"># a compound model and it is necessary to create the appropriate</span>
            <span class="c1"># alias for the input coordinate name for the equivalencies dict</span>
            <span class="k">if</span> <span class="n">inputs_map</span><span class="p">:</span>
                <span class="n">edict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">mod</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">mod</span><span class="p">:</span>
                        <span class="n">edict</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">equivalencies</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edict</span> <span class="o">=</span> <span class="n">equivalencies</span>
            <span class="c1"># We combine any instance-level input equivalencies with user</span>
            <span class="c1"># specified ones at call-time.</span>
            <span class="n">input_units_equivalencies</span> <span class="o">=</span> <span class="n">_combine_equivalency_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                                                  <span class="n">edict</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">input_units_equivalencies</span><span class="p">)</span>

            <span class="c1"># We now iterate over the different inputs and make sure that their</span>
            <span class="c1"># units are consistent with those specified in input_units.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)):</span>

                <span class="n">input_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">input_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Quantity</span><span class="p">):</span>

                    <span class="c1"># We check for consistency of the units with input_units,</span>
                    <span class="c1"># taking into account any equivalencies</span>

                    <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span>
                            <span class="n">input_unit</span><span class="p">,</span>
                            <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">input_name</span><span class="p">]):</span>

                        <span class="c1"># If equivalencies have been specified, we need to</span>
                        <span class="c1"># convert the input to the input units - this is</span>
                        <span class="c1"># because some equivalencies are non-linear, and</span>
                        <span class="c1"># we need to be sure that we evaluate the model in</span>
                        <span class="c1"># its own frame of reference. If input_units_strict</span>
                        <span class="c1"># is set, we also need to convert to the input units.</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_units_equivalencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">input_units_strict</span><span class="p">[</span><span class="n">input_name</span><span class="p">]):</span>
                            <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">input_unit</span><span class="p">,</span>
                                                     <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span>
                                                         <span class="n">input_name</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="c1"># We consider the following two cases separately so as</span>
                        <span class="c1"># to be able to raise more appropriate/nicer exceptions</span>

                        <span class="k">if</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="n">dimensionless_unscaled</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Units of input &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span><span class="si">}</span><span class="s2">),&quot;</span>
                                             <span class="s2">&quot;could not be converted to &quot;</span>
                                             <span class="s2">&quot;required dimensionless &quot;</span>
                                             <span class="s2">&quot;input&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Units of input &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span><span class="si">}</span><span class="s2">),&quot;</span>
                                             <span class="s2">&quot; could not be &quot;</span>
                                             <span class="s2">&quot;converted to required input&quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot; units of </span><span class="si">{</span><span class="n">input_unit</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">input_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># If we allow dimensionless input, we add the units to the</span>
                    <span class="c1"># input values without conversion, otherwise we raise an</span>
                    <span class="c1"># exception.</span>

                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units_allow_dimensionless</span><span class="p">[</span><span class="n">input_name</span><span class="p">]</span>
                            <span class="ow">and</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dimensionless_unscaled</span>
                            <span class="ow">and</span> <span class="n">input_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Units of input &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;,&quot;</span>
                                             <span class="s2">&quot; (dimensionless), could not be converted to required &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;input units of </span><span class="si">{</span><span class="n">input_unit</span><span class="si">}</span><span class="s2"> &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">input_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inputs</span>

    <span class="k">def</span> <span class="nf">_process_output_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">inputs_are_quantity</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span> <span class="ow">and</span> <span class="n">inputs_are_quantity</span><span class="p">:</span>
            <span class="c1"># We allow a non-iterable unit only if there is one output</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_units</span><span class="p">):</span>
                <span class="n">return_units</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span>

            <span class="n">outputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Quantity</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">return_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">out_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_prepare_output_single_model</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcast_shape</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">output</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_prepare_outputs_single_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">broadcasted_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">broadcasted_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_single_model</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_outputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">):</span>
        <span class="n">pivots</span> <span class="o">=</span> <span class="n">broadcasted_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># If model_set_axis = False was passed then use</span>
        <span class="c1"># self._model_set_axis to format the output.</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="n">pivots</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pivot</span> <span class="o">&lt;</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="n">model_set_axis</span><span class="p">:</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span>
                                           <span class="n">model_set_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_outputs_single_model</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_outputs_model_set</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model.</span>

<span class="sd">        Uses a deep copy so that all model attributes, including parameter</span>
<span class="sd">        values, are copied as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deep copy of this model.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model with a new name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">new_model</span>

    <span class="k">def</span> <span class="nf">coerce_units</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">input_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">input_units_equivalencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">input_units_allow_dimensionless</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attach units to this (unitless) model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_units : dict or tuple, optional</span>
<span class="sd">            Input units to attach.  If dict, each key is the name of a model input,</span>
<span class="sd">            and the value is the unit to attach.  If tuple, the elements are units</span>
<span class="sd">            to attach in order corresponding to `Model.inputs`.</span>
<span class="sd">        return_units : dict or tuple, optional</span>
<span class="sd">            Output units to attach.  If dict, each key is the name of a model output,</span>
<span class="sd">            and the value is the unit to attach.  If tuple, the elements are units</span>
<span class="sd">            to attach in order corresponding to `Model.outputs`.</span>
<span class="sd">        input_units_equivalencies : dict, optional</span>
<span class="sd">            Default equivalencies to apply to input values.  If set, this should be a</span>
<span class="sd">            dictionary where each key is a string that corresponds to one of the</span>
<span class="sd">            model inputs.</span>
<span class="sd">        input_units_allow_dimensionless : bool or dict, optional</span>
<span class="sd">            Allow dimensionless input. If this is True, input values to evaluate will</span>
<span class="sd">            gain the units specified in input_units. If this is a dictionary then it</span>
<span class="sd">            should map input name to a bool to allow dimensionless numbers for that</span>
<span class="sd">            input.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `CompoundModel`</span>
<span class="sd">            A `CompoundModel` composed of the current model plus</span>
<span class="sd">            `~astropy.modeling.mappings.UnitsMapping` model(s) that attach the units.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the current model already has units.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Wrapping a unitless model to require and convert units:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import Polynomial1D</span>
<span class="sd">        &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">        &gt;&gt;&gt; poly = Polynomial1D(1, c0=1, c1=2)</span>
<span class="sd">        &gt;&gt;&gt; model = poly.coerce_units((u.m,), (u.s,))</span>
<span class="sd">        &gt;&gt;&gt; model(u.Quantity(10, u.m))  # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;Quantity 21. s&gt;</span>
<span class="sd">        &gt;&gt;&gt; model(u.Quantity(1000, u.cm))  # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;Quantity 21. s&gt;</span>
<span class="sd">        &gt;&gt;&gt; model(u.Quantity(10, u.cm))  # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;Quantity 1.2 s&gt;</span>

<span class="sd">        Wrapping a unitless model but still permitting unitless input:</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import Polynomial1D</span>
<span class="sd">        &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">        &gt;&gt;&gt; poly = Polynomial1D(1, c0=1, c1=2)</span>
<span class="sd">        &gt;&gt;&gt; model = poly.coerce_units((u.m,), (u.s,), input_units_allow_dimensionless=True)</span>
<span class="sd">        &gt;&gt;&gt; model(u.Quantity(10, u.m))  # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;Quantity 21. s&gt;</span>
<span class="sd">        &gt;&gt;&gt; model(10)  # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;Quantity 21. s&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.mappings</span> <span class="kn">import</span> <span class="n">UnitsMapping</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_units</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_units</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="n">model_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="o">!=</span> <span class="n">dimensionless_unscaled</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify input_units for model with &quot;</span>
                                     <span class="s2">&quot;existing input units&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_units</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">input_units</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;input_units keys (</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_units</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">) &quot;&quot;&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;do not match model inputs (</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;&quot;&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="n">input_units</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_units</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_units</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;input_units length does not match n_inputs: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">, received </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">input_units</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="n">mapping</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">unit</span><span class="p">,</span> <span class="n">model_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">input_units</span><span class="p">))</span>
            <span class="n">input_mapping</span> <span class="o">=</span> <span class="n">UnitsMapping</span><span class="p">(</span>
                <span class="n">mapping</span><span class="p">,</span>
                <span class="n">input_units_equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">,</span>
                <span class="n">input_units_allow_dimensionless</span><span class="o">=</span><span class="n">input_units_allow_dimensionless</span>
            <span class="p">)</span>
            <span class="n">input_mapping</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
            <span class="n">input_mapping</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">input_mapping</span> <span class="o">|</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">return_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_units</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_units</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="n">model_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="o">!=</span> <span class="n">dimensionless_unscaled</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify return_units for model &quot;</span>
                                     <span class="s2">&quot;with existing output units&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_units</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">return_units</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;return_units keys (</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">return_units</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">) &quot;&quot;&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;do not match model outputs (</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;&quot;&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="n">return_units</span> <span class="o">=</span> <span class="p">[</span><span class="n">return_units</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_units</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;return_units length does not match n_outputs: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="si">}</span><span class="s2">, received </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">return_units</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="n">mapping</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">model_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">unit</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">return_units</span><span class="p">))</span>
            <span class="n">return_mapping</span> <span class="o">=</span> <span class="n">UnitsMapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
            <span class="n">return_mapping</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>
            <span class="n">return_mapping</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|</span> <span class="n">return_mapping</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of components in a single model, which is</span>
<span class="sd">        obviously 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_initialize_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop parameter constraint values off the keyword arguments passed to</span>
<span class="sd">        `Model.__init__` and store them in private instance attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Pop any constraints off the keyword arguments</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">for</span> <span class="n">ckey</span><span class="p">,</span> <span class="n">cvalue</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ckey</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mconstraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_initialize_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the _parameters array that stores raw parameter values for</span>
<span class="sd">        all parameter sets for use with vectorized fitting algorithms; on</span>
<span class="sd">        FittableModels the _param_name attributes actually just reference</span>
<span class="sd">        slices of this array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_models&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n_models</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;n_models must be either None (in which case it is &quot;</span>
                <span class="s2">&quot;determined from the model_set_axis of the parameter initial &quot;</span>
                <span class="s2">&quot;values) or it must be a positive integer &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(got </span><span class="si">{</span><span class="n">n_models</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Default to zero</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise disable</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;model_set_axis must be either False or an integer &quot;</span>
                    <span class="s2">&quot;specifying the parameter array axis to map to each &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;model in a set of models (got </span><span class="si">{</span><span class="n">model_set_axis</span><span class="si">!r}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="c1"># Process positional arguments by matching them up with the</span>
        <span class="c1"># corresponding parameters in self.param_names--if any also appear as</span>
        <span class="c1"># keyword arguments this presents a conflict</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.__init__() takes at most &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> positional arguments (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2"> given)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">model_set_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># A value of None implies using the default value, if exists</span>
                <span class="k">continue</span>
            <span class="c1"># We use quantity_asanyarray here instead of np.asanyarray because</span>
            <span class="c1"># if any of the arguments are quantities, we need to return a</span>
            <span class="c1"># Quantity object not a plain Numpy array.</span>
            <span class="n">param_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">quantity_asanyarray</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_value</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># At this point the only remaining keyword arguments should be</span>
        <span class="c1"># parameter names; any others are in error.</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.__init__() got multiple values for parameter &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param_name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># We use quantity_asanyarray here instead of np.asanyarray</span>
                <span class="c1"># because if any of the arguments are quantities, we need</span>
                <span class="c1"># to return a Quantity object not a plain Numpy array.</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">quantity_asanyarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_value</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Now deal with case where param_name is not supplied by args or kwargs</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_value</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># If any keyword arguments were left over at this point they are</span>
            <span class="c1"># invalid--the base class should only be passed the parameter</span>
            <span class="c1"># values, constraints, and param_dim</span>
            <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="c1"># Just raise an error on the first unrecognized argument</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.__init__() got an unrecognized parameter &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kwarg</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Determine the number of model sets: If the model_set_axis is</span>
        <span class="c1"># None then there is just one parameter set; otherwise it is determined</span>
        <span class="c1"># by the size of that axis on the first parameter--if the other</span>
        <span class="c1"># parameters don&#39;t have the right number of axes or the sizes of their</span>
        <span class="c1"># model_set_axis don&#39;t match an error is raised</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">max_ndim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">param_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">min_ndim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="s2">&quot;All parameter values must be arrays of dimension &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;at least </span><span class="si">{</span><span class="n">min_ndim</span><span class="si">}</span><span class="s2"> for model_set_axis=</span><span class="si">{</span><span class="n">model_set_axis</span><span class="si">}</span><span class="s2"> (the value &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;given for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is only </span><span class="si">{</span><span class="n">param_ndim</span><span class="si">}</span><span class="s2">-dimensional)&quot;</span><span class="p">)</span>

                <span class="n">max_ndim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_ndim</span><span class="p">,</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Use the dimensions of the first parameter to determine</span>
                    <span class="c1"># the number of model sets</span>
                    <span class="n">n_models</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Inconsistent dimensions for parameter </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> for &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_models</span><span class="si">}</span><span class="s2"> model sets.  The length of axis </span><span class="si">{</span><span class="n">model_set_axis</span><span class="si">}</span><span class="s2"> must be the &quot;</span>
                        <span class="s2">&quot;same for all input parameter values&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="n">max_ndim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_models</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="n">n_models</span>
        <span class="c1"># now validate parameters</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_parameter_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mostly deals with consistency checks and determining unit issues.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
        <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
        <span class="c1"># Use default if value is not provided</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>
            <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># No value was supplied for the parameter and the</span>
                <span class="c1"># parameter does not have a default, therefore the model</span>
                <span class="c1"># is underspecified</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.__init__() requires a value for &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;parameter </span><span class="si">{</span><span class="n">param_name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">default</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.__init__() requires a Quantity for parameter &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param_name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">param</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_val</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">unit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_val</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_val</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="o">=</span> <span class="n">_val</span><span class="o">.</span><span class="n">unit</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_internal_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_val</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">param</span><span class="o">.</span><span class="n">_internal_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">param_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">param_size</span><span class="p">)</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_slice</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_shape</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_size</span>
            <span class="n">total_size</span> <span class="o">+=</span> <span class="n">param_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parameters_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Now set the parameter values (this will also fill</span>
        <span class="c1"># self._parameters)</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Finally validate all the parameters; we do this last so that</span>
        <span class="c1"># validators that depend on one of the other parameters&#39; values will</span>
        <span class="c1"># work</span>

    <span class="k">def</span> <span class="nf">_array_to_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]]</span>
            <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
            <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_check_param_broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_ndim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This subroutine checks that all parameter arrays can be broadcast</span>
<span class="sd">        against each other, and determines the shapes parameters must have in</span>
<span class="sd">        order to broadcast correctly.</span>

<span class="sd">        If model_set_axis is None this merely checks that the parameters</span>
<span class="sd">        broadcast and returns an empty dict if so.  This mode is only used for</span>
<span class="sd">        single model sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_ndim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">max_ndim</span><span class="p">:</span>
                <span class="c1"># All arrays have the same number of dimensions up to the</span>
                <span class="c1"># model_set_axis dimension, but after that they may have a</span>
                <span class="c1"># different number of trailing axes.  The number of trailing</span>
                <span class="c1"># axes must be extended for mutual compatibility.  For example</span>
                <span class="c1"># if max_ndim = 3 and model_set_axis = 0, an array with the</span>
                <span class="c1"># shape (2, 2) must be extended to (2, 1, 2).  However, an</span>
                <span class="c1"># array with shape (2,) is extended to (2, 1).</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_ndim</span> <span class="o">-</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Just need to prepend axes to make up the difference</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">param_shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">param_shape</span><span class="p">[:</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">new_axes</span> <span class="o">+</span>
                                       <span class="n">param_shape</span><span class="p">[</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;broadcast_shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_shape</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>

        <span class="c1"># Now check mutual broadcastability of all shapes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">IncompatibleShapeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">shape_a</span><span class="p">,</span> <span class="n">shape_a_idx</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">,</span> <span class="n">shape_b_idx</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span>
            <span class="n">param_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">shape_a_idx</span><span class="p">]</span>
            <span class="n">param_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">shape_b_idx</span><span class="p">]</span>

            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Parameter </span><span class="si">{</span><span class="n">param_a</span><span class="si">!r}</span><span class="s2"> of shape </span><span class="si">{</span><span class="n">shape_a</span><span class="si">!r}</span><span class="s2"> cannot be broadcast with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;parameter </span><span class="si">{</span><span class="n">param_b</span><span class="si">!r}</span><span class="s2"> of shape </span><span class="si">{</span><span class="n">shape_b</span><span class="si">!r}</span><span class="s2">.  All parameter arrays &quot;</span>
                <span class="s2">&quot;must have shapes that are mutually compatible according &quot;</span>
                <span class="s2">&quot;to the broadcasting rules.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of the Model.param_sets property.</span>

<span class="sd">        This internal implementation has a ``raw`` argument which controls</span>
<span class="sd">        whether or not to return the raw parameter values (i.e. the values that</span>
<span class="sd">        are actually stored in the ._parameters array, as opposed to the values</span>
<span class="sd">        displayed to users.  In most cases these are one in the same but there</span>
<span class="sd">        are currently a few exceptions.</span>

<span class="sd">        Note: This is notably an overcomplicated device and may be removed</span>
<span class="sd">        entirely in the near future.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">raw</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">_setter</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_internal_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>

            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_shape&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

            <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Add a single param set axis to the parameter&#39;s value (thus</span>
                <span class="c1"># converting scalars to shape (1,) array values) for</span>
                <span class="c1"># consistency</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">units</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raw</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">internal_unit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">units</span><span class="p">:</span>
            <span class="c1"># If the parameters are not all the same shape, converting to an</span>
            <span class="c1"># array is going to produce an object array</span>
            <span class="c1"># However the way Numpy creates object arrays is tricky in that it</span>
            <span class="c1"># will recurse into array objects in the list and break them up</span>
            <span class="c1"># into separate objects.  Doing things this way ensures a 1-D</span>
            <span class="c1"># object array the elements of which are the individual parameter</span>
            <span class="c1"># arrays.  There&#39;s not much reason to do this over returning a list</span>
            <span class="c1"># except for consistency</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">psets</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">return</span> <span class="n">psets</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">param_repr_oneline</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">defaults</span> <span class="ow">and</span> <span class="n">defaults</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">kwarg</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_models=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span><span class="si">}</span><span class="s2">)&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__str__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__str__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Inputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Outputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Model set size&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span>
                 <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span>
                 <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keyword</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">defaults</span> <span class="ow">and</span> <span class="n">defaults</span><span class="p">[</span><span class="n">keyword</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Parameters:&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">param_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
            <span class="c1"># Set units on the columns</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">param_table</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">param_table</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FittableModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for models that can be fitted using the built-in fitting</span>
<span class="sd">    algorithms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># derivative with respect to parameters</span>
    <span class="n">fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function (similar to the model&#39;s `~Model.evaluate`) to compute the</span>
<span class="sd">    derivatives of the model with respect to its parameters, for use by fitting</span>
<span class="sd">    algorithms.  In other words, this computes the Jacobian matrix with respect</span>
<span class="sd">    to the model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Flag that indicates if the model derivatives with respect to parameters</span>
    <span class="c1"># are given in columns or rows</span>
    <span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Fittable1DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for one-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_inputs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">n_outputs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">_separable</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Fittable2DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for two-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_inputs</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n_outputs</span> <span class="o">=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_make_arithmetic_operator</span><span class="p">(</span><span class="n">oper</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">make_binary_operator_eval</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">op</span>


<span class="k">def</span> <span class="nf">_composition_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">),</span> <span class="n">params</span><span class="p">),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_join_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c1"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c1"># documentation purposes:</span>
    <span class="c1">#</span>
    <span class="c1">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c1">#</span>
    <span class="c1"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[:</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span>
                                    <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]:],</span> <span class="n">params</span><span class="p">)),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="n">BINARY_OPERATORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">),</span>
    <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">),</span>
    <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">),</span>
    <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">),</span>
    <span class="s1">&#39;**&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">),</span>
    <span class="s1">&#39;|&#39;</span><span class="p">:</span> <span class="n">_composition_operator</span><span class="p">,</span>
    <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span> <span class="n">_join_operator</span>
<span class="p">}</span>

<span class="n">SPECIAL_OPERATORS</span> <span class="o">=</span> <span class="n">_SpecialOperatorsDict</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_add_special_operator</span><span class="p">(</span><span class="n">sop_name</span><span class="p">,</span> <span class="n">sop</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">SPECIAL_OPERATORS</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sop_name</span><span class="p">,</span> <span class="n">sop</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CompoundModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Base class for compound models.</span>

<span class="sd">    While it can be used directly, the recommended way</span>
<span class="sd">    to combine models is through the model operators.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_param_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_submodels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tdict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;fix_inputs&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Both operands must have equal values for n_models&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;fix_inputs&#39;</span> <span class="ow">and</span> <span class="p">((</span><span class="n">left</span><span class="o">.</span><span class="n">model_set_axis</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">)</span>
                                   <span class="ow">or</span> <span class="n">left</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">):</span>  <span class="c1"># not False and not 0</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;model_set_axis must be False or 0 and consistent for operands&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">model_set_axis</span>

        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">SPECIAL_OPERATORS</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span> <span class="ow">or</span>
                    <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s1">&#39;Both operands must match numbers of inputs and outputs&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unsupported operands for |: </span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (n_inputs=</span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;n_outputs=</span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span><span class="si">}</span><span class="s2">) and </span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(n_inputs=</span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">, n_outputs=</span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="si">}</span><span class="s2">); &quot;</span>
                    <span class="s2">&quot;n_outputs for the left-hand model must match n_inputs &quot;</span>
                    <span class="s2">&quot;for the right-hand model.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;First argument to &quot;fix_inputs&quot; must be an instance of &#39;</span>
                                 <span class="s1">&#39;an astropy Model.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected a dictionary for second argument of &quot;fix_inputs&quot;.&#39;</span><span class="p">)</span>

            <span class="c1"># Dict keys must match either possible indices</span>
            <span class="c1"># for model on left side, or names for inputs.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="c1"># Assign directly to the private attribute (instead of using the setter)</span>
            <span class="c1"># to avoid asserting the new number of outputs matches the old one.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span>
            <span class="n">newinputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">input_ind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Substitution key integer value &#39;</span>
                            <span class="s1">&#39;not among possible input choices.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_ind</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate specification of &quot;</span>
                                         <span class="s2">&quot;same input (index/name).&quot;</span><span class="p">)</span>
                    <span class="n">input_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Substitution key string not among possible &#39;</span>
                            <span class="s1">&#39;input choices.&#39;</span><span class="p">)</span>
                    <span class="c1"># Check to see it doesn&#39;t match positional</span>
                    <span class="c1"># specification.</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">input_ind</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate specification of &quot;</span>
                                         <span class="s2">&quot;same input (index/name).&quot;</span><span class="p">)</span>
                    <span class="n">input_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="c1"># Remove substituted inputs</span>
            <span class="n">input_ind</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">input_ind</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">input_ind</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">newinputs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newinputs</span><span class="p">)</span>
            <span class="c1"># Now check to see if the input model has bounding_box defined.</span>
            <span class="c1"># If so, remove the appropriate dimensions and set it for this</span>
            <span class="c1"># instance.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">fix_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s1">&#39;Illegal operator: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">linear</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">linear</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eqcons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ineqcons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_left_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_left_inputs_from_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_right_inputs_from_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="c1"># Args expected to look like (*left inputs, *right inputs, *left params, *right params)</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span> <span class="ow">or</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_left_params_from_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="c1"># Args expected to look like (*left inputs, *right inputs, *left params, *right params)</span>
            <span class="n">n_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="n">n_inputs</span><span class="p">:</span> <span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_left_params</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_left_params</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_right_params_from_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="c1"># Args expected to look like (*left inputs, *right inputs, *left params, *right params)</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_left_params</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_left_params</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">_get_kwarg_model_parameters_as_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># could do it with inserts but rebuilding seems like simpilist way</span>

        <span class="c1"># TODO: Check if any param names are in kwargs maybe as an intersection of sets?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">:</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">])</span>
            <span class="n">args_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">])</span>
            <span class="n">args_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span>

        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">kw_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kw_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">kw_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">args_pos</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Missing parameter or input&quot;</span><span class="p">)</span>

                <span class="n">args_pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_args</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_apply_operators_to_value_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;**&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">leftval</span> <span class="o">=</span> <span class="p">(</span><span class="n">leftval</span><span class="p">,)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rightval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">rightval</span> <span class="o">=</span> <span class="p">(</span><span class="n">rightval</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">leftval</span> <span class="o">+</span> <span class="n">rightval</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">SPECIAL_OPERATORS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binary_operation</span><span class="p">(</span><span class="n">SPECIAL_OPERATORS</span><span class="p">[</span><span class="n">op</span><span class="p">],</span> <span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s1">&#39;Unrecognized operator </span><span class="si">{op}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kwarg_model_parameters_as_positional</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
        <span class="n">left_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_left_inputs_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">left_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_left_params_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="n">pos_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">)))</span>
            <span class="n">fixed_inputs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">else</span> <span class="n">pos_index</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span> <span class="n">value</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">left_inputs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">fixed_inputs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">fixed_inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">inp</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_inputs</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">leftval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">left_inputs</span><span class="p">,</span> <span class="n">left_params</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">leftval</span>

        <span class="n">right_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_right_inputs_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">right_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_right_params_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;|&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="n">right_params</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="o">*</span><span class="n">right_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rightval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">right_inputs</span><span class="p">,</span> <span class="n">right_params</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_operators_to_value_lists</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">submodel_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the names of submodels in a ``CompoundModel``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">]</span>
        <span class="n">nonecount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;None_</span><span class="si">{</span><span class="n">nonecount</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">nonecount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newnames</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">both_inverses_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if both members of this compound model have inverses return True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyDeprecationWarning</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;CompoundModel.both_inverses_exist is deprecated. &quot;</span>
            <span class="s2">&quot;Use has_inverse instead.&quot;</span><span class="p">,</span>
            <span class="n">AstropyDeprecationWarning</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inverse</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_pre_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CompoundModel specific input setup that needs to occur prior to</span>
<span class="sd">            model evaluation.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">            All of the _pre_evaluate for each component model will be</span>
<span class="sd">            performed at the time that the individual model is evaluated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If equivalencies are provided, necessary to map parameters and pass</span>
        <span class="c1"># the leaflist as a keyword input for use by model evaluation so that</span>
        <span class="c1"># the compound model input names can be matched to the model input</span>
        <span class="c1"># names.</span>
        <span class="k">if</span> <span class="s1">&#39;equivalencies&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># Restructure to be useful for the individual model lookup</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inputs_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span> <span class="k">for</span>
                                    <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="c1"># Setup actual model evaluation method</span>
        <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">_inputs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_argnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;No inputs should be used to determine input_shape when handling compound models&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">_post_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">broadcasted_shapes</span><span class="p">,</span> <span class="n">with_bbox</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CompoundModel specific post evaluation processing of outputs</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">            All of the _post_evaluate for each component model will be</span>
<span class="sd">            performed at the time that the individual model is evaluated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_box</span><span class="p">(</span><span class="n">with_bbox</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="n">leftval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
                    <span class="n">rightval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rightval</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">leftval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">]),</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="n">rightval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:]),</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s2">&quot;|&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_operators_to_value_lists</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="n">rightval</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">*</span><span class="n">leftval</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">leftval</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">subinds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">subvals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">subs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="n">subinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">subinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">subvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Turn inputs specified in kw into positional indices.</span>
            <span class="c1"># Names for compound inputs do not propagate to sub models.</span>
            <span class="n">kwind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kwval</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">kwkey</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">kwkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kwkey</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Keyword argument duplicates &quot;</span>
                                         <span class="s2">&quot;positional value supplied.&quot;</span><span class="p">)</span>
                    <span class="n">kwind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                    <span class="n">kwval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="n">kwkey</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">kw</span><span class="p">[</span><span class="n">kwkey</span><span class="p">]</span>
            <span class="c1"># Build new argument list</span>
            <span class="c1"># Append keyword specified args first</span>
            <span class="k">if</span> <span class="n">kwind</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">kwind</span><span class="p">,</span> <span class="n">kwval</span><span class="p">))</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">kwindsorted</span><span class="p">,</span> <span class="n">kwvalsorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="n">newargs</span> <span class="o">=</span> <span class="n">newargs</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwvalsorted</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subinds</span><span class="p">:</span>
                <span class="n">subargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">subinds</span><span class="p">,</span> <span class="n">subvals</span><span class="p">))</span>
                <span class="n">subargs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="c1"># subindsorted, subvalsorted = list(zip(*subargs))</span>
                <span class="c1"># The substitutions must be inserted in order</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">subargs</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An ordered list of parameter names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>

    <span class="k">def</span> <span class="nf">_make_leaflist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">leaflist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">make_subtree_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="o">=</span> <span class="n">leaflist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tdict</span> <span class="o">=</span> <span class="n">tdict</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If someone accesses an attribute not already defined, map the</span>
<span class="sd">        parameters, and then see if the requested attribute is one of</span>
<span class="sd">        the parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The following test is needed to avoid infinite recursion</span>
        <span class="c1"># caused by deepcopy. There may be other such cases discovered.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;__setstate__&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attribute &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; not found&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="n">leaflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span>
        <span class="n">tdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tdict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Steps in slices not supported &#39;</span>
                                 <span class="s1">&#39;for compound models&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_index_to_int</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_index_to_int</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Slice endpoint cannot be 0&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span> <span class="o">+</span> <span class="n">stop</span>
            <span class="c1"># now search for matching node:</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>  <span class="c1"># only single value, get leaf instead in code below</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tdict</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">leftind</span><span class="p">,</span> <span class="n">rightind</span> <span class="o">=</span> <span class="n">tdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">leftind</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">rightind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">node</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;No appropriate subtree matches slice&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">leaflist</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">leaflist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_str_index_to_int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;index must be integer, slice, or model name string&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_str_index_to_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">str_index</span><span class="p">):</span>
        <span class="c1"># Search through leaflist for item with that name</span>
        <span class="n">found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nleaf</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">str_index</span><span class="p">:</span>
                <span class="n">found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nleaf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No component with name &#39;</span><span class="si">{</span><span class="n">str_index</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiple components found using &#39;</span><span class="si">{</span><span class="n">str_index</span><span class="si">}</span><span class="s2">&#39; as name</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;at indices </span><span class="si">{</span><span class="n">found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The number of inputs of a model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_inputs</span>

    <span class="nd">@n_inputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_inputs</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The number of outputs of a model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_outputs</span>

    <span class="nd">@n_outputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_outputs</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span>

    <span class="nd">@eqcons</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span>

    <span class="nd">@ineqcons</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eqcons</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">traverse_postorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_operator</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Postorder traversal of the CompoundModel tree.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">(</span><span class="n">include_operator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">(</span><span class="n">include_operator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">include_operator</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_format_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_leaf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">leaf_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">operands</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">format_leaf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">format_leaf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">]&#39;</span>  <span class="c1"># noqa: E731</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_leaf</span><span class="p">(</span><span class="n">leaf_idx</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                <span class="n">leaf_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">right</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="n">OPERATOR_PRECEDENCE</span><span class="p">:</span>
                <span class="n">oper_order</span> <span class="o">=</span> <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">op</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">oper_order</span><span class="p">):</span>
                        <span class="n">left</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">left</span><span class="si">}</span><span class="s1">)&#39;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">op</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">oper_order</span><span class="p">):</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">right</span><span class="si">}</span><span class="s1">)&#39;</span>

                <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">right</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;((</span><span class="si">{</span><span class="n">left</span><span class="si">}</span><span class="s1">),&#39;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">right</span><span class="si">}</span><span class="s1">))&#39;</span>
                <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">]: </span><span class="si">{</span><span class="n">m</span><span class="si">!r}</span><span class="s2">&quot;</span>
                           <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_expression</span><span class="p">()</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_components</span><span class="p">()</span>
        <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Expression&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Components&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">indent</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_format_str</span><span class="p">(</span><span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isleaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inverse</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inverse</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fittable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the fittable attribute on a compound model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">fittable</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fittable</span>

    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">)</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_map_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map all the constituent model parameters to the compound object,</span>
<span class="sd">        renaming as necessary by appending a suffix number.</span>

<span class="sd">        This can be an expensive operation, particularly for a complex</span>
<span class="sd">        expression tree.</span>

<span class="sd">        All the corresponding parameter attributes are created that one</span>
<span class="sd">        expects for the Model class.</span>

<span class="sd">        The parameter objects that the attributes point to are the same</span>
<span class="sd">        objects as in the constiutent models. Changes made to parameter</span>
<span class="sd">        values to either are seen by both.</span>

<span class="sd">        Prior to calling this, none of the associated attributes will</span>
<span class="sd">        exist. This method must be called to make the model usable by</span>
<span class="sd">        fitting engines.</span>

<span class="sd">        If oldnames=True, then parameters are named as in the original</span>
<span class="sd">        implementation of compound models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># do nothing</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_leaflist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">param_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lindex</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">leaf</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                    <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                    <span class="n">new_param_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">lindex</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">new_param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parameters_</span><span class="p">[</span><span class="n">new_param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_param_name</span><span class="p">)</span>
                    <span class="n">param_map</span><span class="p">[</span><span class="n">new_param_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lindex</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_map</span> <span class="o">=</span> <span class="n">param_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_map_inverse</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_map</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_slices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">param_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">param_size</span><span class="p">)</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_slice</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_shape</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_size</span>
            <span class="n">total_size</span> <span class="o">+=</span> <span class="n">param_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_lookup</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">adict</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">adict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">branch</span><span class="p">,</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">inputs_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map the names of the inputs to this ExpressionTree to the inputs to the leaf models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># If we don&#39;t have an operator the mapping is trivial</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">inp</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">r_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>  <span class="c1"># Get from left</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_inputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Get from right</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_inputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">)]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="n">fixed_ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fixed_ind</span><span class="p">]</span>
            <span class="n">inp_ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="n">inp_ind</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inp_ind</span><span class="p">:</span>
                <span class="n">inputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inputs_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">inp</span>
        <span class="k">return</span> <span class="n">inputs_map</span>

    <span class="k">def</span> <span class="nf">_parameter_units_for_data_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_units</span><span class="p">,</span> <span class="n">output_units</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_parameters</span><span class="p">()</span>
        <span class="n">units_for_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">imodel</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaflist</span><span class="p">):</span>
            <span class="n">units_for_data_leaf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_parameter_units_for_data_units</span><span class="p">(</span><span class="n">input_units</span><span class="p">,</span> <span class="n">output_units</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param_leaf</span> <span class="ow">in</span> <span class="n">units_for_data_leaf</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_map_inverse</span><span class="p">[(</span><span class="n">imodel</span><span class="p">,</span> <span class="n">param_leaf</span><span class="p">)]</span>
                <span class="n">units_for_data</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">units_for_data_leaf</span><span class="p">[</span><span class="n">param_leaf</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">units_for_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="n">input_units_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">input_units_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">input_units_dict</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="n">input_units_equivalencies_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_equivalencies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_units_equivalencies_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">input_units_equivalencies_dict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_allow_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_allow_dimensionless</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_units_strict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">inputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_units_strict</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">return_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">outputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">return_units</span><span class="p">[</span><span class="n">orig_key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">orig_key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">outputs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">outputs_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">return_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">outputs_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map the names of the outputs to this ExpressionTree to the outputs to the leaf models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outputs_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># If we don&#39;t have an operator the mapping is trivial</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">}</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">r_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">out</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">r_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>  <span class="c1"># Get from left</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_outputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Get from right</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_outputs_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span>
                            <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">)]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span>
                            <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;fix_inputs&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                <span class="n">l_outputs_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs_map</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_outputs_map</span><span class="p">()[</span><span class="n">out</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outputs_map</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">outputs_map</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flag indicating whether or not a custom bounding_box has been</span>
<span class="sd">        assigned to this model by a user, via assignment to</span>
<span class="sd">        ``model.bounding_box``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a model at fixed positions, respecting the ``bounding_box``.</span>

<span class="sd">        The key difference relative to evaluating the model directly is that</span>
<span class="sd">        this method is limited to a bounding box if the `Model.bounding_box`</span>
<span class="sd">        attribute is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            An array that the evaluated model will be added to.  If this is not</span>
<span class="sd">            given (or given as ``None``), a new array will be created.</span>
<span class="sd">        coords : array-like, optional</span>
<span class="sd">            An array to be used to translate from the model&#39;s input coordinates</span>
<span class="sd">            to the ``out`` array. It should have the property that</span>
<span class="sd">            ``self(coords)`` yields the same shape as ``out``.  If ``out`` is</span>
<span class="sd">            not specified, ``coords`` will be used to determine the shape of</span>
<span class="sd">            the returned array. If this is not provided (or None), the model</span>
<span class="sd">            will be evaluated on a grid determined by `Model.bounding_box`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            The model added to ``out`` if  ``out`` is not ``None``, or else a</span>
<span class="sd">            new array from evaluating the model over ``coords``.</span>
<span class="sd">            If ``out`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">            limited to the `Model.bounding_box` limits. If</span>
<span class="sd">            `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be</span>
<span class="sd">            passed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``coords`` are not given and the the `Model.bounding_box` of</span>
<span class="sd">            this model is not set.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`astropy:bounding-boxes`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_box</span><span class="p">()</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set, &#39;</span>
                             <span class="s1">&#39;coords or out must be input.&#39;</span><span class="p">)</span>

        <span class="c1"># for consistent indexing</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Check dimensions match out and model</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndim</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;inconsistent shape of the output.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the array and model must have the same &#39;</span>
                                 <span class="s1">&#39;number of dimensions.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assures position is at center pixel, important when using</span>
            <span class="c1"># add_array.</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">pd</span>

            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
                <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;The `bounding_box` is larger than the input out in &#39;</span>
                        <span class="s1">&#39;one or more dimensions. Set &#39;</span>
                        <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_shape</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">replace_submodel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new `~astropy.modeling.CompoundModel` instance from an</span>
<span class="sd">        existing CompoundModel, replacing the named submodel with a new model.</span>

<span class="sd">        In order to ensure that inverses and names are kept/reconstructed, it&#39;s</span>
<span class="sd">        necessary to rebuild the CompoundModel from the replaced node all the</span>
<span class="sd">        way back to the base. The original CompoundModel is left untouched.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            name of submodel to be replaced</span>
<span class="sd">        model : `~astropy.modeling.Model`</span>
<span class="sd">            replacement model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">submodels</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">()</span>
                     <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">submodels</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">submodels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one submodel named </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">old_model</span> <span class="o">=</span> <span class="n">submodels</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_model</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;New and old models must have equal values &quot;</span>
                                 <span class="s2">&quot;for n_models&quot;</span><span class="p">)</span>

            <span class="c1"># Do this check first in order to raise a more helpful Exception,</span>
            <span class="c1"># although it would fail trying to construct the new CompoundModel</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="ow">or</span>
                    <span class="n">old_model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;New model must match numbers of inputs and &quot;</span>
                                 <span class="s2">&quot;outputs of existing model&quot;</span><span class="p">)</span>

            <span class="n">tree</span> <span class="o">=</span> <span class="n">_get_submodel_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">tree</span><span class="p">:</span>
                <span class="n">branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">branch</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">model</span><span class="p">)</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">branch</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">branch</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
                                      <span class="n">name</span><span class="o">=</span><span class="n">branch</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">model</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No submodels found named </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_sub_models_and_parameter_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a work-around to properly set the sub models and respective</span>
<span class="sd">        parameters&#39;s units/values when using ``without_units_for_data``</span>
<span class="sd">        or ``without_units_for_data`` methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">model_parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">parameter</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">model_parameter</span><span class="o">.</span><span class="n">value</span>
            <span class="n">parameter</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">model_parameter</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">without_units_for_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See `~astropy.modeling.Model.without_units_for_data` for overview</span>
<span class="sd">        of this method.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This modifies the behavior of the base method to account for the</span>
<span class="sd">        case where the sub-models of a compound model have different output</span>
<span class="sd">        units. This is only valid for compound * and / compound models as</span>
<span class="sd">        in that case it is reasonable to mix the output units. It does this</span>
<span class="sd">        by modifying the output units of each sub model by using the output</span>
<span class="sd">        units of the other sub model so that we can apply the original function</span>
<span class="sd">        and get the desired result.</span>

<span class="sd">        Additional data has to be output in the mixed output unit case</span>
<span class="sd">        so that the units can be properly rebuilt by</span>
<span class="sd">        `~astropy.modeling.CompoundModel.with_units_from_data`.</span>

<span class="sd">        Outside the mixed output units, this method is identical to the</span>
<span class="sd">        base method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">]:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">inp</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>

            <span class="n">left_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">output_units</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">right_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">output_units</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="n">left_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">/</span> <span class="n">right_units</span><span class="p">[</span><span class="n">out</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
                <span class="n">right_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">/</span> <span class="n">left_units</span><span class="p">[</span><span class="n">out</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">*</span> <span class="n">right_units</span><span class="p">[</span><span class="n">out</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
                <span class="n">right_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">out</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">*</span> <span class="n">left_units</span><span class="p">[</span><span class="n">out</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

            <span class="n">left_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">right_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">without_units_for_data</span><span class="p">(</span><span class="o">**</span><span class="n">left_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">left_kwargs</span><span class="p">[</span><span class="s1">&#39;_left_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">left_kwargs</span><span class="p">[</span><span class="s1">&#39;_right_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">without_units_for_data</span><span class="p">(</span><span class="o">**</span><span class="n">right_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">right_kwargs</span><span class="p">[</span><span class="s1">&#39;_left_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">right_kwargs</span><span class="p">[</span><span class="s1">&#39;_right_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">model</span><span class="o">.</span><span class="n">_set_sub_models_and_parameter_units</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">left_kwargs</span><span class="p">,</span> <span class="n">right_kwargs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">without_units_for_data</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_units_from_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See `~astropy.modeling.Model.with_units_from_data` for overview</span>
<span class="sd">        of this method.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This modifies the behavior of the base method to account for the</span>
<span class="sd">        case where the sub-models of a compound model have different output</span>
<span class="sd">        units. This is only valid for compound * and / compound models as</span>
<span class="sd">        in that case it is reasonable to mix the output units. In order to</span>
<span class="sd">        do this it requires some additional information output by</span>
<span class="sd">        `~astropy.modeling.CompoundModel.without_units_for_data` passed as</span>
<span class="sd">        keyword arguments under the keywords ``_left_kwargs`` and ``_right_kwargs``.</span>

<span class="sd">        Outside the mixed output units, this method is identical to the</span>
<span class="sd">        base method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">]:</span>
            <span class="n">left_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_left_kwargs&#39;</span><span class="p">)</span>
            <span class="n">right_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_right_kwargs&#39;</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">with_units_from_data</span><span class="p">(</span><span class="o">**</span><span class="n">left_kwargs</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">with_units_from_data</span><span class="p">(</span><span class="o">**</span><span class="n">right_kwargs</span><span class="p">)</span>

            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_set_sub_models_and_parameter_units</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">with_units_from_data</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_submodel_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the route down a CompoundModel&#39;s tree to the model with the</span>
<span class="sd">    specified name (whether it&#39;s a leaf or not)&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_get_submodel_path</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_get_submodel_path</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">def</span> <span class="nf">binary_operation</span><span class="p">(</span><span class="n">binoperator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform binary operation. Operands may be matching tuples of operands.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">binoperator</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">binoperator</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_ops</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">opset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursive function to collect operators used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">CompoundModel</span><span class="p">):</span>
        <span class="n">opset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
        <span class="n">get_ops</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">opset</span><span class="p">)</span>
        <span class="n">get_ops</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">opset</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span>


<span class="k">def</span> <span class="nf">make_subtree_dict</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">nodepath</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Traverse a tree noting each node by a key that indicates all the</span>
<span class="sd">    left/right choices necessary to reach that node. Each key will</span>
<span class="sd">    reference a tuple that contains:</span>

<span class="sd">    - reference to the compound model for that node.</span>
<span class="sd">    - left most index contained within that subtree</span>
<span class="sd">       (relative to all indices for the whole tree)</span>
<span class="sd">    - right most index contained within that subtree</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># if this is a leaf, just append it to the leaflist</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s1">&#39;isleaf&#39;</span><span class="p">):</span>
        <span class="n">leaflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">leftmostind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span>
        <span class="n">make_subtree_dict</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">nodepath</span><span class="o">+</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">)</span>
        <span class="n">make_subtree_dict</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">nodepath</span><span class="o">+</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">tdict</span><span class="p">,</span> <span class="n">leaflist</span><span class="p">)</span>
        <span class="n">rightmostind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">tdict</span><span class="p">[</span><span class="n">nodepath</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">leftmostind</span><span class="p">,</span> <span class="n">rightmostind</span><span class="p">)</span>


<span class="n">_ORDER_OF_OPERATORS</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,)]</span>
<span class="n">OPERATOR_PRECEDENCE</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_ORDER_OF_OPERATORS</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
<span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">ops</span>


<span class="k">def</span> <span class="nf">fix_inputs</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">bounding_boxes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">selector_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a compound model with one or more of the input</span>
<span class="sd">    values of the input model assigned fixed values (scalar or array).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    modelinstance : `~astropy.modeling.Model` instance</span>
<span class="sd">        This is the model that one or more of the</span>
<span class="sd">        model input values will be fixed to some constant value.</span>
<span class="sd">    values : dict</span>
<span class="sd">        A dictionary where the key identifies which input to fix</span>
<span class="sd">        and its value is the value to fix it at. The key may either be the</span>
<span class="sd">        name of the input or a number reflecting its order in the inputs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from astropy.modeling.models import Gaussian2D</span>
<span class="sd">    &gt;&gt;&gt; g = Gaussian2D(1, 2, 3, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; gv = fix_inputs(g, {0: 2.5})</span>

<span class="sd">    Results in a 1D function equivalent to Gaussian2D(1, 2, 3, 4, 5)(x=2.5, y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="s1">&#39;fix_inputs&#39;</span><span class="p">,</span> <span class="n">modelinstance</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bounding_boxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">selector_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selector_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">CompoundBoundingBox</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span> <span class="n">bounding_boxes</span><span class="p">,</span> <span class="n">selector_args</span><span class="p">)</span>
        <span class="n">_selector</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">selector_args</span><span class="o">.</span><span class="n">get_fixed_values</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

        <span class="n">new_bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">_selector</span><span class="p">]</span>
        <span class="n">new_bbox</span> <span class="o">=</span> <span class="n">new_bbox</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">new_bbox</span><span class="p">)</span>

        <span class="n">model</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">new_bbox</span>
    <span class="k">return</span> <span class="n">model</span>


<span class="k">def</span> <span class="nf">bind_bounding_box</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">ignored</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set a validated bounding box to a model instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    modelinstance : `~astropy.modeling.Model` instance</span>
<span class="sd">        This is the model that the validated bounding box will be set on.</span>
<span class="sd">    bounding_box : tuple</span>
<span class="sd">        A bounding box tuple, see :ref:`astropy:bounding-boxes` for details</span>
<span class="sd">    ignored : list</span>
<span class="sd">        List of the inputs to be ignored by the bounding box.</span>
<span class="sd">    order : str, optional</span>
<span class="sd">        The ordering of the bounding box tuple, can be either ``&#39;C&#39;`` or</span>
<span class="sd">        ``&#39;F&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modelinstance</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">ModelBoundingBox</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span>
                                                           <span class="n">bounding_box</span><span class="p">,</span>
                                                           <span class="n">ignored</span><span class="o">=</span><span class="n">ignored</span><span class="p">,</span>
                                                           <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bind_compound_bounding_box</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span> <span class="n">bounding_boxes</span><span class="p">,</span> <span class="n">selector_args</span><span class="p">,</span>
                               <span class="n">create_selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignored</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a validated compound bounding box to a model instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    modelinstance : `~astropy.modeling.Model` instance</span>
<span class="sd">        This is the model that the validated compound bounding box will be set on.</span>
<span class="sd">    bounding_boxes : dict</span>
<span class="sd">        A dictionary of bounding box tuples, see :ref:`astropy:bounding-boxes`</span>
<span class="sd">        for details.</span>
<span class="sd">    selector_args : list</span>
<span class="sd">        List of selector argument tuples to define selection for compound</span>
<span class="sd">        bounding box, see :ref:`astropy:bounding-boxes` for details.</span>
<span class="sd">    create_selector : callable, optional</span>
<span class="sd">        An optional callable with interface (selector_value, model) which</span>
<span class="sd">        can generate a bounding box based on a selector value and model if</span>
<span class="sd">        there is no bounding box in the compound bounding box listed under</span>
<span class="sd">        that selector value. Default is ``None``, meaning new bounding</span>
<span class="sd">        box entries will not be automatically generated.</span>
<span class="sd">    ignored : list</span>
<span class="sd">        List of the inputs to be ignored by the bounding box.</span>
<span class="sd">    order : str, optional</span>
<span class="sd">        The ordering of the bounding box tuple, can be either ``&#39;C&#39;`` or</span>
<span class="sd">        ``&#39;F&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modelinstance</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">CompoundBoundingBox</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">modelinstance</span><span class="p">,</span>
                                                              <span class="n">bounding_boxes</span><span class="p">,</span> <span class="n">selector_args</span><span class="p">,</span>
                                                              <span class="n">create_selector</span><span class="o">=</span><span class="n">create_selector</span><span class="p">,</span>
                                                              <span class="n">ignored</span><span class="o">=</span><span class="n">ignored</span><span class="p">,</span>
                                                              <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">custom_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a model from a user defined function. The inputs and parameters of</span>
<span class="sd">    the model will be inferred from the arguments of the function.</span>

<span class="sd">    This can be used either as a function or as a decorator.  See below for</span>
<span class="sd">    examples of both usages.</span>

<span class="sd">    The model is separable only if there is a single input.</span>

<span class="sd">    .. note::</span>

<span class="sd">        All model parameters have to be defined as keyword arguments with</span>
<span class="sd">        default values in the model function.  Use `None` as a default argument</span>
<span class="sd">        value if you do not want to have a default value for that parameter.</span>

<span class="sd">        The standard settable model properties can be configured by default</span>
<span class="sd">        using keyword arguments matching the name of the property; however,</span>
<span class="sd">        these values are not set as model &quot;parameters&quot;. Moreover, users</span>
<span class="sd">        cannot use keyword arguments matching non-settable model properties,</span>
<span class="sd">        with the exception of ``n_outputs`` which should be set to the number of</span>
<span class="sd">        outputs of your function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Function which defines the model.  It should take N positional</span>
<span class="sd">        arguments where ``N`` is dimensions of the model (the number of</span>
<span class="sd">        independent variable in the model), and any number of keyword arguments</span>
<span class="sd">        (the parameters).  It must return the value of the model (typically as</span>
<span class="sd">        an array, but can also be a scalar for scalar inputs).  This</span>
<span class="sd">        corresponds to the `~astropy.modeling.Model.evaluate` method.</span>
<span class="sd">    fit_deriv : function, optional</span>
<span class="sd">        Function which defines the Jacobian derivative of the model. I.e., the</span>
<span class="sd">        derivative with respect to the *parameters* of the model.  It should</span>
<span class="sd">        have the same argument signature as ``func``, but should return a</span>
<span class="sd">        sequence where each element of the sequence is the derivative</span>
<span class="sd">        with respect to the corresponding argument. This corresponds to the</span>
<span class="sd">        :meth:`~astropy.modeling.FittableModel.fit_deriv` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define a sinusoidal model function as a custom 1D model::</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import custom_model</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; def sine_model(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return amplitude * np.sin(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; def sine_deriv(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return 2 * np.pi * amplitude * np.cos(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; SineModel = custom_model(sine_model, fit_deriv=sine_deriv)</span>

<span class="sd">    Create an instance of the custom model and evaluate it::</span>

<span class="sd">        &gt;&gt;&gt; model = SineModel()</span>
<span class="sd">        &gt;&gt;&gt; model(0.25)</span>
<span class="sd">        1.0</span>

<span class="sd">    This model instance can now be used like a usual astropy model.</span>

<span class="sd">    The next example demonstrates a 2D Moffat function model, and also</span>
<span class="sd">    demonstrates the support for docstrings (this example could also include</span>
<span class="sd">    a derivative, but it has been omitted for simplicity)::</span>

<span class="sd">        &gt;&gt;&gt; @custom_model</span>
<span class="sd">        ... def Moffat2D(x, y, amplitude=1.0, x_0=0.0, y_0=0.0, gamma=1.0,</span>
<span class="sd">        ...            alpha=1.0):</span>
<span class="sd">        ...     \&quot;\&quot;\&quot;Two dimensional Moffat function.\&quot;\&quot;\&quot;</span>
<span class="sd">        ...     rr_gg = ((x - x_0) ** 2 + (y - y_0) ** 2) / gamma ** 2</span>
<span class="sd">        ...     return amplitude * (1 + rr_gg) ** (-alpha)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; print(Moffat2D.__doc__)</span>
<span class="sd">        Two dimensional Moffat function.</span>
<span class="sd">        &gt;&gt;&gt; model = Moffat2D()</span>
<span class="sd">        &gt;&gt;&gt; model(1, 1)  # doctest: +FLOAT_CMP</span>
<span class="sd">        0.3333333333333333</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">_custom_model_wrapper</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_custom_model_wrapper</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> takes at most one positional argument (the callable/&quot;</span>
            <span class="s2">&quot;function to be turned into a model.  When used as a decorator &quot;</span>
            <span class="s2">&quot;it should be passed keyword arguments only (if &quot;</span>
            <span class="s2">&quot;any).&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_custom_model_inputs</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes the inputs to the `custom_model`&#39;s function into the appropriate</span>
<span class="sd">    categories.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inputs : list</span>
<span class="sd">        list of evaluation inputs</span>
<span class="sd">    special_params : dict</span>
<span class="sd">        dictionary of model properties which require special treatment</span>
<span class="sd">    settable_params : dict</span>
<span class="sd">        dictionary of defaults for settable model properties</span>
<span class="sd">    params : dict</span>
<span class="sd">        dictionary of model parameters set by `custom_model`&#39;s function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inputs</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">get_inputs_and_params</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">special</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;n_outputs&#39;</span><span class="p">]</span>
    <span class="n">settable</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">Model</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">Model</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">special</span><span class="p">]</span>

    <span class="n">special_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">settable_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">special</span><span class="p">:</span>
            <span class="n">special_params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>
        <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">settable</span><span class="p">:</span>
            <span class="n">settable_params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>
        <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter &#39;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; cannot be a model property: </span><span class="si">{</span><span class="n">properties</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>

    <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">special_params</span><span class="p">,</span> <span class="n">settable_params</span><span class="p">,</span> <span class="n">params</span>


<span class="k">def</span> <span class="nf">_custom_model_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal implementation `custom_model`.</span>

<span class="sd">    When `custom_model` is called as a function its arguments are passed to</span>
<span class="sd">    this function, and the result of this function is returned.</span>

<span class="sd">    When `custom_model` is used as a decorator a partial evaluation of this</span>
<span class="sd">    function is returned by `custom_model`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s2">&quot;func is not callable; it must be a function or other callable &quot;</span>
            <span class="s2">&quot;object&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s2">&quot;fit_deriv not callable; it must be a function or other &quot;</span>
            <span class="s2">&quot;callable object&quot;</span><span class="p">)</span>

    <span class="n">model_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">inputs</span><span class="p">,</span> <span class="n">special_params</span><span class="p">,</span> <span class="n">settable_params</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">_custom_model_inputs</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fit_deriv</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s2">&quot;derivative function should accept &quot;</span>
                                   <span class="s2">&quot;same number of parameters as func.&quot;</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span>

    <span class="n">members</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">),</span>
        <span class="s1">&#39;__doc__&#39;</span><span class="p">:</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
        <span class="s1">&#39;n_inputs&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">),</span>
        <span class="s1">&#39;n_outputs&#39;</span><span class="p">:</span> <span class="n">special_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_outputs&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="s1">&#39;evaluate&#39;</span><span class="p">:</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
        <span class="s1">&#39;_settable_properties&#39;</span><span class="p">:</span> <span class="n">settable_params</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">members</span><span class="p">[</span><span class="s1">&#39;fit_deriv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">)</span>

    <span class="n">members</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="p">(</span><span class="n">FittableModel</span><span class="p">,),</span> <span class="n">members</span><span class="p">)</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">_separable</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="k">def</span> <span class="nf">render_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates a model on an input array. Evaluation is limited to</span>
<span class="sd">    a bounding box if the `Model.bounding_box` attribute is set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `Model`</span>
<span class="sd">        Model to be evaluated.</span>
<span class="sd">    arr : `numpy.ndarray`, optional</span>
<span class="sd">        Array on which the model is evaluated.</span>
<span class="sd">    coords : array-like, optional</span>
<span class="sd">        Coordinate arrays mapping to ``arr``, such that</span>
<span class="sd">        ``arr[coords] == arr``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        The model evaluated on the input ``arr`` or a new array from</span>
<span class="sd">        ``coords``.</span>
<span class="sd">        If ``arr`` and ``coords`` are both `None`, the returned array is</span>
<span class="sd">        limited to the `Model.bounding_box` limits. If</span>
<span class="sd">        `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be passed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    :ref:`astropy:bounding-boxes`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bbox</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bounding_box</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If no bounding_box is set,&#39;</span>
                         <span class="s1">&#39;coords or arr must be input.&#39;</span><span class="p">)</span>

    <span class="c1"># for consistent indexing</span>
    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Check dimensions match model</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;number of array dimensions inconsistent with &#39;</span>
                             <span class="s1">&#39;number of model inputs.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check dimensions match arr and model</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;coordinate length inconsistent with the number &#39;</span>
                             <span class="s1">&#39;of model inputs.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;coordinate shape inconsistent with the &#39;</span>
                                 <span class="s1">&#39;array shape.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assures position is at center pixel, important when using add_array</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sub_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">extract_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sub_shape</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
            <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

        <span class="n">sub_coords</span> <span class="o">=</span> <span class="n">sub_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">add_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">sub_coords</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The `bounding_box` is larger than the input&#39;</span>
                                 <span class="s1">&#39; arr in one or more dimensions. Set &#39;</span>
                                 <span class="s1">&#39;`model.bounding_box = None`.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im_shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">limits</span><span class="p">]</span>

        <span class="n">arr</span> <span class="o">+=</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">arr</span>


<span class="k">def</span> <span class="nf">hide_inverse</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a convenience function intended to disable automatic generation</span>
<span class="sd">    of the inverse in compound models by disabling one of the constituent</span>
<span class="sd">    model&#39;s inverse. This is to handle cases where user provided inverse</span>
<span class="sd">    functions are not compatible within an expression.</span>

<span class="sd">    Example:</span>
<span class="sd">        compound_model.inverse = hide_inverse(m1) + m2 + m3</span>

<span class="sd">    This will insure that the defined inverse itself won&#39;t attempt to</span>
<span class="sd">    build its own inverse, which would otherwise fail in this example</span>
<span class="sd">    (e.g., m = m1 + m2 + m3 happens to raises an exception for this</span>
<span class="sd">    reason.)</span>

<span class="sd">    Note that this permanently disables it. To prevent that either copy</span>
<span class="sd">    the model or restore the inverse later.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">del</span> <span class="n">model</span><span class="o">.</span><span class="n">inverse</span>
    <span class="k">return</span> <span class="n">model</span>
</pre></div>

              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, The Gammapy developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>