
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gammapy.maps.hpx.geom &#8212; gammapy vX.Y.Z</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/gammapy.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../../_static/gammapy_logo.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/gammapy_logo_nav.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../getting-started/index.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../user-guide/index.html">
  User guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../tutorials/index.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../api-reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../development/index.html">
  Developer guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../release-notes/index.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-primary btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        dev  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables _modules/gammapy/maps/hpx/geom and {'json_url': 'https://docs.gammapy.org/stable/switcher.json', 'version_match': 'dev'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "_modules/gammapy/maps/hpx/geom.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://docs.gammapy.org/stable/switcher.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "_modules/gammapy/maps/hpx/geom.html";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 1.2.dev1112+g3c26600d5 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "dev") {
                node.classList.add("active");
                let btn = document.getElementById("version_switcher_button");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/gammapy/gammapy" rel="noopener" target="_blank" title="Github"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">Github</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/gammapyST" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://gammapy.slack.com/" rel="noopener" target="_blank" title="Slack"><span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for gammapy.maps.hpx.geom</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;Utilities for dealing with HEALPix projections and mappings.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="n">SkyCoord</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span>
<span class="kn">from</span> <span class="nn">gammapy.utils.array</span> <span class="kn">import</span> <span class="n">is_power2</span>
<span class="kn">from</span> <span class="nn">..axes</span> <span class="kn">import</span> <span class="n">MapAxes</span>
<span class="kn">from</span> <span class="nn">..coord</span> <span class="kn">import</span> <span class="n">MapCoord</span><span class="p">,</span> <span class="n">skycoord_to_lonlat</span>
<span class="kn">from</span> <span class="nn">..geom</span> <span class="kn">import</span> <span class="n">Geom</span><span class="p">,</span> <span class="n">pix_tuple_to_idx</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">INVALID_INDEX</span><span class="p">,</span> <span class="n">coordsys_to_frame</span><span class="p">,</span> <span class="n">frame_to_coordsys</span>
<span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">HPX_FITS_CONVENTIONS</span><span class="p">,</span> <span class="n">HpxConv</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">coords_to_vec</span><span class="p">,</span>
    <span class="n">get_nside_from_pix_size</span><span class="p">,</span>
    <span class="n">get_pix_size_from_nside</span><span class="p">,</span>
    <span class="n">get_subpixels</span><span class="p">,</span>
    <span class="n">get_superpixels</span><span class="p">,</span>
    <span class="n">match_hpx_pix</span><span class="p">,</span>
    <span class="n">nside_to_order</span><span class="p">,</span>
    <span class="n">parse_hpxregion</span><span class="p">,</span>
    <span class="n">ravel_hpx_index</span><span class="p">,</span>
    <span class="n">unravel_hpx_index</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Not sure if we should expose this in the docs or not:</span>
<span class="c1"># HPX_FITS_CONVENTIONS, HpxConv</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;HpxGeom&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="HpxGeom"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom">[docs]</a><span class="k">class</span> <span class="nc">HpxGeom</span><span class="p">(</span><span class="n">Geom</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Geometry class for HEALPix maps.</span>

<span class="sd">    This class performs mapping between partial-sky indices (pixel</span>
<span class="sd">    number within a HEALPix region) and all-sky indices (pixel number</span>
<span class="sd">    within an all-sky HEALPix map). Multi-band HEALPix geometries use</span>
<span class="sd">    a global indexing scheme that assigns a unique pixel number based</span>
<span class="sd">    on the all-sky index and band index. In the single-band case the</span>
<span class="sd">    global index is the same as the HEALPix index.</span>

<span class="sd">    By default, the constructor will return an all-sky map.</span>
<span class="sd">    Partial-sky maps can be defined with the ``region`` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nside : `~numpy.ndarray`</span>
<span class="sd">        HEALPix NSIDE parameter, the total number of pixels is</span>
<span class="sd">        12*nside*nside. For multi-dimensional maps one can pass</span>
<span class="sd">        either a single ``nside`` value or a vector of ``nside`` values</span>
<span class="sd">        defining the pixel size for each image plane. If ``nside`` is not</span>
<span class="sd">        a scalar then its dimensionality should match that of the</span>
<span class="sd">        non-spatial axes. If nest is True, ``nside`` must be a power of 2,</span>
<span class="sd">        less than 2**30.</span>
<span class="sd">    nest : bool</span>
<span class="sd">        Indexing scheme. If True, &quot;NESTED&quot; scheme. If False, &quot;RING&quot; scheme.</span>
<span class="sd">    frame : {&quot;icrs&quot;, &quot;galactic&quot;}</span>
<span class="sd">        Coordinate system. Default is &quot;icrs&quot;.</span>
<span class="sd">    region : str or tuple</span>
<span class="sd">        Spatial geometry for partial-sky maps. If None, the map will</span>
<span class="sd">        encompass the whole sky. String input will be parsed</span>
<span class="sd">        according to HPX_REG header keyword conventions. Tuple</span>
<span class="sd">        input can be used to define an explicit list of pixels</span>
<span class="sd">        encompassed by the geometry.</span>
<span class="sd">    axes : list</span>
<span class="sd">        Axes for non-spatial dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_hpx</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_region</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nside</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;icrs&quot;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">healpy.pixelfunc</span> <span class="kn">import</span> <span class="n">check_nside</span>

        <span class="n">check_nside</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="n">nest</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="n">MapAxes</span><span class="o">.</span><span class="n">from_default</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">n_spatial_axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Wrong dimensionality for nside. nside must &quot;</span>
                <span class="s2">&quot;be a scalar or have a dimensionality consistent &quot;</span>
                <span class="s2">&quot;with the axes argument.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nest</span> <span class="o">=</span> <span class="n">nest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">=</span> <span class="n">region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_lookup</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create local-to-global pixel lookup table.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">ipix</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_index_list</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nest</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">nside</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nside</span><span class="o">.</span><span class="n">flat</span>
            <span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ravel_hpx_index</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ipix</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">=</span> <span class="n">region</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indxschm</span> <span class="o">=</span> <span class="s2">&quot;EXPLICIT&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">region</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">region</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">region</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">region</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">region</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">)</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">=</span> <span class="s2">&quot;explicit&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indxschm</span> <span class="o">=</span> <span class="s2">&quot;EXPLICIT&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">)</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indxschm</span> <span class="o">=</span> <span class="s2">&quot;IMPLICIT&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid region string: </span><span class="si">{</span><span class="n">region</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HpxGeom.local_to_global"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.local_to_global">[docs]</a>    <span class="k">def</span> <span class="nf">local_to_global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_local</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a global index (all-sky) from a local (partial-sky) index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx_local : tuple</span>
<span class="sd">            A tuple of pixel indices with local HEALPix pixel indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_global : tuple</span>
<span class="sd">            A tuple of pixel index vectors with global HEALPix pixel indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx_local</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx_local</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_tmp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">idx_local</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">idx_local</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx_tmp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span>

        <span class="n">idx_global</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx_global</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx_local</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span></div>

<div class="viewcode-block" id="HpxGeom.global_to_local"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.global_to_local">[docs]</a>    <span class="k">def</span> <span class="nf">global_to_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_global</span><span class="p">,</span> <span class="n">ravel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute global (all-sky) index from a local (partial-sky) index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx_global : tuple</span>
<span class="sd">            A tuple of pixel indices with global HEALPix pixel indices.</span>
<span class="sd">        ravel : bool, optional</span>
<span class="sd">            Return a raveled index. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_local : tuple</span>
<span class="sd">            A tuple of pixel indices with local HEALPix pixel indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_global</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_global</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">))</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_global</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">idx_global</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx_global</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx_global</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">)</span>
            <span class="n">retval</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx_local</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">retval</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">idx_global</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_local</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">t</span> <span class="o">==</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">idx_local</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_local</span><span class="p">):</span>
            <span class="n">idx_local</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ravel</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx_local</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx_local</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.cutout"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.cutout">[docs]</a>    <span class="k">def</span> <span class="nf">cutout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a cutout around a given position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        position : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            Center position of the cutout region.</span>
<span class="sd">        width : `~astropy.coordinates.Angle` or `~astropy.units.Quantity`</span>
<span class="sd">            Diameter of the circular cutout region.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cutout : `~gammapy.maps.WcsNDMap`</span>
<span class="sd">            Cutout map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only do a cutout from a regular map.&quot;</span><span class="p">)</span>

        <span class="n">width</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="s2">&quot;deg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">nside</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span>
            <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">skydir</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.coord_to_pix"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.coord_to_pix">[docs]</a>    <span class="k">def</span> <span class="nf">coord_to_pix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">MapCoord</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">coords</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">axis_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">names</span>
        <span class="p">)</span><span class="o">.</span><span class="n">broadcasted</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">phi</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">coord_to_idx</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">coord_to_pix</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

            <span class="c1"># FIXME: Figure out how to handle coordinates out of</span>
            <span class="c1"># bounds of non-spatial dimensions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idxs</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>

            <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">)</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">pix</span><span class="p">])</span> <span class="o">+</span> <span class="n">bins</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pix</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">),)</span>

        <span class="k">return</span> <span class="n">pix</span></div>

<div class="viewcode-block" id="HpxGeom.pix_to_coord"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.pix_to_coord">[docs]</a>    <span class="k">def</span> <span class="nf">pix_to_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pix</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
                <span class="n">bins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">]]</span>
                <span class="n">vals</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">pix_to_coord</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">])]</span>

            <span class="n">idxs</span> <span class="o">=</span> <span class="n">pix_tuple_to_idx</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>

            <span class="n">ipix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">ipix</span> <span class="o">==</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span>
            <span class="n">ipix</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pix2ang</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">ipix</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="n">vals</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">float</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ipix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pix2ang</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">ipix</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">theta</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="HpxGeom.pix_to_idx"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.pix_to_idx">[docs]</a>    <span class="k">def</span> <span class="nf">pix_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># FIXME: Look for better method to clip HPX indices</span>
        <span class="c1"># TODO: copy idx to avoid modifying input pix?</span>
        <span class="c1"># pix_tuple_to_idx seems to always make a copy!?</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pix_tuple_to_idx</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
        <span class="n">idx_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_to_local</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nbin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nbin</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_local</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of non-spatial axes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;All axes names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;skycoord&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape of non-spatial axes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape of the `~numpy.ndarray` matching this geometry.&quot;&quot;&quot;</span>
        <span class="n">npix_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">)])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">npix_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">shape</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_shape_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape of data of the non-spatial axes and unit spatial axes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of dimensions as an integer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;HEALPix ordering (&#39;NESTED&#39; or &#39;RING&#39;).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;NESTED&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nest</span> <span class="k">else</span> <span class="s2">&quot;RING&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nside</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;NSIDE in each band.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nside</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The order in each band (``NSIDE = 2 ** ORDER``).</span>

<span class="sd">        Set to -1 for bands with NSIDE that is not a power of 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nside_to_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether HEALPix order is nested as a boolean.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nest</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of pixels in each band.</span>

<span class="sd">        For partial-sky geometries this can</span>
<span class="sd">        be less than the number of pixels for the band NSIDE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npix_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum number of pixels.&quot;&quot;&quot;</span>
        <span class="n">maxpix</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">maxpix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">projection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Map projection.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;HPX&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">region</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Region string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_allsky</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag for all-sky maps.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag identifying whether this geometry is regular in non-spatial dimensions.</span>

<span class="sd">        False for multi-resolution or irregular geometries.</span>
<span class="sd">        If True, all image planes have the same pixel geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">==</span> <span class="s2">&quot;explicit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Map coordinates of the center of the geometry as a tuple.&quot;&quot;&quot;</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">skycoord_to_lonlat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_skydir</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">center_coord</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center_pix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pixel coordinates of the center of the geometry as a tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_to_pix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_coord</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center_skydir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sky coordinate of the center of the geometry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            Center position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: simplify</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">==</span> <span class="s2">&quot;explicit&quot;</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nside</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pix2vec</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">)</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">])</span>
            <span class="n">lonlat</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">vec2ang</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">lonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">lonlat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lonlat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">parse_hpxregion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;DISK&quot;</span><span class="p">,</span> <span class="s2">&quot;DISK_INC&quot;</span><span class="p">]:</span>
                <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;HPX_PIXEL&quot;</span><span class="p">:</span>
                <span class="n">nside_pix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">ipix_pix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;NESTED&quot;</span><span class="p">:</span>
                    <span class="n">nest_pix</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RING&quot;</span><span class="p">:</span>
                    <span class="n">nest_pix</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid ordering scheme: </span><span class="si">{</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pix2ang</span><span class="p">(</span><span class="n">nside_pix</span><span class="p">,</span> <span class="n">ipix_pix</span><span class="p">,</span> <span class="n">nest_pix</span><span class="p">)</span>
                <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span>
                <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;deg&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pixel_scales</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Pixel scale.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        angle: `~astropy.coordinates.Angle`</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_pix_size_from_nside</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span>

<div class="viewcode-block" id="HpxGeom.interp_weights"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.interp_weights">[docs]</a>    <span class="k">def</span> <span class="nf">interp_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get interpolation weights for given coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : `MapCoord` or dict</span>
<span class="sd">            Input coordinates.</span>
<span class="sd">        idxs : `~numpy.ndarray`, optional</span>
<span class="sd">            Indices for non-spatial axes.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        weights : `~numpy.ndarray`</span>
<span class="sd">            Interpolation weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">MapCoord</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span><span class="o">.</span><span class="n">broadcasted</span>

        <span class="k">if</span> <span class="n">idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_to_idx</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">phi</span>

        <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">theta</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">phi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span><span class="p">:</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idxs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>

        <span class="n">pix</span><span class="p">,</span> <span class="n">wts</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">get_interp_weights</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">)</span>
        <span class="n">wts</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pix</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span><span class="p">:</span>
            <span class="n">pix_local</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">global_to_local</span><span class="p">([</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">idxs</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pix_local</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">global_to_local</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">ravel</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="c1"># If a pixel lies outside of the geometry set its index to the center pixel</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">pix_local</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">coords_ctr</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">lat</span><span class="p">]</span>
            <span class="n">coords_ctr</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">pix_to_coord</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">idxs</span><span class="p">)]</span>
            <span class="n">idx_ctr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_to_idx</span><span class="p">(</span><span class="n">coords_ctr</span><span class="p">)</span>
            <span class="n">idx_ctr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_to_local</span><span class="p">(</span><span class="n">idx_ctr</span><span class="p">)</span>
            <span class="n">pix_local</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">pix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))[</span><span class="n">m</span><span class="p">]</span>

        <span class="n">pix_local</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pix_local</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pix_local</span><span class="p">,</span> <span class="n">wts</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ipix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;HEALPix pixel and band indices for every pixel in the map.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">()</span>

<div class="viewcode-block" id="HpxGeom.is_aligned"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.is_aligned">[docs]</a>    <span class="k">def</span> <span class="nf">is_aligned</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if HEALPix geoms and extra axes are aligned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `HpxGeom`</span>
<span class="sd">            Other geometry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aligned : bool</span>
<span class="sd">            Whether geometries are aligned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">otheraxis</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">otheraxis</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">frame</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nest</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nest</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="HpxGeom.to_nside"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_nside">[docs]</a>    <span class="k">def</span> <span class="nf">to_nside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nside</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Upgrade or downgrade the resolution to a given NSIDE.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nside : int</span>
<span class="sd">            HEALPix NSIDE parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geom : `~HpxGeom`</span>
<span class="sd">            A HEALPix geometry object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Upgrade and degrade only implemented for standard maps&quot;</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">nside</span><span class="o">=</span><span class="n">nside</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.to_binsz"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_binsz">[docs]</a>    <span class="k">def</span> <span class="nf">to_binsz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binsz</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change pixel size of the geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binsz : float or `~astropy.units.Quantity`</span>
<span class="sd">            New pixel size. A float is assumed to be in degree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geom : `WcsGeom`</span>
<span class="sd">            Geometry with new pixel size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">binsz</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">binsz</span><span class="p">,</span> <span class="s2">&quot;deg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
                <span class="n">binsz</span><span class="o">=</span><span class="n">binsz</span><span class="p">,</span>
                <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
                <span class="n">skydir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center_skydir</span><span class="p">,</span>
                <span class="n">binsz</span><span class="o">=</span><span class="n">binsz</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="s2">&quot;deg&quot;</span><span class="p">),</span>
                <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.separation"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.separation">[docs]</a>    <span class="k">def</span> <span class="nf">separation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute sky separation with respect to a given center.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            Center position.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        separation : `~astropy.coordinates.Angle`</span>
<span class="sd">            Separation angle array (1D).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_image</span><span class="p">()</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">center</span><span class="o">.</span><span class="n">separation</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">skycoord</span><span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.to_swapped"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_swapped">[docs]</a>    <span class="k">def</span> <span class="nf">to_swapped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Geometry copy with swapped ORDERING (NEST-&gt;RING or vice versa).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geom : `~HpxGeom`</span>
<span class="sd">            A HEALPix geometry object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.to_image"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_image">[docs]</a>    <span class="k">def</span> <span class="nf">to_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.to_cube"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_cube">[docs]</a>    <span class="k">def</span> <span class="nf">to_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="o">+</span> <span class="n">axes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nside</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx_nb</span> <span class="o">=</span> <span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">get_all_neighbours</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">),)</span>
        <span class="n">idx_nb</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">idx_nb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="k">return</span> <span class="n">idx_nb</span>

    <span class="k">def</span> <span class="nf">_pad_spatial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot pad an all-sky map.&quot;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_r</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

        <span class="c1"># TODO: Pre-filter indices to find those close to the edge</span>
        <span class="n">idx_nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_neighbors</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx_nb</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx_nb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pad_width</span><span class="p">):</span>
            <span class="n">mask_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx_nb</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">idx_edge</span> <span class="o">=</span> <span class="n">idx_nb</span><span class="p">[</span><span class="n">mask_edge</span><span class="p">]</span>
            <span class="n">idx_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idx_edge</span><span class="p">)</span>
            <span class="n">idx_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx_r</span><span class="p">,</span> <span class="n">idx_edge</span><span class="p">)))</span>
            <span class="n">idx_nb</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="n">idx_edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
            <span class="n">idx_nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_neighbors</span><span class="p">(</span><span class="n">idx_nb</span><span class="p">)</span>
            <span class="n">idx_nb</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx_nb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="n">idx_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HpxGeom.crop"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.crop">[docs]</a>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop_width</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot crop an all-sky map.&quot;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_r</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

        <span class="c1"># TODO: Pre-filter indices to find those close to the edge</span>
        <span class="n">idx_nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_neighbors</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx_nb</span> <span class="o">=</span> <span class="n">ravel_hpx_index</span><span class="p">(</span><span class="n">idx_nb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">crop_width</span><span class="p">):</span>
            <span class="c1"># Mask of pixels that have at least one neighbor not</span>
            <span class="c1"># contained in the geometry</span>
            <span class="n">mask_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx_nb</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">idx_r</span> <span class="o">=</span> <span class="n">idx_r</span><span class="p">[</span><span class="o">~</span><span class="n">mask_edge</span><span class="p">]</span>
            <span class="n">idx_nb</span> <span class="o">=</span> <span class="n">idx_nb</span><span class="p">[:,</span> <span class="o">~</span><span class="n">mask_edge</span><span class="p">]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="n">idx_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.upsample"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.upsample">[docs]</a>    <span class="k">def</span> <span class="nf">upsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_power2</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Upsample factor must be a power of 2.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
                <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nside</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">idx_new</span> <span class="o">=</span> <span class="n">get_subpixels</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nside</span><span class="p">,</span> <span class="n">nside</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)):</span>
            <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">idx_new</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_new</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.downsample"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.downsample">[docs]</a>    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">axis_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_power2</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Downsample factor must be a power of 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Currently the only valid axis name is None.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">//</span> <span class="n">factor</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
                <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nside</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx_new</span> <span class="o">=</span> <span class="n">get_superpixels</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nside</span><span class="p">,</span> <span class="n">nside</span> <span class="o">//</span> <span class="n">factor</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_new</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">//</span> <span class="n">factor</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.create"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.create">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">nside</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">binsz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;icrs&quot;</span><span class="p">,</span>
        <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">skydir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an HpxGeom object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nside : int or `~numpy.ndarray`, optional</span>
<span class="sd">            HEALPix NSIDE parameter. This parameter sets the size of</span>
<span class="sd">            the spatial pixels in the map. If nest is True, ``nside`` must be a</span>
<span class="sd">            power of 2, less than 2**30.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        binsz : float or `~numpy.ndarray`, optional</span>
<span class="sd">            Approximate pixel size in degrees. An ``nside`` will be</span>
<span class="sd">            chosen that corresponds to a pixel size closest to this</span>
<span class="sd">            value. This option is superseded by ``nside``.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        nest : bool, optional</span>
<span class="sd">            Indexing scheme. If True, &quot;NESTED&quot; scheme. If False, &quot;RING&quot; scheme.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        frame : {&quot;icrs&quot;, &quot;galactic&quot;}, optional</span>
<span class="sd">            Coordinate system, either Galactic (&quot;galactic&quot;) or Equatorial (&quot;icrs&quot;).</span>
<span class="sd">            Default is &quot;icrs&quot;.</span>
<span class="sd">        region : str, optional</span>
<span class="sd">            HEALPix region string. Allows for partial-sky maps. Default is None.</span>
<span class="sd">        axes : list, optional</span>
<span class="sd">            List of axes for non-spatial dimensions. Default is None.</span>
<span class="sd">        skydir : tuple or `~astropy.coordinates.SkyCoord`, optional</span>
<span class="sd">            Sky position of map center. Can be either a SkyCoord</span>
<span class="sd">            object or a tuple of longitude and latitude in deg in the</span>
<span class="sd">            coordinate system of the map. Default is None.</span>
<span class="sd">        width : float, optional</span>
<span class="sd">            Diameter of the map in degrees. If set the map will</span>
<span class="sd">            encompass all pixels within a circular region centered on</span>
<span class="sd">            ``skydir``. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geom : `~HpxGeom`</span>
<span class="sd">            A HEALPix geometry object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from gammapy.maps import HpxGeom, MapAxis</span>
<span class="sd">        &gt;&gt;&gt; axis = MapAxis.from_bounds(0,1,2)</span>
<span class="sd">        &gt;&gt;&gt; geom = HpxGeom.create(nside=16) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; geom = HpxGeom.create(binsz=0.1, width=10.0) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; geom = HpxGeom.create(nside=64, width=10.0, axes=[axis]) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; geom = HpxGeom.create(nside=[32,64], width=10.0, axes=[axis]) # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nside</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">binsz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either nside or binsz must be defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nside</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">binsz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="n">get_nside_from_pix_size</span><span class="p">(</span><span class="n">binsz</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">skydir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">skydir</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">skydir</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">skydir</span><span class="p">,</span> <span class="n">SkyCoord</span><span class="p">):</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">skycoord_to_lonlat</span><span class="p">(</span><span class="n">skydir</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type for skydir: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">skydir</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;DISK(</span><span class="si">{</span><span class="n">lon</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">lat</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="n">nest</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.from_header"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.from_header">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_header</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">hdu_bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an HPX object from a FITS header.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        header : `~astropy.io.fits.Header`</span>
<span class="sd">            The FITS header.</span>
<span class="sd">        hdu_bands : `~astropy.io.fits.BinTableHDU`, optional</span>
<span class="sd">            The BANDS table HDU. Default is None.</span>
<span class="sd">        format : str, optional</span>
<span class="sd">            FITS convention. Default is None.</span>
<span class="sd">            If None the format is guessed. The following</span>
<span class="sd">            formats are supported:</span>

<span class="sd">                - &quot;gadf&quot;</span>
<span class="sd">                - &quot;fgst-ccube&quot;</span>
<span class="sd">                - &quot;fgst-ltcube&quot;</span>
<span class="sd">                - &quot;fgst-bexpcube&quot;</span>
<span class="sd">                - &quot;fgst-srcmap&quot;</span>
<span class="sd">                - &quot;fgst-template&quot;</span>
<span class="sd">                - &quot;fgst-srcmap-sparse&quot;</span>
<span class="sd">                - &quot;galprop&quot;</span>
<span class="sd">                - &quot;galprop2&quot;</span>
<span class="sd">                - &quot;healpy&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hpx : `~HpxGeom`</span>
<span class="sd">            HEALPix geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="n">HpxConv</span><span class="o">.</span><span class="n">identify_hpx_format</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

        <span class="n">conv</span> <span class="o">=</span> <span class="n">HPX_FITS_CONVENTIONS</span><span class="p">[</span><span class="nb">format</span><span class="p">]</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">MapAxes</span><span class="o">.</span><span class="n">from_table_hdu</span><span class="p">(</span><span class="n">hdu_bands</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;PIXTYPE&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;HEALPIX&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid header PIXTYPE: </span><span class="si">{</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXTYPE&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (must be HEALPIX)&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;ORDERING&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RING&quot;</span><span class="p">:</span>
            <span class="n">nest</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;ORDERING&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;NESTED&quot;</span><span class="p">:</span>
            <span class="n">nest</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid header ORDERING: </span><span class="si">{</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;ORDERING&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (must be RING or NESTED)&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">hdu_bands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;NSIDE&quot;</span> <span class="ow">in</span> <span class="n">hdu_bands</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="n">hdu_bands</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;NSIDE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;NSIDE&quot;</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;NSIDE&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;ORDER&quot;</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;ORDER&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to extract NSIDE or ORDER.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">coordsys_to_frame</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">conv</span><span class="o">.</span><span class="n">frame</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;COORDSYS&quot;</span><span class="p">,</span> <span class="s2">&quot;icrs&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;HPX_REG&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">region</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;HPXREGION&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">region</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">nest</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.from_hdu"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.from_hdu">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_hdu</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">hdu</span><span class="p">,</span> <span class="n">hdu_bands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an HPX object from a BinTable HDU.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hdu : `~astropy.io.fits.BinTableHDU`</span>
<span class="sd">            The FITS HDU.</span>
<span class="sd">        hdu_bands : `~astropy.io.fits.BinTableHDU`, optional</span>
<span class="sd">            The BANDS table HDU. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hpx : `~HpxGeom`</span>
<span class="sd">            HEALPix geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: Need correct handling of IMPLICIT and EXPLICIT maps</span>

        <span class="c1"># if HPX region is not defined then geometry is defined by</span>
        <span class="c1"># the set of all pixels in the table</span>
        <span class="k">if</span> <span class="s2">&quot;HPX_REG&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;PIX&quot;</span><span class="p">),</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;CHANNEL&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_header</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">hdu_bands</span><span class="o">=</span><span class="n">hdu_bands</span><span class="p">,</span> <span class="n">pix</span><span class="o">=</span><span class="n">pix</span><span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.to_header"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_header">[docs]</a>    <span class="k">def</span> <span class="nf">to_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;gadf&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build and return FITS header for this HEALPix map.&quot;&quot;&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Header</span><span class="p">()</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="n">HPX_FITS_CONVENTIONS</span><span class="p">[</span><span class="nb">format</span><span class="p">])</span>

        <span class="c1"># FIXME: For some sparse maps we may want to allow EXPLICIT</span>
        <span class="c1"># with an empty region string</span>
        <span class="n">indxschm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;indxschm&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">indxschm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indxschm</span> <span class="o">=</span> <span class="s2">&quot;IMPLICIT&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indxschm</span> <span class="o">=</span> <span class="s2">&quot;EXPLICIT&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indxschm</span> <span class="o">=</span> <span class="s2">&quot;LOCAL&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;FGST&quot;</span> <span class="ow">in</span> <span class="nb">format</span><span class="o">.</span><span class="n">convname</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;TELESCOP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;GLAST&quot;</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;INSTRUME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;LAT&quot;</span>

        <span class="n">header</span><span class="p">[</span><span class="nb">format</span><span class="o">.</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_to_coordsys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;PIXTYPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;HEALPIX&quot;</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;ORDERING&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordering</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;INDXSCHM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indxschm</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;ORDER&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;NSIDE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;FIRSTPIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;LASTPIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;HPX_CONV&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">convname</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="s2">&quot;icrs&quot;</span><span class="p">:</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;EQUINOX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2000.0</span><span class="p">,</span> <span class="s2">&quot;Equinox of RA &amp; DEC specifications&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">:</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;HPX_REG&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region</span>

        <span class="k">return</span> <span class="n">header</span></div>

    <span class="k">def</span> <span class="nf">_make_bands_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;NSIDE&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">cols</span>

<div class="viewcode-block" id="HpxGeom.get_index_list"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.get_index_list">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_index_list</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">nest</span><span class="p">,</span> <span class="n">region</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get list of pixels indices for all the pixels in a region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nside : int</span>
<span class="sd">            HEALPix NSIDE parameter.</span>
<span class="sd">        nest : bool</span>
<span class="sd">            Indexing scheme. If True, &quot;NESTED&quot; scheme. If False, &quot;RING&quot; scheme.</span>
<span class="sd">        region : str</span>
<span class="sd">            HEALPix region string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ilist : `~numpy.ndarray`</span>
<span class="sd">            List of pixel indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="c1"># TODO: this should return something more friendly than a tuple</span>
        <span class="c1"># e.g. a namedtuple or a dict</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">parse_hpxregion</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>

        <span class="n">reg_type</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;DISK&quot;</span><span class="p">:</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">coords_to_vec</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ilist</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">query_disc</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="n">nest</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;DISK_INC&quot;</span><span class="p">:</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">coords_to_vec</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fact</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">ilist</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">query_disc</span><span class="p">(</span>
                <span class="n">nside</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="n">nest</span><span class="p">,</span> <span class="n">fact</span><span class="o">=</span><span class="n">fact</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;HPX_PIXEL&quot;</span><span class="p">:</span>
            <span class="n">nside_pix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;NESTED&quot;</span><span class="p">:</span>
                <span class="n">ipix_ring</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">nest2ring</span><span class="p">(</span><span class="n">nside_pix</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;RING&quot;</span><span class="p">:</span>
                <span class="n">ipix_ring</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid ordering scheme: </span><span class="si">{</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ilist</span> <span class="o">=</span> <span class="n">match_hpx_pix</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">nest</span><span class="p">,</span> <span class="n">nside_pix</span><span class="p">,</span> <span class="n">ipix_ring</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid region type: </span><span class="si">{</span><span class="n">reg_type</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ilist</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Width of the map.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: simplify</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mf">180.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">==</span> <span class="s2">&quot;explicit&quot;</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nside</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pix2ang</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span> <span class="n">lonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ang</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;deg&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dirs</span><span class="o">.</span><span class="n">separation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_skydir</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">parse_hpxregion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;DISK&quot;</span><span class="p">,</span> <span class="s2">&quot;DISK_INC&quot;</span><span class="p">}:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;HPX_PIXEL&quot;</span><span class="p">:</span>
                <span class="n">pix_size</span> <span class="o">=</span> <span class="n">get_pix_size_from_nside</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">width</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pix_size</span>

        <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="s2">&quot;deg&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_nside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>

<div class="viewcode-block" id="HpxGeom.to_wcs_geom"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_wcs_geom">[docs]</a>    <span class="k">def</span> <span class="nf">to_wcs_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="s2">&quot;AIT&quot;</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width_pix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a WCS projection appropriate for this HEALPix pixelization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        proj : str, optional</span>
<span class="sd">            Projection type of WCS geometry.</span>
<span class="sd">            Default is &quot;AIT&quot;.</span>
<span class="sd">        oversample : float, optional</span>
<span class="sd">            Oversampling factor for WCS map. This will be the</span>
<span class="sd">            approximate ratio of the width of a HEALPix pixel to a WCS</span>
<span class="sd">            pixel. If this parameter is None then the width will be</span>
<span class="sd">            set from ``width_pix``.</span>
<span class="sd">            Default is 2.</span>
<span class="sd">        width_pix : int, optional</span>
<span class="sd">            Width of the WCS geometry in pixels. The pixel size will</span>
<span class="sd">            be set to the number of pixels satisfying ``oversample``</span>
<span class="sd">            or ``width_pix`` whichever is smaller. If this parameter</span>
<span class="sd">            is None then the width will be set from ``oversample``.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wcs : `~gammapy.maps.WcsGeom`</span>
<span class="sd">            WCS geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">gammapy.maps</span> <span class="kn">import</span> <span class="n">WcsGeom</span>

        <span class="n">pix_size</span> <span class="o">=</span> <span class="n">get_pix_size_from_nside</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>
        <span class="n">binsz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pix_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">oversample</span>
        <span class="n">width</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="s2">&quot;deg&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pix_size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">width_pix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="n">binsz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">width_pix</span><span class="p">:</span>
            <span class="n">binsz</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">width_pix</span>

        <span class="k">if</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mf">90.0</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">360.0</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="mf">180.0</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">WcsGeom</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">binsz</span><span class="o">=</span><span class="n">binsz</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">skydir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center_skydir</span><span class="p">,</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.to_wcs_tiles"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.to_wcs_tiles">[docs]</a>    <span class="k">def</span> <span class="nf">to_wcs_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nside_tiles</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="s2">&quot;0 deg&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create WCS tiles geometries from HPX geometry with given nside.</span>

<span class="sd">        The HEALPix geom is divide into superpixels defined by ``nside_tiles``,</span>
<span class="sd">        which are then represented by a WCS geometry using a tangential</span>
<span class="sd">        projection. The number of WCS tiles is given by the number of pixels</span>
<span class="sd">        for the given ``nside_tiles``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nside_tiles : int, optional</span>
<span class="sd">            HEALPix NSIDE parameter for super pixel tiles.</span>
<span class="sd">            Default is 4.</span>
<span class="sd">        margin : `~astropy.units.Quantity`, optional</span>
<span class="sd">            Width margin of the WCS tile.</span>
<span class="sd">            Default is &quot;0 deg&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wcs_tiles : list</span>
<span class="sd">            List of WCS tile geometries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>
        <span class="kn">from</span> <span class="nn">gammapy.maps</span> <span class="kn">import</span> <span class="n">WcsGeom</span>

        <span class="n">margin</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">margin</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nside_tiles</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nside_tiles must be &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;to_wcs_tiles() is only supported for all sky geoms&quot;</span><span class="p">)</span>

        <span class="n">binsz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">nside2resol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">))</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span>

        <span class="n">hpx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_image</span><span class="p">()</span><span class="o">.</span><span class="n">to_nside</span><span class="p">(</span><span class="n">nside</span><span class="o">=</span><span class="n">nside_tiles</span><span class="p">)</span>
        <span class="n">wcs_tiles</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">pix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hpx</span><span class="o">.</span><span class="n">npix</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">skydir</span> <span class="o">=</span> <span class="n">hpx</span><span class="o">.</span><span class="n">pix_to_coord</span><span class="p">([</span><span class="n">pix</span><span class="p">])</span>
            <span class="n">vtx</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">boundaries</span><span class="p">(</span><span class="n">nside</span><span class="o">=</span><span class="n">hpx</span><span class="o">.</span><span class="n">nside</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">pix</span><span class="o">=</span><span class="n">pix</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="n">hpx</span><span class="o">.</span><span class="n">nest</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">vec2ang</span><span class="p">(</span><span class="n">vtx</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">boundaries</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">lon</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">lat</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">hpx</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>

            <span class="c1"># Compute maximum separation between all pairs of boundaries and take it</span>
            <span class="c1"># as width</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">boundaries</span><span class="o">.</span><span class="n">separation</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="n">wcs_tile_geom</span> <span class="o">=</span> <span class="n">WcsGeom</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
                <span class="n">skydir</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">skydir</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()),</span> <span class="nb">float</span><span class="p">(</span><span class="n">skydir</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())),</span>
                <span class="n">width</span><span class="o">=</span><span class="n">width</span> <span class="o">+</span> <span class="n">margin</span><span class="p">,</span>
                <span class="n">binsz</span><span class="o">=</span><span class="n">binsz</span><span class="p">,</span>
                <span class="n">frame</span><span class="o">=</span><span class="n">hpx</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span>
                <span class="n">proj</span><span class="o">=</span><span class="s2">&quot;TAN&quot;</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">wcs_tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wcs_tile_geom</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wcs_tiles</span></div>

<div class="viewcode-block" id="HpxGeom.get_idx"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.get_idx">[docs]</a>    <span class="k">def</span> <span class="nf">get_idx</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">axis_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># TODO: simplify this!!!</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image index out of range: </span><span class="si">{</span><span class="n">idx</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Regular all- and partial-sky maps</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">))]</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span> <span class="ow">and</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">axis_name</span><span class="p">:</span>
                        <span class="n">pix</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">nbin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pix</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">nbin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pix</span> <span class="o">+=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>

            <span class="n">pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">pix</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_to_global</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>

        <span class="c1"># Non-regular all-sky</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span><span class="p">:</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">idx_img</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">idx_img</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">npix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">[</span><span class="n">idx_img</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">s_img</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npix</span><span class="p">),)</span> <span class="o">+</span> <span class="n">idx_img</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s_img</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npix</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

                <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">s_img</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">[</span><span class="n">idx_img</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
                    <span class="n">pix</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">s_img</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_img</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pix</span><span class="p">]</span>

        <span class="c1"># Explicit pixel indices</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">npix_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)))</span>
                <span class="n">idx_ravel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">npix_sum</span><span class="p">[</span><span class="n">idx_ravel</span><span class="p">],</span> <span class="n">npix_sum</span><span class="p">[</span><span class="n">idx_ravel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">pix_flat</span> <span class="o">=</span> <span class="n">unravel_hpx_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ipix</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_max</span><span class="p">)</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))]</span>

            <span class="k">for</span> <span class="n">idx_img</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_axes</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">idx_img</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">npix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">[</span><span class="n">idx_img</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">s_img</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npix</span><span class="p">),)</span> <span class="o">+</span> <span class="n">idx_img</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s_img</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npix</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">pix_flat</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)]),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">s_img</span><span class="p">]</span> <span class="o">=</span> <span class="n">pix_flat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">m</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">s_img</span><span class="p">]</span> <span class="o">=</span> <span class="n">pix_flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
                    <span class="n">pix</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">s_img</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_img</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">pix</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pix</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_to_local</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="n">p</span> <span class="o">!=</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pix</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">pix</span></div>

<div class="viewcode-block" id="HpxGeom.region_mask"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.region_mask">[docs]</a>    <span class="k">def</span> <span class="nf">region_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a mask from a given list of regions.</span>

<span class="sd">        The mask is filled such that a pixel inside the region is filled with</span>
<span class="sd">        &quot;True&quot;. To invert the mask, e.g. to create a mask with exclusion regions</span>
<span class="sd">        the tilde (~) operator can be used (see example below).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regions : str, `~regions.Region` or list of `~regions.Region`</span>
<span class="sd">            Region or list of regions (pixel or sky regions accepted).</span>
<span class="sd">            A region can be defined as a string ind DS9 format as well.</span>
<span class="sd">            See http://ds9.si.edu/doc/ref/region.html for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask_map : `~gammapy.maps.WcsNDMap` of boolean type</span>
<span class="sd">            Boolean region mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">gammapy.maps</span> <span class="kn">import</span> <span class="n">Map</span><span class="p">,</span> <span class="n">RegionGeom</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regular</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multi-resolution maps not supported yet&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: use spatial coordinates only...</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">RegionGeom</span><span class="o">.</span><span class="n">from_regions</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Map</span><span class="o">.</span><span class="n">from_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.get_coord"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.get_coord">[docs]</a>    <span class="k">def</span> <span class="nf">get_coord</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">axis_name</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span> <span class="ow">and</span> <span class="n">axis_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mode &#39;edges&#39; requires axis name to be defined&quot;</span><span class="p">)</span>

        <span class="n">pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span>
            <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span>
        <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pix_to_coord</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">MapCoord</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">axis_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">names</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="HpxGeom.contains"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_to_idx</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">t</span> <span class="o">!=</span> <span class="n">INVALID_INDEX</span><span class="o">.</span><span class="n">int</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="HpxGeom.solid_angle"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.solid_angle">[docs]</a>    <span class="k">def</span> <span class="nf">solid_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solid angle array as a `~astropy.units.Quantity` in ``sr``.</span>

<span class="sd">        The array has the same dimensionality as ``map.nside``</span>
<span class="sd">        as all pixels have the same solid angle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">return</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">nside2pixarea</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">),</span> <span class="s2">&quot;sr&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_skydir</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_skydir</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">deg</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">axes       : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">shape      : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">ndim       : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">nside      : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">nested     : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nest</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">frame      : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">projection : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">center     : </span><span class="si">{</span><span class="n">lon</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> deg, </span><span class="si">{</span><span class="n">lat</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> deg</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HpxGeom.is_allclose"><a class="viewcode-back" href="../../../../api/gammapy.maps.HpxGeom.html#gammapy.maps.HpxGeom.is_allclose">[docs]</a>    <span class="k">def</span> <span class="nf">is_allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">rtol_axes</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">atol_axes</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two data IRFs for equivalency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `HpxGeom`</span>
<span class="sd">            Geometry to compare against.</span>
<span class="sd">        rtol_axes : float, optional</span>
<span class="sd">            Relative tolerance for axes comparison.</span>
<span class="sd">            Default is 1e-6.</span>
<span class="sd">        atol_axes : float, optional</span>
<span class="sd">            Relative tolerance for axes comparison.</span>
<span class="sd">            Default is 1e-6.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_allclose : bool</span>
<span class="sd">            Whether the geometry is all close.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot compare </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allsky</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_allsky</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">axes_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">is_allclose</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol_axes</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol_axes</span><span class="p">)</span>

        <span class="n">hpx_eq</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nside</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">frame</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">order</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nest</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nest</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">axes_eq</span> <span class="ow">and</span> <span class="n">hpx_eq</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_allclose</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>
</pre></div>

              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2023, The Gammapy developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>