
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/analysis-time/light_curve_simulation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_analysis-time_light_curve_simulation.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_analysis-time_light_curve_simulation.py:


Simulating and fitting a time varying source
============================================

Simulate and fit a time decaying light curve of a source using the CTA 1DC response.

Prerequisites
-------------

-  To understand how a single binned simulation works, please refer to
   :doc:`/tutorials/analysis-1d/spectrum_simulation` tutorial and 
   :doc:`/tutorials/analysis-3d/simulate_3d` tutorial for 1D and 3D simulations
   respectively.
-  For details of light curve extraction using gammapy, refer to the two
   tutorials :doc:`/tutorials/analysis-time/light_curve` and
   :doc:`/tutorials/analysis-time/light_curve_flare` tutorial.

Context
-------

Frequently, studies of variable sources (eg: decaying GRB light curves,
AGN flares, etc) require time variable simulations. For most use cases,
generating an event list is an overkill, and it suffices to use binned
simulations using a temporal model.

**Objective: Simulate and fit a time decaying light curve of a source
with CTA using the CTA 1DC response**

Proposed approach
-----------------

We will simulate 10 spectral datasets within given time intervals (Good
Time Intervals) following a given spectral (a power law) and temporal
profile (an exponential decay, with a decay time of 6 hr ). These are
then analysed using the light curve estimator to obtain flux points.

Modelling and fitting of lightcurves can be done either - directly on
the output of the `LighCurveEstimator` (at the DL5 level) - fit the
simulated datasets (at the DL4 level)

In summary, necessary steps are:

-  Choose observation parameters including a list of
   `gammapy.data.GTI`
-  Define temporal and spectral models from :ref:model-gallery as per
   science case
-  Perform the simulation (in 1D or 3D)
-  Extract the light curve from the reduced dataset as shown
   in :doc:`/tutorials/analysis-time/light_curve` tutorial.
-  Optionally, we show here how to fit the simulated datasets using a
   source model

Setup
-----

As usual, we’ll start with some general imports…

.. GENERATED FROM PYTHON SOURCE LINES 62-65

Setup
-----


.. GENERATED FROM PYTHON SOURCE LINES 65-78

.. code-block:: python3


    import logging
    import numpy as np
    import astropy.units as u
    from astropy.coordinates import SkyCoord
    from astropy.time import Time

    # %matplotlib inline
    import matplotlib.pyplot as plt

    log = logging.getLogger(__name__)









.. GENERATED FROM PYTHON SOURCE LINES 79-81

And some gammapy specific imports


.. GENERATED FROM PYTHON SOURCE LINES 81-95

.. code-block:: python3


    from gammapy.data import Observation, observatory_locations
    from gammapy.datasets import Datasets, FluxPointsDataset, SpectrumDataset
    from gammapy.estimators import LightCurveEstimator
    from gammapy.irf import load_cta_irfs
    from gammapy.makers import SpectrumDatasetMaker
    from gammapy.maps import MapAxis, RegionGeom, TimeMapAxis
    from gammapy.modeling import Fit
    from gammapy.modeling.models import (
        ExpDecayTemporalModel,
        PowerLawSpectralModel,
        SkyModel,
    )








.. GENERATED FROM PYTHON SOURCE LINES 96-98

Check setup
-----------

.. GENERATED FROM PYTHON SOURCE LINES 98-103

.. code-block:: python3

    from gammapy.utils.check import check_tutorials_setup

    check_tutorials_setup()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    System:

            python_executable      : /home/runner/micromamba-root/envs/gammapy-dev/bin/python 
            python_version         : 3.8.13     
            machine                : x86_64     
            system                 : Linux      


    Gammapy package:

            version                : 1.1.dev115+g4c945ee81 
            path                   : /home/runner/work/gammapy-docs/gammapy-docs/gammapy/gammapy 


    Other packages:

            numpy                  : 1.22.4     
            scipy                  : 1.9.3      
            astropy                : 5.1        
            regions                : 0.6        
            click                  : 8.1.3      
            yaml                   : 6.0        
            IPython                : 8.5.0      
            jupyterlab             : 3.5.0      
            matplotlib             : 3.6.1      
            pandas                 : 1.5.1      
            healpy                 : 1.16.1     
            iminuit                : 2.17.0     
            sherpa                 : 4.15.0     
            naima                  : 0.10.0     
            emcee                  : 3.1.3      
            corner                 : 2.2.1      


    Gammapy environment variables:

            GAMMAPY_DATA           : /home/runner/work/gammapy-docs/gammapy-docs/gammapy-datasets/dev 





.. GENERATED FROM PYTHON SOURCE LINES 104-106

We first define our preferred time format:


.. GENERATED FROM PYTHON SOURCE LINES 106-110

.. code-block:: python3


    TimeMapAxis.time_format = "iso"









.. GENERATED FROM PYTHON SOURCE LINES 111-119

Simulating a light curve
------------------------

We will simulate 10 spectra between 300 GeV and 10 TeV using an
`PowerLawSpectralModel` and a `ExpDecayTemporalModel`. The important
thing to note here is how to attach a different `GTI` to each dataset.
Since we use spectrum datasets here, we will use a `RegionGeom`.


.. GENERATED FROM PYTHON SOURCE LINES 119-139

.. code-block:: python3


    # Loading IRFs
    irfs = load_cta_irfs(
        "$GAMMAPY_DATA/cta-1dc/caldb/data/cta/1dc/bcf/South_z20_50h/irf_file.fits"
    )

    # Reconstructed and true energy axis
    energy_axis = MapAxis.from_edges(
        np.logspace(-0.5, 1.0, 10), unit="TeV", name="energy", interp="log"
    )
    energy_axis_true = MapAxis.from_edges(
        np.logspace(-1.2, 2.0, 31), unit="TeV", name="energy_true", interp="log"
    )

    geom = RegionGeom.create("galactic;circle(0, 0, 0.11)", axes=[energy_axis])

    # Pointing position
    pointing = SkyCoord(0.5, 0.5, unit="deg", frame="galactic")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/core.py:2042: UnitsWarning: '1/s/MeV/sr' did not parse as fits unit: Numeric factor not supported by FITS If this is meant to be a custom unit, define it with 'u.def_unit'. To have it recognized inside a file reader or other code, enable it with 'u.add_enabled_units'. For details, see https://docs.astropy.org/en/latest/units/combining_and_defining.html
      warnings.warn(msg, UnitsWarning)




.. GENERATED FROM PYTHON SOURCE LINES 140-144

Note that observations are usually conducted in Wobble mode, in which
the source is not in the center of the camera. This allows to have a
symmetrical sky position from which background can be estimated.


.. GENERATED FROM PYTHON SOURCE LINES 144-163

.. code-block:: python3


    # Define the source model: A combination of spectral and temporal model

    gti_t0 = Time("2020-03-01")
    spectral_model = PowerLawSpectralModel(
        index=3, amplitude="1e-11 cm-2 s-1 TeV-1", reference="1 TeV"
    )
    temporal_model = ExpDecayTemporalModel(t0="6 h", t_ref=gti_t0.mjd * u.d)

    model_simu = SkyModel(
        spectral_model=spectral_model,
        temporal_model=temporal_model,
        name="model-simu",
    )

    # Look at the model
    model_simu.parameters.to_table()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: overflow encountered in exp
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)
    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: invalid value encountered in subtract
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)




.. GENERATED FROM PYTHON SOURCE LINES 164-167

Now, define the start and observation livetime wrt to the reference
time, `gti_t0`


.. GENERATED FROM PYTHON SOURCE LINES 167-174

.. code-block:: python3


    n_obs = 10

    tstart = gti_t0 + [1, 2, 3, 5, 8, 10, 20, 22, 23, 24] * u.h
    lvtm = [55, 25, 26, 40, 40, 50, 40, 52, 43, 47] * u.min









.. GENERATED FROM PYTHON SOURCE LINES 175-177

Now perform the simulations


.. GENERATED FROM PYTHON SOURCE LINES 177-204

.. code-block:: python3


    datasets = Datasets()

    empty = SpectrumDataset.create(
        geom=geom, energy_axis_true=energy_axis_true, name="empty"
    )

    maker = SpectrumDatasetMaker(selection=["exposure", "background", "edisp"])


    for idx in range(n_obs):
        obs = Observation.create(
            pointing=pointing,
            livetime=lvtm[idx],
            tstart=tstart[idx],
            irfs=irfs,
            reference_time=gti_t0,
            obs_id=idx,
            location=observatory_locations["cta_south"],
        )
        empty_i = empty.copy(name=f"dataset-{idx}")
        dataset = maker.run(empty_i, obs)
        dataset.models = model_simu
        dataset.fake()
        datasets.append(dataset)









.. GENERATED FROM PYTHON SOURCE LINES 205-208

The reduced datasets have been successfully simulated. Let’s take a
quick look into our datasets.


.. GENERATED FROM PYTHON SOURCE LINES 208-212

.. code-block:: python3


    datasets.info_table()









.. GENERATED FROM PYTHON SOURCE LINES 213-222

Extract the lightcurve
----------------------

This section uses standard light curve estimation tools for a 1D
extraction. Only a spectral model needs to be defined in this case.
Since the estimator returns the integrated flux separately for each time
bin, the temporal model need not be accounted for at this stage. We
extract the lightcurve in 3 energy binsç


.. GENERATED FROM PYTHON SOURCE LINES 222-232

.. code-block:: python3


    # Define the model:
    spectral_model = PowerLawSpectralModel(
        index=3, amplitude="1e-11 cm-2 s-1 TeV-1", reference="1 TeV"
    )
    model_fit = SkyModel(spectral_model=spectral_model, name="model-fit")

    # Attach model to all datasets
    datasets.models = model_fit








.. GENERATED FROM PYTHON SOURCE LINES 233-243

.. code-block:: python3

    lc_maker_1d = LightCurveEstimator(
        energy_edges=[0.3, 0.6, 1.0, 10] * u.TeV,
        source="model-fit",
        selection_optional=["ul"],
    )
    lc_1d = lc_maker_1d.run(datasets)

    ax = lc_1d.plot(marker="o", axis_name="time", sed_type="flux")





.. image-sg:: /tutorials/analysis-time/images/sphx_glr_light_curve_simulation_001.png
   :alt: light curve simulation
   :srcset: /tutorials/analysis-time/images/sphx_glr_light_curve_simulation_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 244-255

Fitting temporal models
-----------------------

We have the reconstructed lightcurve at this point. Now we want to fit a
profile to the obtained light curves, using a joint fitting across the
different datasets, while simultaneously minimising across the temporal
model parameters as well. The temporal models can be applied

-  directly on the obtained lightcurve
-  on the simulated datasets


.. GENERATED FROM PYTHON SOURCE LINES 258-264

Fitting the obtained light curve
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The fitting will proceed through a joint fit of the flux points. First,
we need to obtain a set of `FluxPointDatasets`, one for each time bin


.. GENERATED FROM PYTHON SOURCE LINES 264-273

.. code-block:: python3


    # Create the datasets by iterating over the returned lightcurve
    datasets = Datasets()

    for idx, fp in enumerate(lc_1d.iter_by_axis(axis_name="time")):
        dataset = FluxPointsDataset(data=fp, name=f"time-bin-{idx}")
        datasets.append(dataset)









.. GENERATED FROM PYTHON SOURCE LINES 274-278

We will fit the amplitude, spectral index and the decay time scale. Note
that `t_ref` should be fixed by default for the
`ExpDecayTemporalModel`.


.. GENERATED FROM PYTHON SOURCE LINES 278-293

.. code-block:: python3


    # Define the model:
    spectral_model1 = PowerLawSpectralModel(
        index=2.0, amplitude="1e-12 cm-2 s-1 TeV-1", reference="1 TeV"
    )
    temporal_model1 = ExpDecayTemporalModel(t0="10 h", t_ref=gti_t0.mjd * u.d)

    model = SkyModel(
        spectral_model=spectral_model1,
        temporal_model=temporal_model1,
        name="model-test",
    )

    datasets.models = model





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: overflow encountered in exp
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)
    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: invalid value encountered in subtract
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)




.. GENERATED FROM PYTHON SOURCE LINES 294-295

Do a joint fit

.. GENERATED FROM PYTHON SOURCE LINES 295-299

.. code-block:: python3

    fit = Fit()
    result = fit.run(datasets=datasets)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: overflow encountered in exp
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)
    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: invalid value encountered in subtract
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)




.. GENERATED FROM PYTHON SOURCE LINES 300-303

Now let’s plot model and data. We plot only the normalisation of the
temporal model in relative units for one particular energy range


.. GENERATED FROM PYTHON SOURCE LINES 303-314

.. code-block:: python3


    lc_1TeV_10TeV = lc_1d.slice_by_idx({"energy": slice(2, 3)})
    ax = lc_1TeV_10TeV.plot(sed_type="norm", axis_name="time")

    time_range = lc_1TeV_10TeV.geom.axes["time"].time_bounds
    temporal_model1.plot(ax=ax, time_range=time_range, label="Best fit model")

    ax.set_yscale("linear")
    plt.legend()





.. image-sg:: /tutorials/analysis-time/images/sphx_glr_light_curve_simulation_002.png
   :alt: light curve simulation
   :srcset: /tutorials/analysis-time/images/sphx_glr_light_curve_simulation_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 315-325

Fit the datasets
~~~~~~~~~~~~~~~~

Here, we apply the models directly to the simulated datasets.

For modelling and fitting more complex flares, you should attach the
relevant model to each group of `datasets`. The parameters of a model
in a given group of dataset will be tied. For more details on joint
fitting in Gammapy, see :doc:`/tutorials/analysis-3d/analysis_3d`


.. GENERATED FROM PYTHON SOURCE LINES 325-342

.. code-block:: python3


    # Define the model:
    spectral_model2 = PowerLawSpectralModel(
        index=2.0, amplitude="1e-12 cm-2 s-1 TeV-1", reference="1 TeV"
    )
    temporal_model2 = ExpDecayTemporalModel(t0="10 h", t_ref=gti_t0.mjd * u.d)

    model2 = SkyModel(
        spectral_model=spectral_model2,
        temporal_model=temporal_model2,
        name="model-test2",
    )

    model2.parameters.to_table()

    datasets.models = model2





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: overflow encountered in exp
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)
    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: invalid value encountered in subtract
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)




.. GENERATED FROM PYTHON SOURCE LINES 343-344

Do a joint fit

.. GENERATED FROM PYTHON SOURCE LINES 344-350

.. code-block:: python3

    fit = Fit()
    result = fit.run(datasets=datasets)

    result.parameters.to_table()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: overflow encountered in exp
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)
    /home/runner/micromamba-root/envs/gammapy-dev/lib/python3.8/site-packages/astropy/units/quantity.py:611: RuntimeWarning: invalid value encountered in subtract
      result = super().__array_ufunc__(function, method, *arrays, **kwargs)




.. GENERATED FROM PYTHON SOURCE LINES 351-354

We see that the fitted parameters are consistent between fitting flux
points and datasets, and match well with the simulated ones


.. GENERATED FROM PYTHON SOURCE LINES 357-366

Exercises
---------

1. Re-do the analysis with `MapDataset` instead of `SpectralDataset`
2. Model the flare of PKS 2155-304 which you obtained using the
  :doc:`/tutorials/analysis-time/light_curve_flare` tutorial.
  Use a combination of a Gaussian and Exponential flare profiles.
3. Do a joint fitting of the datasets.



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  33.134 seconds)


.. _sphx_glr_download_tutorials_analysis-time_light_curve_simulation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/gammapy/gammapy-webpage/master?urlpath=lab/tree/notebooks/dev/tutorials/analysis-time/light_curve_simulation.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: light_curve_simulation.py <light_curve_simulation.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: light_curve_simulation.ipynb <light_curve_simulation.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
